/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
package org.apache.hadoop.hbase.thrift.generated;

import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.EnumMap;
import java.util.Set;
import java.util.HashSet;
import java.util.EnumSet;
import java.util.Collections;
import java.util.BitSet;
import java.nio.ByteBuffer;
import java.util.Arrays;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.thrift.*;
import org.apache.thrift.async.*;
import org.apache.thrift.meta_data.*;
import org.apache.thrift.transport.*;
import org.apache.thrift.protocol.*;

public class Hbase {

  public interface Iface {

    /**
     * Brings a table on-line (enables it)
     *
     * @param tableName name of the table
     */
    public void enableTable(ByteBuffer tableName) throws IOError, TException;

    /**
     * Disables a table (takes it off-line) If it is being served, the master
     * will tell the servers to stop serving it.
     *
     * @param tableName name of the table
     */
    public void disableTable(ByteBuffer tableName) throws IOError, TException;

    /**
     * @return true if table is on-line
     *
     * @param tableName name of the table to check
     */
    public boolean isTableEnabled(ByteBuffer tableName) throws IOError, TException;

    public void compact(ByteBuffer tableNameOrRegionName) throws IOError, TException;

    public void majorCompact(ByteBuffer tableNameOrRegionName) throws IOError, TException;

    /**
     * List all the userspace tables.
     *
     * @return returns a list of names
     */
    public List<ByteBuffer> getTableNames() throws IOError, TException;

    /**
     * List all the column families assoicated with a table.
     *
     * @return list of column family descriptors
     *
     * @param tableName table name
     */
    public Map<ByteBuffer,ColumnDescriptor> getColumnDescriptors(ByteBuffer tableName) throws IOError, TException;

    /**
     * List the regions associated with a table.
     *
     * @return list of region descriptors
     *
     * @param tableName table name
     */
    public List<TRegionInfo> getTableRegions(ByteBuffer tableName) throws IOError, TException;

    /**
     * Create a table with the specified column families.  The name
     * field for each ColumnDescriptor must be set and must end in a
     * colon (:). All other fields are optional and will get default
     * values if not explicitly specified.
     *
     * @throws IllegalArgument if an input parameter is invalid
     *
     * @throws AlreadyExists if the table name already exists
     *
     * @param tableName name of table to create
     *
     * @param columnFamilies list of column family descriptors
     */
    public void createTable(ByteBuffer tableName, List<ColumnDescriptor> columnFamilies) throws IOError, IllegalArgument, AlreadyExists, TException;

    /**
     * Deletes a table
     *
     * @throws IOError if table doesn't exist on server or there was some other
     * problem
     *
     * @param tableName name of table to delete
     */
    public void deleteTable(ByteBuffer tableName) throws IOError, TException;

    /**
     * Get a single TCell for the specified table, row, and column at the
     * latest timestamp. Returns an empty list if no such value exists.
     *
     * @return value for specified row/column
     *
     * @param tableName name of table
     *
     * @param row row key
     *
     * @param column column name
     */
    public List<TCell> get(ByteBuffer tableName, ByteBuffer row, ByteBuffer column) throws IOError, TException;

    /**
     * Get the specified number of versions for the specified table,
     * row, and column.
     *
     * @return list of cells for specified row/column
     *
     * @param tableName name of table
     *
     * @param row row key
     *
     * @param column column name
     *
     * @param numVersions number of versions to retrieve
     */
    public List<TCell> getVer(ByteBuffer tableName, ByteBuffer row, ByteBuffer column, int numVersions) throws IOError, TException;

    /**
     * Get the specified number of versions for the specified table,
     * row, and column.  Only versions less than or equal to the specified
     * timestamp will be returned.
     *
     * @return list of cells for specified row/column
     *
     * @param tableName name of table
     *
     * @param row row key
     *
     * @param column column name
     *
     * @param timestamp timestamp
     *
     * @param numVersions number of versions to retrieve
     */
    public List<TCell> getVerTs(ByteBuffer tableName, ByteBuffer row, ByteBuffer column, long timestamp, int numVersions) throws IOError, TException;

    /**
     * Get all the data for the specified table and row at the latest
     * timestamp. Returns an empty list if the row does not exist.
     *
     * @return TRowResult containing the row and map of columns to TCells
     *
     * @param tableName name of table
     *
     * @param row row key
     */
    public List<TRowResult> getRow(ByteBuffer tableName, ByteBuffer row) throws IOError, TException;

    /**
     * Get the specified columns for the specified table and row at the latest
     * timestamp. Returns an empty list if the row does not exist.
     *
     * @return TRowResult containing the row and map of columns to TCells
     *
     * @param tableName name of table
     *
     * @param row row key
     *
     * @param columns List of columns to return, null for all columns
     */
    public List<TRowResult> getRowWithColumns(ByteBuffer tableName, ByteBuffer row, List<ByteBuffer> columns) throws IOError, TException;

    /**
     * Get all the data for the specified table and row at the specified
     * timestamp. Returns an empty list if the row does not exist.
     *
     * @return TRowResult containing the row and map of columns to TCells
     *
     * @param tableName name of the table
     *
     * @param row row key
     *
     * @param timestamp timestamp
     */
    public List<TRowResult> getRowTs(ByteBuffer tableName, ByteBuffer row, long timestamp) throws IOError, TException;

    /**
     * Get the specified columns for the specified table and row at the specified
     * timestamp. Returns an empty list if the row does not exist.
     *
     * @return TRowResult containing the row and map of columns to TCells
     *
     * @param tableName name of table
     *
     * @param row row key
     *
     * @param columns List of columns to return, null for all columns
     *
     * @param timestamp
     */
    public List<TRowResult> getRowWithColumnsTs(ByteBuffer tableName, ByteBuffer row, List<ByteBuffer> columns, long timestamp) throws IOError, TException;

    /**
     * Get all the data for the specified table and rows at the latest
     * timestamp. Returns an empty list if no rows exist.
     *
     * @return TRowResult containing the rows and map of columns to TCells
     *
     * @param tableName name of table
     *
     * @param rows row keys
     */
    public List<TRowResult> getRows(ByteBuffer tableName, List<ByteBuffer> rows) throws IOError, TException;

    /**
     * Get the specified columns for the specified table and rows at the latest
     * timestamp. Returns an empty list if no rows exist.
     *
     * @return TRowResult containing the rows and map of columns to TCells
     *
     * @param tableName name of table
     *
     * @param rows row keys
     *
     * @param columns List of columns to return, null for all columns
     */
    public List<TRowResult> getRowsWithColumns(ByteBuffer tableName, List<ByteBuffer> rows, List<ByteBuffer> columns) throws IOError, TException;

    /**
     * Get all the data for the specified table and rows at the specified
     * timestamp. Returns an empty list if no rows exist.
     *
     * @return TRowResult containing the rows and map of columns to TCells
     *
     * @param tableName name of the table
     *
     * @param rows row keys
     *
     * @param timestamp timestamp
     */
    public List<TRowResult> getRowsTs(ByteBuffer tableName, List<ByteBuffer> rows, long timestamp) throws IOError, TException;

    /**
     * Get the specified columns for the specified table and rows at the specified
     * timestamp. Returns an empty list if no rows exist.
     *
     * @return TRowResult containing the rows and map of columns to TCells
     *
     * @param tableName name of table
     *
     * @param rows row keys
     *
     * @param columns List of columns to return, null for all columns
     *
     * @param timestamp
     */
    public List<TRowResult> getRowsWithColumnsTs(ByteBuffer tableName, List<ByteBuffer> rows, List<ByteBuffer> columns, long timestamp) throws IOError, TException;

    /**
     * Apply a series of mutations (updates/deletes) to a row in a
     * single transaction.  If an exception is thrown, then the
     * transaction is aborted.  Default current timestamp is used, and
     * all entries will have an identical timestamp.
     *
     * @param tableName name of table
     *
     * @param row row key
     *
     * @param mutations list of mutation commands
     */
    public void mutateRow(ByteBuffer tableName, ByteBuffer row, List<Mutation> mutations) throws IOError, IllegalArgument, TException;

    /**
     * Apply a series of mutations (updates/deletes) to a row in a
     * single transaction.  If an exception is thrown, then the
     * transaction is aborted.  The specified timestamp is used, and
     * all entries will have an identical timestamp.
     *
     * @param tableName name of table
     *
     * @param row row key
     *
     * @param mutations list of mutation commands
     *
     * @param timestamp timestamp
     */
    public void mutateRowTs(ByteBuffer tableName, ByteBuffer row, List<Mutation> mutations, long timestamp) throws IOError, IllegalArgument, TException;

    /**
     * Apply a series of batches (each a series of mutations on a single row)
     * in a single transaction.  If an exception is thrown, then the
     * transaction is aborted.  Default current timestamp is used, and
     * all entries will have an identical timestamp.
     *
     * @param tableName name of table
     *
     * @param rowBatches list of row batches
     */
    public void mutateRows(ByteBuffer tableName, List<BatchMutation> rowBatches) throws IOError, IllegalArgument, TException;

    /**
     * Apply a series of batches (each a series of mutations on a single row)
     * in a single transaction.  If an exception is thrown, then the
     * transaction is aborted.  The specified timestamp is used, and
     * all entries will have an identical timestamp.
     *
     * @param tableName name of table
     *
     * @param rowBatches list of row batches
     *
     * @param timestamp timestamp
     */
    public void mutateRowsTs(ByteBuffer tableName, List<BatchMutation> rowBatches, long timestamp) throws IOError, IllegalArgument, TException;

    /**
     * Atomically increment the column value specified.  Returns the next value post increment.
     *
     * @param tableName name of table
     *
     * @param row row to increment
     *
     * @param column name of column
     *
     * @param value amount to increment by
     */
    public long atomicIncrement(ByteBuffer tableName, ByteBuffer row, ByteBuffer column, long value) throws IOError, IllegalArgument, TException;

    /**
     * Delete all cells that match the passed row and column.
     *
     * @param tableName name of table
     *
     * @param row Row to update
     *
     * @param column name of column whose value is to be deleted
     */
    public void deleteAll(ByteBuffer tableName, ByteBuffer row, ByteBuffer column) throws IOError, TException;

    /**
     * Delete all cells that match the passed row and column and whose
     * timestamp is equal-to or older than the passed timestamp.
     *
     * @param tableName name of table
     *
     * @param row Row to update
     *
     * @param column name of column whose value is to be deleted
     *
     * @param timestamp timestamp
     */
    public void deleteAllTs(ByteBuffer tableName, ByteBuffer row, ByteBuffer column, long timestamp) throws IOError, TException;

    /**
     * Completely delete the row's cells.
     *
     * @param tableName name of table
     *
     * @param row key of the row to be completely deleted.
     */
    public void deleteAllRow(ByteBuffer tableName, ByteBuffer row) throws IOError, TException;

    /**
     * Completely delete the row's cells marked with a timestamp
     * equal-to or older than the passed timestamp.
     *
     * @param tableName name of table
     *
     * @param row key of the row to be completely deleted.
     *
     * @param timestamp timestamp
     */
    public void deleteAllRowTs(ByteBuffer tableName, ByteBuffer row, long timestamp) throws IOError, TException;

    /**
     * Get a scanner on the current table starting at the specified row and
     * ending at the last row in the table.  Return the specified columns.
     *
     * @return scanner id to be used with other scanner procedures
     *
     * @param tableName name of table
     *
     * @param startRow Starting row in table to scan.
     * Send "" (empty string) to start at the first row.
     *
     * @param columns columns to scan. If column name is a column family, all
     * columns of the specified column family are returned. It's also possible
     * to pass a regex in the column qualifier.
     */
    public int scannerOpen(ByteBuffer tableName, ByteBuffer startRow, List<ByteBuffer> columns) throws IOError, TException;

    /**
     * Get a scanner on the current table starting and stopping at the
     * specified rows.  ending at the last row in the table.  Return the
     * specified columns.
     *
     * @return scanner id to be used with other scanner procedures
     *
     * @param tableName name of table
     *
     * @param startRow Starting row in table to scan.
     * Send "" (empty string) to start at the first row.
     *
     * @param stopRow row to stop scanning on. This row is *not* included in the
     * scanner's results
     *
     * @param columns columns to scan. If column name is a column family, all
     * columns of the specified column family are returned. It's also possible
     * to pass a regex in the column qualifier.
     */
    public int scannerOpenWithStop(ByteBuffer tableName, ByteBuffer startRow, ByteBuffer stopRow, List<ByteBuffer> columns) throws IOError, TException;

    /**
     * Open a scanner for a given prefix.  That is all rows will have the specified
     * prefix. No other rows will be returned.
     *
     * @return scanner id to use with other scanner calls
     *
     * @param tableName name of table
     *
     * @param startAndPrefix the prefix (and thus start row) of the keys you want
     *
     * @param columns the columns you want returned
     */
    public int scannerOpenWithPrefix(ByteBuffer tableName, ByteBuffer startAndPrefix, List<ByteBuffer> columns) throws IOError, TException;

    /**
     * Get a scanner on the current table starting at the specified row and
     * ending at the last row in the table.  Return the specified columns.
     * Only values with the specified timestamp are returned.
     *
     * @return scanner id to be used with other scanner procedures
     *
     * @param tableName name of table
     *
     * @param startRow Starting row in table to scan.
     * Send "" (empty string) to start at the first row.
     *
     * @param columns columns to scan. If column name is a column family, all
     * columns of the specified column family are returned. It's also possible
     * to pass a regex in the column qualifier.
     *
     * @param timestamp timestamp
     */
    public int scannerOpenTs(ByteBuffer tableName, ByteBuffer startRow, List<ByteBuffer> columns, long timestamp) throws IOError, TException;

    /**
     * Get a scanner on the current table starting and stopping at the
     * specified rows.  ending at the last row in the table.  Return the
     * specified columns.  Only values with the specified timestamp are
     * returned.
     *
     * @return scanner id to be used with other scanner procedures
     *
     * @param tableName name of table
     *
     * @param startRow Starting row in table to scan.
     * Send "" (empty string) to start at the first row.
     *
     * @param stopRow row to stop scanning on. This row is *not* included in the
     * scanner's results
     *
     * @param columns columns to scan. If column name is a column family, all
     * columns of the specified column family are returned. It's also possible
     * to pass a regex in the column qualifier.
     *
     * @param timestamp timestamp
     */
    public int scannerOpenWithStopTs(ByteBuffer tableName, ByteBuffer startRow, ByteBuffer stopRow, List<ByteBuffer> columns, long timestamp) throws IOError, TException;

    /**
     * Returns the scanner's current row value and advances to the next
     * row in the table.  When there are no more rows in the table, or a key
     * greater-than-or-equal-to the scanner's specified stopRow is reached,
     * an empty list is returned.
     *
     * @return a TRowResult containing the current row and a map of the columns to TCells.
     *
     * @throws IllegalArgument if ScannerID is invalid
     *
     * @throws NotFound when the scanner reaches the end
     *
     * @param id id of a scanner returned by scannerOpen
     */
    public List<TRowResult> scannerGet(int id) throws IOError, IllegalArgument, TException;

    /**
     * Returns, starting at the scanner's current row value nbRows worth of
     * rows and advances to the next row in the table.  When there are no more
     * rows in the table, or a key greater-than-or-equal-to the scanner's
     * specified stopRow is reached,  an empty list is returned.
     *
     * @return a TRowResult containing the current row and a map of the columns to TCells.
     *
     * @throws IllegalArgument if ScannerID is invalid
     *
     * @throws NotFound when the scanner reaches the end
     *
     * @param id id of a scanner returned by scannerOpen
     *
     * @param nbRows number of results to return
     */
    public List<TRowResult> scannerGetList(int id, int nbRows) throws IOError, IllegalArgument, TException;

    /**
     * Closes the server-state associated with an open scanner.
     *
     * @throws IllegalArgument if ScannerID is invalid
     *
     * @param id id of a scanner returned by scannerOpen
     */
    public void scannerClose(int id) throws IOError, IllegalArgument, TException;

    /**
     * Parallel get. For a given table and column, return for
     * the given rows.
     *
     * @param tableName table to get from
     * @param column column to get
     * @param rows a list of rows to get
     * @result list of TRowResult for each item
     *
     * @param tableName
     * @param column
     * @param rows
     */
    public List<TRowResult> parallelGet(ByteBuffer tableName, ByteBuffer column, List<ByteBuffer> rows) throws IOError, TException;

    /**
     * Do an async series of atomic increments.
     *
     * @param increments a list of increments to apply
     *
     * @param increments
     */
    public void asyncAtomicIncrements(List<Increment> increments) throws TException;

    /**
     * Submit a series of updates to be processed. If the return value
     * is true, then it worked and you can forget. If the return value
     * is FALSE then there was a failure and none of the increments were
     * queued to be applied.
     *
     * @param increments
     */
    public boolean queueIncrementColumnValues(List<Increment> increments) throws TException;

  }

  public interface AsyncIface {

    public void enableTable(ByteBuffer tableName, AsyncMethodCallback<AsyncClient.enableTable_call> resultHandler) throws TException;

    public void disableTable(ByteBuffer tableName, AsyncMethodCallback<AsyncClient.disableTable_call> resultHandler) throws TException;

    public void isTableEnabled(ByteBuffer tableName, AsyncMethodCallback<AsyncClient.isTableEnabled_call> resultHandler) throws TException;

    public void compact(ByteBuffer tableNameOrRegionName, AsyncMethodCallback<AsyncClient.compact_call> resultHandler) throws TException;

    public void majorCompact(ByteBuffer tableNameOrRegionName, AsyncMethodCallback<AsyncClient.majorCompact_call> resultHandler) throws TException;

    public void getTableNames(AsyncMethodCallback<AsyncClient.getTableNames_call> resultHandler) throws TException;

    public void getColumnDescriptors(ByteBuffer tableName, AsyncMethodCallback<AsyncClient.getColumnDescriptors_call> resultHandler) throws TException;

    public void getTableRegions(ByteBuffer tableName, AsyncMethodCallback<AsyncClient.getTableRegions_call> resultHandler) throws TException;

    public void createTable(ByteBuffer tableName, List<ColumnDescriptor> columnFamilies, AsyncMethodCallback<AsyncClient.createTable_call> resultHandler) throws TException;

    public void deleteTable(ByteBuffer tableName, AsyncMethodCallback<AsyncClient.deleteTable_call> resultHandler) throws TException;

    public void get(ByteBuffer tableName, ByteBuffer row, ByteBuffer column, AsyncMethodCallback<AsyncClient.get_call> resultHandler) throws TException;

    public void getVer(ByteBuffer tableName, ByteBuffer row, ByteBuffer column, int numVersions, AsyncMethodCallback<AsyncClient.getVer_call> resultHandler) throws TException;

    public void getVerTs(ByteBuffer tableName, ByteBuffer row, ByteBuffer column, long timestamp, int numVersions, AsyncMethodCallback<AsyncClient.getVerTs_call> resultHandler) throws TException;

    public void getRow(ByteBuffer tableName, ByteBuffer row, AsyncMethodCallback<AsyncClient.getRow_call> resultHandler) throws TException;

    public void getRowWithColumns(ByteBuffer tableName, ByteBuffer row, List<ByteBuffer> columns, AsyncMethodCallback<AsyncClient.getRowWithColumns_call> resultHandler) throws TException;

    public void getRowTs(ByteBuffer tableName, ByteBuffer row, long timestamp, AsyncMethodCallback<AsyncClient.getRowTs_call> resultHandler) throws TException;

    public void getRowWithColumnsTs(ByteBuffer tableName, ByteBuffer row, List<ByteBuffer> columns, long timestamp, AsyncMethodCallback<AsyncClient.getRowWithColumnsTs_call> resultHandler) throws TException;

    public void getRows(ByteBuffer tableName, List<ByteBuffer> rows, AsyncMethodCallback<AsyncClient.getRows_call> resultHandler) throws TException;

    public void getRowsWithColumns(ByteBuffer tableName, List<ByteBuffer> rows, List<ByteBuffer> columns, AsyncMethodCallback<AsyncClient.getRowsWithColumns_call> resultHandler) throws TException;

    public void getRowsTs(ByteBuffer tableName, List<ByteBuffer> rows, long timestamp, AsyncMethodCallback<AsyncClient.getRowsTs_call> resultHandler) throws TException;

    public void getRowsWithColumnsTs(ByteBuffer tableName, List<ByteBuffer> rows, List<ByteBuffer> columns, long timestamp, AsyncMethodCallback<AsyncClient.getRowsWithColumnsTs_call> resultHandler) throws TException;

    public void mutateRow(ByteBuffer tableName, ByteBuffer row, List<Mutation> mutations, AsyncMethodCallback<AsyncClient.mutateRow_call> resultHandler) throws TException;

    public void mutateRowTs(ByteBuffer tableName, ByteBuffer row, List<Mutation> mutations, long timestamp, AsyncMethodCallback<AsyncClient.mutateRowTs_call> resultHandler) throws TException;

    public void mutateRows(ByteBuffer tableName, List<BatchMutation> rowBatches, AsyncMethodCallback<AsyncClient.mutateRows_call> resultHandler) throws TException;

    public void mutateRowsTs(ByteBuffer tableName, List<BatchMutation> rowBatches, long timestamp, AsyncMethodCallback<AsyncClient.mutateRowsTs_call> resultHandler) throws TException;

    public void atomicIncrement(ByteBuffer tableName, ByteBuffer row, ByteBuffer column, long value, AsyncMethodCallback<AsyncClient.atomicIncrement_call> resultHandler) throws TException;

    public void deleteAll(ByteBuffer tableName, ByteBuffer row, ByteBuffer column, AsyncMethodCallback<AsyncClient.deleteAll_call> resultHandler) throws TException;

    public void deleteAllTs(ByteBuffer tableName, ByteBuffer row, ByteBuffer column, long timestamp, AsyncMethodCallback<AsyncClient.deleteAllTs_call> resultHandler) throws TException;

    public void deleteAllRow(ByteBuffer tableName, ByteBuffer row, AsyncMethodCallback<AsyncClient.deleteAllRow_call> resultHandler) throws TException;

    public void deleteAllRowTs(ByteBuffer tableName, ByteBuffer row, long timestamp, AsyncMethodCallback<AsyncClient.deleteAllRowTs_call> resultHandler) throws TException;

    public void scannerOpen(ByteBuffer tableName, ByteBuffer startRow, List<ByteBuffer> columns, AsyncMethodCallback<AsyncClient.scannerOpen_call> resultHandler) throws TException;

    public void scannerOpenWithStop(ByteBuffer tableName, ByteBuffer startRow, ByteBuffer stopRow, List<ByteBuffer> columns, AsyncMethodCallback<AsyncClient.scannerOpenWithStop_call> resultHandler) throws TException;

    public void scannerOpenWithPrefix(ByteBuffer tableName, ByteBuffer startAndPrefix, List<ByteBuffer> columns, AsyncMethodCallback<AsyncClient.scannerOpenWithPrefix_call> resultHandler) throws TException;

    public void scannerOpenTs(ByteBuffer tableName, ByteBuffer startRow, List<ByteBuffer> columns, long timestamp, AsyncMethodCallback<AsyncClient.scannerOpenTs_call> resultHandler) throws TException;

    public void scannerOpenWithStopTs(ByteBuffer tableName, ByteBuffer startRow, ByteBuffer stopRow, List<ByteBuffer> columns, long timestamp, AsyncMethodCallback<AsyncClient.scannerOpenWithStopTs_call> resultHandler) throws TException;

    public void scannerGet(int id, AsyncMethodCallback<AsyncClient.scannerGet_call> resultHandler) throws TException;

    public void scannerGetList(int id, int nbRows, AsyncMethodCallback<AsyncClient.scannerGetList_call> resultHandler) throws TException;

    public void scannerClose(int id, AsyncMethodCallback<AsyncClient.scannerClose_call> resultHandler) throws TException;

    public void parallelGet(ByteBuffer tableName, ByteBuffer column, List<ByteBuffer> rows, AsyncMethodCallback<AsyncClient.parallelGet_call> resultHandler) throws TException;

    public void asyncAtomicIncrements(List<Increment> increments, AsyncMethodCallback<AsyncClient.asyncAtomicIncrements_call> resultHandler) throws TException;

    public void queueIncrementColumnValues(List<Increment> increments, AsyncMethodCallback<AsyncClient.queueIncrementColumnValues_call> resultHandler) throws TException;

  }

  public static class Client implements TServiceClient, Iface {
    public static class Factory implements TServiceClientFactory<Client> {
      public Factory() {}
      public Client getClient(TProtocol prot) {
        return new Client(prot);
      }
      public Client getClient(TProtocol iprot, TProtocol oprot) {
        return new Client(iprot, oprot);
      }
    }

    public Client(TProtocol prot)
    {
      this(prot, prot);
    }

    public Client(TProtocol iprot, TProtocol oprot)
    {
      iprot_ = iprot;
      oprot_ = oprot;
    }

    protected TProtocol iprot_;
    protected TProtocol oprot_;

    protected int seqid_;

    public TProtocol getInputProtocol()
    {
      return this.iprot_;
    }

    public TProtocol getOutputProtocol()
    {
      return this.oprot_;
    }

    public void enableTable(ByteBuffer tableName) throws IOError, TException
    {
      send_enableTable(tableName);
      recv_enableTable();
    }

    public void send_enableTable(ByteBuffer tableName) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("enableTable", TMessageType.CALL, ++seqid_));
      enableTable_args args = new enableTable_args();
      args.setTableName(tableName);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_enableTable() throws IOError, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "enableTable failed: out of sequence response");
      }
      enableTable_result result = new enableTable_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.io != null) {
        throw result.io;
      }
      return;
    }

    public void disableTable(ByteBuffer tableName) throws IOError, TException
    {
      send_disableTable(tableName);
      recv_disableTable();
    }

    public void send_disableTable(ByteBuffer tableName) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("disableTable", TMessageType.CALL, ++seqid_));
      disableTable_args args = new disableTable_args();
      args.setTableName(tableName);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_disableTable() throws IOError, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "disableTable failed: out of sequence response");
      }
      disableTable_result result = new disableTable_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.io != null) {
        throw result.io;
      }
      return;
    }

    public boolean isTableEnabled(ByteBuffer tableName) throws IOError, TException
    {
      send_isTableEnabled(tableName);
      return recv_isTableEnabled();
    }

    public void send_isTableEnabled(ByteBuffer tableName) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("isTableEnabled", TMessageType.CALL, ++seqid_));
      isTableEnabled_args args = new isTableEnabled_args();
      args.setTableName(tableName);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public boolean recv_isTableEnabled() throws IOError, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "isTableEnabled failed: out of sequence response");
      }
      isTableEnabled_result result = new isTableEnabled_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.io != null) {
        throw result.io;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "isTableEnabled failed: unknown result");
    }

    public void compact(ByteBuffer tableNameOrRegionName) throws IOError, TException
    {
      send_compact(tableNameOrRegionName);
      recv_compact();
    }

    public void send_compact(ByteBuffer tableNameOrRegionName) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("compact", TMessageType.CALL, ++seqid_));
      compact_args args = new compact_args();
      args.setTableNameOrRegionName(tableNameOrRegionName);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_compact() throws IOError, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "compact failed: out of sequence response");
      }
      compact_result result = new compact_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.io != null) {
        throw result.io;
      }
      return;
    }

    public void majorCompact(ByteBuffer tableNameOrRegionName) throws IOError, TException
    {
      send_majorCompact(tableNameOrRegionName);
      recv_majorCompact();
    }

    public void send_majorCompact(ByteBuffer tableNameOrRegionName) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("majorCompact", TMessageType.CALL, ++seqid_));
      majorCompact_args args = new majorCompact_args();
      args.setTableNameOrRegionName(tableNameOrRegionName);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_majorCompact() throws IOError, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "majorCompact failed: out of sequence response");
      }
      majorCompact_result result = new majorCompact_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.io != null) {
        throw result.io;
      }
      return;
    }

    public List<ByteBuffer> getTableNames() throws IOError, TException
    {
      send_getTableNames();
      return recv_getTableNames();
    }

    public void send_getTableNames() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getTableNames", TMessageType.CALL, ++seqid_));
      getTableNames_args args = new getTableNames_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<ByteBuffer> recv_getTableNames() throws IOError, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getTableNames failed: out of sequence response");
      }
      getTableNames_result result = new getTableNames_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.io != null) {
        throw result.io;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getTableNames failed: unknown result");
    }

    public Map<ByteBuffer,ColumnDescriptor> getColumnDescriptors(ByteBuffer tableName) throws IOError, TException
    {
      send_getColumnDescriptors(tableName);
      return recv_getColumnDescriptors();
    }

    public void send_getColumnDescriptors(ByteBuffer tableName) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getColumnDescriptors", TMessageType.CALL, ++seqid_));
      getColumnDescriptors_args args = new getColumnDescriptors_args();
      args.setTableName(tableName);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public Map<ByteBuffer,ColumnDescriptor> recv_getColumnDescriptors() throws IOError, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getColumnDescriptors failed: out of sequence response");
      }
      getColumnDescriptors_result result = new getColumnDescriptors_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.io != null) {
        throw result.io;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getColumnDescriptors failed: unknown result");
    }

    public List<TRegionInfo> getTableRegions(ByteBuffer tableName) throws IOError, TException
    {
      send_getTableRegions(tableName);
      return recv_getTableRegions();
    }

    public void send_getTableRegions(ByteBuffer tableName) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getTableRegions", TMessageType.CALL, ++seqid_));
      getTableRegions_args args = new getTableRegions_args();
      args.setTableName(tableName);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<TRegionInfo> recv_getTableRegions() throws IOError, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getTableRegions failed: out of sequence response");
      }
      getTableRegions_result result = new getTableRegions_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.io != null) {
        throw result.io;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getTableRegions failed: unknown result");
    }

    public void createTable(ByteBuffer tableName, List<ColumnDescriptor> columnFamilies) throws IOError, IllegalArgument, AlreadyExists, TException
    {
      send_createTable(tableName, columnFamilies);
      recv_createTable();
    }

    public void send_createTable(ByteBuffer tableName, List<ColumnDescriptor> columnFamilies) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("createTable", TMessageType.CALL, ++seqid_));
      createTable_args args = new createTable_args();
      args.setTableName(tableName);
      args.setColumnFamilies(columnFamilies);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_createTable() throws IOError, IllegalArgument, AlreadyExists, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "createTable failed: out of sequence response");
      }
      createTable_result result = new createTable_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.io != null) {
        throw result.io;
      }
      if (result.ia != null) {
        throw result.ia;
      }
      if (result.exist != null) {
        throw result.exist;
      }
      return;
    }

    public void deleteTable(ByteBuffer tableName) throws IOError, TException
    {
      send_deleteTable(tableName);
      recv_deleteTable();
    }

    public void send_deleteTable(ByteBuffer tableName) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("deleteTable", TMessageType.CALL, ++seqid_));
      deleteTable_args args = new deleteTable_args();
      args.setTableName(tableName);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_deleteTable() throws IOError, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "deleteTable failed: out of sequence response");
      }
      deleteTable_result result = new deleteTable_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.io != null) {
        throw result.io;
      }
      return;
    }

    public List<TCell> get(ByteBuffer tableName, ByteBuffer row, ByteBuffer column) throws IOError, TException
    {
      send_get(tableName, row, column);
      return recv_get();
    }

    public void send_get(ByteBuffer tableName, ByteBuffer row, ByteBuffer column) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get", TMessageType.CALL, ++seqid_));
      get_args args = new get_args();
      args.setTableName(tableName);
      args.setRow(row);
      args.setColumn(column);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<TCell> recv_get() throws IOError, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "get failed: out of sequence response");
      }
      get_result result = new get_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.io != null) {
        throw result.io;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get failed: unknown result");
    }

    public List<TCell> getVer(ByteBuffer tableName, ByteBuffer row, ByteBuffer column, int numVersions) throws IOError, TException
    {
      send_getVer(tableName, row, column, numVersions);
      return recv_getVer();
    }

    public void send_getVer(ByteBuffer tableName, ByteBuffer row, ByteBuffer column, int numVersions) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getVer", TMessageType.CALL, ++seqid_));
      getVer_args args = new getVer_args();
      args.setTableName(tableName);
      args.setRow(row);
      args.setColumn(column);
      args.setNumVersions(numVersions);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<TCell> recv_getVer() throws IOError, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getVer failed: out of sequence response");
      }
      getVer_result result = new getVer_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.io != null) {
        throw result.io;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getVer failed: unknown result");
    }

    public List<TCell> getVerTs(ByteBuffer tableName, ByteBuffer row, ByteBuffer column, long timestamp, int numVersions) throws IOError, TException
    {
      send_getVerTs(tableName, row, column, timestamp, numVersions);
      return recv_getVerTs();
    }

    public void send_getVerTs(ByteBuffer tableName, ByteBuffer row, ByteBuffer column, long timestamp, int numVersions) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getVerTs", TMessageType.CALL, ++seqid_));
      getVerTs_args args = new getVerTs_args();
      args.setTableName(tableName);
      args.setRow(row);
      args.setColumn(column);
      args.setTimestamp(timestamp);
      args.setNumVersions(numVersions);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<TCell> recv_getVerTs() throws IOError, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getVerTs failed: out of sequence response");
      }
      getVerTs_result result = new getVerTs_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.io != null) {
        throw result.io;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getVerTs failed: unknown result");
    }

    public List<TRowResult> getRow(ByteBuffer tableName, ByteBuffer row) throws IOError, TException
    {
      send_getRow(tableName, row);
      return recv_getRow();
    }

    public void send_getRow(ByteBuffer tableName, ByteBuffer row) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getRow", TMessageType.CALL, ++seqid_));
      getRow_args args = new getRow_args();
      args.setTableName(tableName);
      args.setRow(row);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<TRowResult> recv_getRow() throws IOError, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getRow failed: out of sequence response");
      }
      getRow_result result = new getRow_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.io != null) {
        throw result.io;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getRow failed: unknown result");
    }

    public List<TRowResult> getRowWithColumns(ByteBuffer tableName, ByteBuffer row, List<ByteBuffer> columns) throws IOError, TException
    {
      send_getRowWithColumns(tableName, row, columns);
      return recv_getRowWithColumns();
    }

    public void send_getRowWithColumns(ByteBuffer tableName, ByteBuffer row, List<ByteBuffer> columns) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getRowWithColumns", TMessageType.CALL, ++seqid_));
      getRowWithColumns_args args = new getRowWithColumns_args();
      args.setTableName(tableName);
      args.setRow(row);
      args.setColumns(columns);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<TRowResult> recv_getRowWithColumns() throws IOError, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getRowWithColumns failed: out of sequence response");
      }
      getRowWithColumns_result result = new getRowWithColumns_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.io != null) {
        throw result.io;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getRowWithColumns failed: unknown result");
    }

    public List<TRowResult> getRowTs(ByteBuffer tableName, ByteBuffer row, long timestamp) throws IOError, TException
    {
      send_getRowTs(tableName, row, timestamp);
      return recv_getRowTs();
    }

    public void send_getRowTs(ByteBuffer tableName, ByteBuffer row, long timestamp) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getRowTs", TMessageType.CALL, ++seqid_));
      getRowTs_args args = new getRowTs_args();
      args.setTableName(tableName);
      args.setRow(row);
      args.setTimestamp(timestamp);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<TRowResult> recv_getRowTs() throws IOError, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getRowTs failed: out of sequence response");
      }
      getRowTs_result result = new getRowTs_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.io != null) {
        throw result.io;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getRowTs failed: unknown result");
    }

    public List<TRowResult> getRowWithColumnsTs(ByteBuffer tableName, ByteBuffer row, List<ByteBuffer> columns, long timestamp) throws IOError, TException
    {
      send_getRowWithColumnsTs(tableName, row, columns, timestamp);
      return recv_getRowWithColumnsTs();
    }

    public void send_getRowWithColumnsTs(ByteBuffer tableName, ByteBuffer row, List<ByteBuffer> columns, long timestamp) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getRowWithColumnsTs", TMessageType.CALL, ++seqid_));
      getRowWithColumnsTs_args args = new getRowWithColumnsTs_args();
      args.setTableName(tableName);
      args.setRow(row);
      args.setColumns(columns);
      args.setTimestamp(timestamp);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<TRowResult> recv_getRowWithColumnsTs() throws IOError, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getRowWithColumnsTs failed: out of sequence response");
      }
      getRowWithColumnsTs_result result = new getRowWithColumnsTs_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.io != null) {
        throw result.io;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getRowWithColumnsTs failed: unknown result");
    }

    public List<TRowResult> getRows(ByteBuffer tableName, List<ByteBuffer> rows) throws IOError, TException
    {
      send_getRows(tableName, rows);
      return recv_getRows();
    }

    public void send_getRows(ByteBuffer tableName, List<ByteBuffer> rows) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getRows", TMessageType.CALL, ++seqid_));
      getRows_args args = new getRows_args();
      args.setTableName(tableName);
      args.setRows(rows);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<TRowResult> recv_getRows() throws IOError, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getRows failed: out of sequence response");
      }
      getRows_result result = new getRows_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.io != null) {
        throw result.io;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getRows failed: unknown result");
    }

    public List<TRowResult> getRowsWithColumns(ByteBuffer tableName, List<ByteBuffer> rows, List<ByteBuffer> columns) throws IOError, TException
    {
      send_getRowsWithColumns(tableName, rows, columns);
      return recv_getRowsWithColumns();
    }

    public void send_getRowsWithColumns(ByteBuffer tableName, List<ByteBuffer> rows, List<ByteBuffer> columns) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getRowsWithColumns", TMessageType.CALL, ++seqid_));
      getRowsWithColumns_args args = new getRowsWithColumns_args();
      args.setTableName(tableName);
      args.setRows(rows);
      args.setColumns(columns);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<TRowResult> recv_getRowsWithColumns() throws IOError, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getRowsWithColumns failed: out of sequence response");
      }
      getRowsWithColumns_result result = new getRowsWithColumns_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.io != null) {
        throw result.io;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getRowsWithColumns failed: unknown result");
    }

    public List<TRowResult> getRowsTs(ByteBuffer tableName, List<ByteBuffer> rows, long timestamp) throws IOError, TException
    {
      send_getRowsTs(tableName, rows, timestamp);
      return recv_getRowsTs();
    }

    public void send_getRowsTs(ByteBuffer tableName, List<ByteBuffer> rows, long timestamp) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getRowsTs", TMessageType.CALL, ++seqid_));
      getRowsTs_args args = new getRowsTs_args();
      args.setTableName(tableName);
      args.setRows(rows);
      args.setTimestamp(timestamp);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<TRowResult> recv_getRowsTs() throws IOError, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getRowsTs failed: out of sequence response");
      }
      getRowsTs_result result = new getRowsTs_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.io != null) {
        throw result.io;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getRowsTs failed: unknown result");
    }

    public List<TRowResult> getRowsWithColumnsTs(ByteBuffer tableName, List<ByteBuffer> rows, List<ByteBuffer> columns, long timestamp) throws IOError, TException
    {
      send_getRowsWithColumnsTs(tableName, rows, columns, timestamp);
      return recv_getRowsWithColumnsTs();
    }

    public void send_getRowsWithColumnsTs(ByteBuffer tableName, List<ByteBuffer> rows, List<ByteBuffer> columns, long timestamp) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getRowsWithColumnsTs", TMessageType.CALL, ++seqid_));
      getRowsWithColumnsTs_args args = new getRowsWithColumnsTs_args();
      args.setTableName(tableName);
      args.setRows(rows);
      args.setColumns(columns);
      args.setTimestamp(timestamp);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<TRowResult> recv_getRowsWithColumnsTs() throws IOError, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getRowsWithColumnsTs failed: out of sequence response");
      }
      getRowsWithColumnsTs_result result = new getRowsWithColumnsTs_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.io != null) {
        throw result.io;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getRowsWithColumnsTs failed: unknown result");
    }

    public void mutateRow(ByteBuffer tableName, ByteBuffer row, List<Mutation> mutations) throws IOError, IllegalArgument, TException
    {
      send_mutateRow(tableName, row, mutations);
      recv_mutateRow();
    }

    public void send_mutateRow(ByteBuffer tableName, ByteBuffer row, List<Mutation> mutations) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("mutateRow", TMessageType.CALL, ++seqid_));
      mutateRow_args args = new mutateRow_args();
      args.setTableName(tableName);
      args.setRow(row);
      args.setMutations(mutations);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_mutateRow() throws IOError, IllegalArgument, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "mutateRow failed: out of sequence response");
      }
      mutateRow_result result = new mutateRow_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.io != null) {
        throw result.io;
      }
      if (result.ia != null) {
        throw result.ia;
      }
      return;
    }

    public void mutateRowTs(ByteBuffer tableName, ByteBuffer row, List<Mutation> mutations, long timestamp) throws IOError, IllegalArgument, TException
    {
      send_mutateRowTs(tableName, row, mutations, timestamp);
      recv_mutateRowTs();
    }

    public void send_mutateRowTs(ByteBuffer tableName, ByteBuffer row, List<Mutation> mutations, long timestamp) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("mutateRowTs", TMessageType.CALL, ++seqid_));
      mutateRowTs_args args = new mutateRowTs_args();
      args.setTableName(tableName);
      args.setRow(row);
      args.setMutations(mutations);
      args.setTimestamp(timestamp);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_mutateRowTs() throws IOError, IllegalArgument, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "mutateRowTs failed: out of sequence response");
      }
      mutateRowTs_result result = new mutateRowTs_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.io != null) {
        throw result.io;
      }
      if (result.ia != null) {
        throw result.ia;
      }
      return;
    }

    public void mutateRows(ByteBuffer tableName, List<BatchMutation> rowBatches) throws IOError, IllegalArgument, TException
    {
      send_mutateRows(tableName, rowBatches);
      recv_mutateRows();
    }

    public void send_mutateRows(ByteBuffer tableName, List<BatchMutation> rowBatches) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("mutateRows", TMessageType.CALL, ++seqid_));
      mutateRows_args args = new mutateRows_args();
      args.setTableName(tableName);
      args.setRowBatches(rowBatches);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_mutateRows() throws IOError, IllegalArgument, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "mutateRows failed: out of sequence response");
      }
      mutateRows_result result = new mutateRows_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.io != null) {
        throw result.io;
      }
      if (result.ia != null) {
        throw result.ia;
      }
      return;
    }

    public void mutateRowsTs(ByteBuffer tableName, List<BatchMutation> rowBatches, long timestamp) throws IOError, IllegalArgument, TException
    {
      send_mutateRowsTs(tableName, rowBatches, timestamp);
      recv_mutateRowsTs();
    }

    public void send_mutateRowsTs(ByteBuffer tableName, List<BatchMutation> rowBatches, long timestamp) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("mutateRowsTs", TMessageType.CALL, ++seqid_));
      mutateRowsTs_args args = new mutateRowsTs_args();
      args.setTableName(tableName);
      args.setRowBatches(rowBatches);
      args.setTimestamp(timestamp);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_mutateRowsTs() throws IOError, IllegalArgument, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "mutateRowsTs failed: out of sequence response");
      }
      mutateRowsTs_result result = new mutateRowsTs_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.io != null) {
        throw result.io;
      }
      if (result.ia != null) {
        throw result.ia;
      }
      return;
    }

    public long atomicIncrement(ByteBuffer tableName, ByteBuffer row, ByteBuffer column, long value) throws IOError, IllegalArgument, TException
    {
      send_atomicIncrement(tableName, row, column, value);
      return recv_atomicIncrement();
    }

    public void send_atomicIncrement(ByteBuffer tableName, ByteBuffer row, ByteBuffer column, long value) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("atomicIncrement", TMessageType.CALL, ++seqid_));
      atomicIncrement_args args = new atomicIncrement_args();
      args.setTableName(tableName);
      args.setRow(row);
      args.setColumn(column);
      args.setValue(value);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public long recv_atomicIncrement() throws IOError, IllegalArgument, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "atomicIncrement failed: out of sequence response");
      }
      atomicIncrement_result result = new atomicIncrement_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.io != null) {
        throw result.io;
      }
      if (result.ia != null) {
        throw result.ia;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "atomicIncrement failed: unknown result");
    }

    public void deleteAll(ByteBuffer tableName, ByteBuffer row, ByteBuffer column) throws IOError, TException
    {
      send_deleteAll(tableName, row, column);
      recv_deleteAll();
    }

    public void send_deleteAll(ByteBuffer tableName, ByteBuffer row, ByteBuffer column) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("deleteAll", TMessageType.CALL, ++seqid_));
      deleteAll_args args = new deleteAll_args();
      args.setTableName(tableName);
      args.setRow(row);
      args.setColumn(column);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_deleteAll() throws IOError, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "deleteAll failed: out of sequence response");
      }
      deleteAll_result result = new deleteAll_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.io != null) {
        throw result.io;
      }
      return;
    }

    public void deleteAllTs(ByteBuffer tableName, ByteBuffer row, ByteBuffer column, long timestamp) throws IOError, TException
    {
      send_deleteAllTs(tableName, row, column, timestamp);
      recv_deleteAllTs();
    }

    public void send_deleteAllTs(ByteBuffer tableName, ByteBuffer row, ByteBuffer column, long timestamp) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("deleteAllTs", TMessageType.CALL, ++seqid_));
      deleteAllTs_args args = new deleteAllTs_args();
      args.setTableName(tableName);
      args.setRow(row);
      args.setColumn(column);
      args.setTimestamp(timestamp);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_deleteAllTs() throws IOError, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "deleteAllTs failed: out of sequence response");
      }
      deleteAllTs_result result = new deleteAllTs_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.io != null) {
        throw result.io;
      }
      return;
    }

    public void deleteAllRow(ByteBuffer tableName, ByteBuffer row) throws IOError, TException
    {
      send_deleteAllRow(tableName, row);
      recv_deleteAllRow();
    }

    public void send_deleteAllRow(ByteBuffer tableName, ByteBuffer row) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("deleteAllRow", TMessageType.CALL, ++seqid_));
      deleteAllRow_args args = new deleteAllRow_args();
      args.setTableName(tableName);
      args.setRow(row);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_deleteAllRow() throws IOError, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "deleteAllRow failed: out of sequence response");
      }
      deleteAllRow_result result = new deleteAllRow_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.io != null) {
        throw result.io;
      }
      return;
    }

    public void deleteAllRowTs(ByteBuffer tableName, ByteBuffer row, long timestamp) throws IOError, TException
    {
      send_deleteAllRowTs(tableName, row, timestamp);
      recv_deleteAllRowTs();
    }

    public void send_deleteAllRowTs(ByteBuffer tableName, ByteBuffer row, long timestamp) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("deleteAllRowTs", TMessageType.CALL, ++seqid_));
      deleteAllRowTs_args args = new deleteAllRowTs_args();
      args.setTableName(tableName);
      args.setRow(row);
      args.setTimestamp(timestamp);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_deleteAllRowTs() throws IOError, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "deleteAllRowTs failed: out of sequence response");
      }
      deleteAllRowTs_result result = new deleteAllRowTs_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.io != null) {
        throw result.io;
      }
      return;
    }

    public int scannerOpen(ByteBuffer tableName, ByteBuffer startRow, List<ByteBuffer> columns) throws IOError, TException
    {
      send_scannerOpen(tableName, startRow, columns);
      return recv_scannerOpen();
    }

    public void send_scannerOpen(ByteBuffer tableName, ByteBuffer startRow, List<ByteBuffer> columns) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("scannerOpen", TMessageType.CALL, ++seqid_));
      scannerOpen_args args = new scannerOpen_args();
      args.setTableName(tableName);
      args.setStartRow(startRow);
      args.setColumns(columns);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public int recv_scannerOpen() throws IOError, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "scannerOpen failed: out of sequence response");
      }
      scannerOpen_result result = new scannerOpen_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.io != null) {
        throw result.io;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "scannerOpen failed: unknown result");
    }

    public int scannerOpenWithStop(ByteBuffer tableName, ByteBuffer startRow, ByteBuffer stopRow, List<ByteBuffer> columns) throws IOError, TException
    {
      send_scannerOpenWithStop(tableName, startRow, stopRow, columns);
      return recv_scannerOpenWithStop();
    }

    public void send_scannerOpenWithStop(ByteBuffer tableName, ByteBuffer startRow, ByteBuffer stopRow, List<ByteBuffer> columns) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("scannerOpenWithStop", TMessageType.CALL, ++seqid_));
      scannerOpenWithStop_args args = new scannerOpenWithStop_args();
      args.setTableName(tableName);
      args.setStartRow(startRow);
      args.setStopRow(stopRow);
      args.setColumns(columns);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public int recv_scannerOpenWithStop() throws IOError, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "scannerOpenWithStop failed: out of sequence response");
      }
      scannerOpenWithStop_result result = new scannerOpenWithStop_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.io != null) {
        throw result.io;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "scannerOpenWithStop failed: unknown result");
    }

    public int scannerOpenWithPrefix(ByteBuffer tableName, ByteBuffer startAndPrefix, List<ByteBuffer> columns) throws IOError, TException
    {
      send_scannerOpenWithPrefix(tableName, startAndPrefix, columns);
      return recv_scannerOpenWithPrefix();
    }

    public void send_scannerOpenWithPrefix(ByteBuffer tableName, ByteBuffer startAndPrefix, List<ByteBuffer> columns) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("scannerOpenWithPrefix", TMessageType.CALL, ++seqid_));
      scannerOpenWithPrefix_args args = new scannerOpenWithPrefix_args();
      args.setTableName(tableName);
      args.setStartAndPrefix(startAndPrefix);
      args.setColumns(columns);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public int recv_scannerOpenWithPrefix() throws IOError, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "scannerOpenWithPrefix failed: out of sequence response");
      }
      scannerOpenWithPrefix_result result = new scannerOpenWithPrefix_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.io != null) {
        throw result.io;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "scannerOpenWithPrefix failed: unknown result");
    }

    public int scannerOpenTs(ByteBuffer tableName, ByteBuffer startRow, List<ByteBuffer> columns, long timestamp) throws IOError, TException
    {
      send_scannerOpenTs(tableName, startRow, columns, timestamp);
      return recv_scannerOpenTs();
    }

    public void send_scannerOpenTs(ByteBuffer tableName, ByteBuffer startRow, List<ByteBuffer> columns, long timestamp) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("scannerOpenTs", TMessageType.CALL, ++seqid_));
      scannerOpenTs_args args = new scannerOpenTs_args();
      args.setTableName(tableName);
      args.setStartRow(startRow);
      args.setColumns(columns);
      args.setTimestamp(timestamp);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public int recv_scannerOpenTs() throws IOError, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "scannerOpenTs failed: out of sequence response");
      }
      scannerOpenTs_result result = new scannerOpenTs_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.io != null) {
        throw result.io;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "scannerOpenTs failed: unknown result");
    }

    public int scannerOpenWithStopTs(ByteBuffer tableName, ByteBuffer startRow, ByteBuffer stopRow, List<ByteBuffer> columns, long timestamp) throws IOError, TException
    {
      send_scannerOpenWithStopTs(tableName, startRow, stopRow, columns, timestamp);
      return recv_scannerOpenWithStopTs();
    }

    public void send_scannerOpenWithStopTs(ByteBuffer tableName, ByteBuffer startRow, ByteBuffer stopRow, List<ByteBuffer> columns, long timestamp) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("scannerOpenWithStopTs", TMessageType.CALL, ++seqid_));
      scannerOpenWithStopTs_args args = new scannerOpenWithStopTs_args();
      args.setTableName(tableName);
      args.setStartRow(startRow);
      args.setStopRow(stopRow);
      args.setColumns(columns);
      args.setTimestamp(timestamp);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public int recv_scannerOpenWithStopTs() throws IOError, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "scannerOpenWithStopTs failed: out of sequence response");
      }
      scannerOpenWithStopTs_result result = new scannerOpenWithStopTs_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.io != null) {
        throw result.io;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "scannerOpenWithStopTs failed: unknown result");
    }

    public List<TRowResult> scannerGet(int id) throws IOError, IllegalArgument, TException
    {
      send_scannerGet(id);
      return recv_scannerGet();
    }

    public void send_scannerGet(int id) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("scannerGet", TMessageType.CALL, ++seqid_));
      scannerGet_args args = new scannerGet_args();
      args.setId(id);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<TRowResult> recv_scannerGet() throws IOError, IllegalArgument, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "scannerGet failed: out of sequence response");
      }
      scannerGet_result result = new scannerGet_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.io != null) {
        throw result.io;
      }
      if (result.ia != null) {
        throw result.ia;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "scannerGet failed: unknown result");
    }

    public List<TRowResult> scannerGetList(int id, int nbRows) throws IOError, IllegalArgument, TException
    {
      send_scannerGetList(id, nbRows);
      return recv_scannerGetList();
    }

    public void send_scannerGetList(int id, int nbRows) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("scannerGetList", TMessageType.CALL, ++seqid_));
      scannerGetList_args args = new scannerGetList_args();
      args.setId(id);
      args.setNbRows(nbRows);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<TRowResult> recv_scannerGetList() throws IOError, IllegalArgument, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "scannerGetList failed: out of sequence response");
      }
      scannerGetList_result result = new scannerGetList_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.io != null) {
        throw result.io;
      }
      if (result.ia != null) {
        throw result.ia;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "scannerGetList failed: unknown result");
    }

    public void scannerClose(int id) throws IOError, IllegalArgument, TException
    {
      send_scannerClose(id);
      recv_scannerClose();
    }

    public void send_scannerClose(int id) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("scannerClose", TMessageType.CALL, ++seqid_));
      scannerClose_args args = new scannerClose_args();
      args.setId(id);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_scannerClose() throws IOError, IllegalArgument, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "scannerClose failed: out of sequence response");
      }
      scannerClose_result result = new scannerClose_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.io != null) {
        throw result.io;
      }
      if (result.ia != null) {
        throw result.ia;
      }
      return;
    }

    public List<TRowResult> parallelGet(ByteBuffer tableName, ByteBuffer column, List<ByteBuffer> rows) throws IOError, TException
    {
      send_parallelGet(tableName, column, rows);
      return recv_parallelGet();
    }

    public void send_parallelGet(ByteBuffer tableName, ByteBuffer column, List<ByteBuffer> rows) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("parallelGet", TMessageType.CALL, ++seqid_));
      parallelGet_args args = new parallelGet_args();
      args.setTableName(tableName);
      args.setColumn(column);
      args.setRows(rows);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<TRowResult> recv_parallelGet() throws IOError, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "parallelGet failed: out of sequence response");
      }
      parallelGet_result result = new parallelGet_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.io != null) {
        throw result.io;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "parallelGet failed: unknown result");
    }

    public void asyncAtomicIncrements(List<Increment> increments) throws TException
    {
      send_asyncAtomicIncrements(increments);
    }

    public void send_asyncAtomicIncrements(List<Increment> increments) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("asyncAtomicIncrements", TMessageType.CALL, ++seqid_));
      asyncAtomicIncrements_args args = new asyncAtomicIncrements_args();
      args.setIncrements(increments);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public boolean queueIncrementColumnValues(List<Increment> increments) throws TException
    {
      send_queueIncrementColumnValues(increments);
      return recv_queueIncrementColumnValues();
    }

    public void send_queueIncrementColumnValues(List<Increment> increments) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("queueIncrementColumnValues", TMessageType.CALL, ++seqid_));
      queueIncrementColumnValues_args args = new queueIncrementColumnValues_args();
      args.setIncrements(increments);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public boolean recv_queueIncrementColumnValues() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "queueIncrementColumnValues failed: out of sequence response");
      }
      queueIncrementColumnValues_result result = new queueIncrementColumnValues_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "queueIncrementColumnValues failed: unknown result");
    }

  }
  public static class AsyncClient extends TAsyncClient implements AsyncIface {
    public static class Factory implements TAsyncClientFactory<AsyncClient> {
      private TAsyncClientManager clientManager;
      private TProtocolFactory protocolFactory;
      public Factory(TAsyncClientManager clientManager, TProtocolFactory protocolFactory) {
        this.clientManager = clientManager;
        this.protocolFactory = protocolFactory;
      }
      public AsyncClient getAsyncClient(TNonblockingTransport transport) {
        return new AsyncClient(protocolFactory, clientManager, transport);
      }
    }

    public AsyncClient(TProtocolFactory protocolFactory, TAsyncClientManager clientManager, TNonblockingTransport transport) {
      super(protocolFactory, clientManager, transport);
    }

    public void enableTable(ByteBuffer tableName, AsyncMethodCallback<enableTable_call> resultHandler) throws TException {
      checkReady();
      enableTable_call method_call = new enableTable_call(tableName, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class enableTable_call extends TAsyncMethodCall {
      private ByteBuffer tableName;
      public enableTable_call(ByteBuffer tableName, AsyncMethodCallback<enableTable_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.tableName = tableName;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("enableTable", TMessageType.CALL, 0));
        enableTable_args args = new enableTable_args();
        args.setTableName(tableName);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws IOError, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_enableTable();
      }
    }

    public void disableTable(ByteBuffer tableName, AsyncMethodCallback<disableTable_call> resultHandler) throws TException {
      checkReady();
      disableTable_call method_call = new disableTable_call(tableName, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class disableTable_call extends TAsyncMethodCall {
      private ByteBuffer tableName;
      public disableTable_call(ByteBuffer tableName, AsyncMethodCallback<disableTable_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.tableName = tableName;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("disableTable", TMessageType.CALL, 0));
        disableTable_args args = new disableTable_args();
        args.setTableName(tableName);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws IOError, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_disableTable();
      }
    }

    public void isTableEnabled(ByteBuffer tableName, AsyncMethodCallback<isTableEnabled_call> resultHandler) throws TException {
      checkReady();
      isTableEnabled_call method_call = new isTableEnabled_call(tableName, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class isTableEnabled_call extends TAsyncMethodCall {
      private ByteBuffer tableName;
      public isTableEnabled_call(ByteBuffer tableName, AsyncMethodCallback<isTableEnabled_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.tableName = tableName;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("isTableEnabled", TMessageType.CALL, 0));
        isTableEnabled_args args = new isTableEnabled_args();
        args.setTableName(tableName);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public boolean getResult() throws IOError, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_isTableEnabled();
      }
    }

    public void compact(ByteBuffer tableNameOrRegionName, AsyncMethodCallback<compact_call> resultHandler) throws TException {
      checkReady();
      compact_call method_call = new compact_call(tableNameOrRegionName, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class compact_call extends TAsyncMethodCall {
      private ByteBuffer tableNameOrRegionName;
      public compact_call(ByteBuffer tableNameOrRegionName, AsyncMethodCallback<compact_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.tableNameOrRegionName = tableNameOrRegionName;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("compact", TMessageType.CALL, 0));
        compact_args args = new compact_args();
        args.setTableNameOrRegionName(tableNameOrRegionName);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws IOError, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_compact();
      }
    }

    public void majorCompact(ByteBuffer tableNameOrRegionName, AsyncMethodCallback<majorCompact_call> resultHandler) throws TException {
      checkReady();
      majorCompact_call method_call = new majorCompact_call(tableNameOrRegionName, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class majorCompact_call extends TAsyncMethodCall {
      private ByteBuffer tableNameOrRegionName;
      public majorCompact_call(ByteBuffer tableNameOrRegionName, AsyncMethodCallback<majorCompact_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.tableNameOrRegionName = tableNameOrRegionName;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("majorCompact", TMessageType.CALL, 0));
        majorCompact_args args = new majorCompact_args();
        args.setTableNameOrRegionName(tableNameOrRegionName);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws IOError, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_majorCompact();
      }
    }

    public void getTableNames(AsyncMethodCallback<getTableNames_call> resultHandler) throws TException {
      checkReady();
      getTableNames_call method_call = new getTableNames_call(resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getTableNames_call extends TAsyncMethodCall {
      public getTableNames_call(AsyncMethodCallback<getTableNames_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getTableNames", TMessageType.CALL, 0));
        getTableNames_args args = new getTableNames_args();
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<ByteBuffer> getResult() throws IOError, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getTableNames();
      }
    }

    public void getColumnDescriptors(ByteBuffer tableName, AsyncMethodCallback<getColumnDescriptors_call> resultHandler) throws TException {
      checkReady();
      getColumnDescriptors_call method_call = new getColumnDescriptors_call(tableName, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getColumnDescriptors_call extends TAsyncMethodCall {
      private ByteBuffer tableName;
      public getColumnDescriptors_call(ByteBuffer tableName, AsyncMethodCallback<getColumnDescriptors_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.tableName = tableName;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getColumnDescriptors", TMessageType.CALL, 0));
        getColumnDescriptors_args args = new getColumnDescriptors_args();
        args.setTableName(tableName);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public Map<ByteBuffer,ColumnDescriptor> getResult() throws IOError, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getColumnDescriptors();
      }
    }

    public void getTableRegions(ByteBuffer tableName, AsyncMethodCallback<getTableRegions_call> resultHandler) throws TException {
      checkReady();
      getTableRegions_call method_call = new getTableRegions_call(tableName, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getTableRegions_call extends TAsyncMethodCall {
      private ByteBuffer tableName;
      public getTableRegions_call(ByteBuffer tableName, AsyncMethodCallback<getTableRegions_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.tableName = tableName;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getTableRegions", TMessageType.CALL, 0));
        getTableRegions_args args = new getTableRegions_args();
        args.setTableName(tableName);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<TRegionInfo> getResult() throws IOError, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getTableRegions();
      }
    }

    public void createTable(ByteBuffer tableName, List<ColumnDescriptor> columnFamilies, AsyncMethodCallback<createTable_call> resultHandler) throws TException {
      checkReady();
      createTable_call method_call = new createTable_call(tableName, columnFamilies, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class createTable_call extends TAsyncMethodCall {
      private ByteBuffer tableName;
      private List<ColumnDescriptor> columnFamilies;
      public createTable_call(ByteBuffer tableName, List<ColumnDescriptor> columnFamilies, AsyncMethodCallback<createTable_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.tableName = tableName;
        this.columnFamilies = columnFamilies;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("createTable", TMessageType.CALL, 0));
        createTable_args args = new createTable_args();
        args.setTableName(tableName);
        args.setColumnFamilies(columnFamilies);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws IOError, IllegalArgument, AlreadyExists, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_createTable();
      }
    }

    public void deleteTable(ByteBuffer tableName, AsyncMethodCallback<deleteTable_call> resultHandler) throws TException {
      checkReady();
      deleteTable_call method_call = new deleteTable_call(tableName, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class deleteTable_call extends TAsyncMethodCall {
      private ByteBuffer tableName;
      public deleteTable_call(ByteBuffer tableName, AsyncMethodCallback<deleteTable_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.tableName = tableName;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("deleteTable", TMessageType.CALL, 0));
        deleteTable_args args = new deleteTable_args();
        args.setTableName(tableName);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws IOError, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_deleteTable();
      }
    }

    public void get(ByteBuffer tableName, ByteBuffer row, ByteBuffer column, AsyncMethodCallback<get_call> resultHandler) throws TException {
      checkReady();
      get_call method_call = new get_call(tableName, row, column, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class get_call extends TAsyncMethodCall {
      private ByteBuffer tableName;
      private ByteBuffer row;
      private ByteBuffer column;
      public get_call(ByteBuffer tableName, ByteBuffer row, ByteBuffer column, AsyncMethodCallback<get_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.tableName = tableName;
        this.row = row;
        this.column = column;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("get", TMessageType.CALL, 0));
        get_args args = new get_args();
        args.setTableName(tableName);
        args.setRow(row);
        args.setColumn(column);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<TCell> getResult() throws IOError, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_get();
      }
    }

    public void getVer(ByteBuffer tableName, ByteBuffer row, ByteBuffer column, int numVersions, AsyncMethodCallback<getVer_call> resultHandler) throws TException {
      checkReady();
      getVer_call method_call = new getVer_call(tableName, row, column, numVersions, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getVer_call extends TAsyncMethodCall {
      private ByteBuffer tableName;
      private ByteBuffer row;
      private ByteBuffer column;
      private int numVersions;
      public getVer_call(ByteBuffer tableName, ByteBuffer row, ByteBuffer column, int numVersions, AsyncMethodCallback<getVer_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.tableName = tableName;
        this.row = row;
        this.column = column;
        this.numVersions = numVersions;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getVer", TMessageType.CALL, 0));
        getVer_args args = new getVer_args();
        args.setTableName(tableName);
        args.setRow(row);
        args.setColumn(column);
        args.setNumVersions(numVersions);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<TCell> getResult() throws IOError, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getVer();
      }
    }

    public void getVerTs(ByteBuffer tableName, ByteBuffer row, ByteBuffer column, long timestamp, int numVersions, AsyncMethodCallback<getVerTs_call> resultHandler) throws TException {
      checkReady();
      getVerTs_call method_call = new getVerTs_call(tableName, row, column, timestamp, numVersions, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getVerTs_call extends TAsyncMethodCall {
      private ByteBuffer tableName;
      private ByteBuffer row;
      private ByteBuffer column;
      private long timestamp;
      private int numVersions;
      public getVerTs_call(ByteBuffer tableName, ByteBuffer row, ByteBuffer column, long timestamp, int numVersions, AsyncMethodCallback<getVerTs_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.tableName = tableName;
        this.row = row;
        this.column = column;
        this.timestamp = timestamp;
        this.numVersions = numVersions;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getVerTs", TMessageType.CALL, 0));
        getVerTs_args args = new getVerTs_args();
        args.setTableName(tableName);
        args.setRow(row);
        args.setColumn(column);
        args.setTimestamp(timestamp);
        args.setNumVersions(numVersions);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<TCell> getResult() throws IOError, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getVerTs();
      }
    }

    public void getRow(ByteBuffer tableName, ByteBuffer row, AsyncMethodCallback<getRow_call> resultHandler) throws TException {
      checkReady();
      getRow_call method_call = new getRow_call(tableName, row, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getRow_call extends TAsyncMethodCall {
      private ByteBuffer tableName;
      private ByteBuffer row;
      public getRow_call(ByteBuffer tableName, ByteBuffer row, AsyncMethodCallback<getRow_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.tableName = tableName;
        this.row = row;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getRow", TMessageType.CALL, 0));
        getRow_args args = new getRow_args();
        args.setTableName(tableName);
        args.setRow(row);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<TRowResult> getResult() throws IOError, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getRow();
      }
    }

    public void getRowWithColumns(ByteBuffer tableName, ByteBuffer row, List<ByteBuffer> columns, AsyncMethodCallback<getRowWithColumns_call> resultHandler) throws TException {
      checkReady();
      getRowWithColumns_call method_call = new getRowWithColumns_call(tableName, row, columns, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getRowWithColumns_call extends TAsyncMethodCall {
      private ByteBuffer tableName;
      private ByteBuffer row;
      private List<ByteBuffer> columns;
      public getRowWithColumns_call(ByteBuffer tableName, ByteBuffer row, List<ByteBuffer> columns, AsyncMethodCallback<getRowWithColumns_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.tableName = tableName;
        this.row = row;
        this.columns = columns;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getRowWithColumns", TMessageType.CALL, 0));
        getRowWithColumns_args args = new getRowWithColumns_args();
        args.setTableName(tableName);
        args.setRow(row);
        args.setColumns(columns);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<TRowResult> getResult() throws IOError, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getRowWithColumns();
      }
    }

    public void getRowTs(ByteBuffer tableName, ByteBuffer row, long timestamp, AsyncMethodCallback<getRowTs_call> resultHandler) throws TException {
      checkReady();
      getRowTs_call method_call = new getRowTs_call(tableName, row, timestamp, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getRowTs_call extends TAsyncMethodCall {
      private ByteBuffer tableName;
      private ByteBuffer row;
      private long timestamp;
      public getRowTs_call(ByteBuffer tableName, ByteBuffer row, long timestamp, AsyncMethodCallback<getRowTs_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.tableName = tableName;
        this.row = row;
        this.timestamp = timestamp;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getRowTs", TMessageType.CALL, 0));
        getRowTs_args args = new getRowTs_args();
        args.setTableName(tableName);
        args.setRow(row);
        args.setTimestamp(timestamp);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<TRowResult> getResult() throws IOError, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getRowTs();
      }
    }

    public void getRowWithColumnsTs(ByteBuffer tableName, ByteBuffer row, List<ByteBuffer> columns, long timestamp, AsyncMethodCallback<getRowWithColumnsTs_call> resultHandler) throws TException {
      checkReady();
      getRowWithColumnsTs_call method_call = new getRowWithColumnsTs_call(tableName, row, columns, timestamp, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getRowWithColumnsTs_call extends TAsyncMethodCall {
      private ByteBuffer tableName;
      private ByteBuffer row;
      private List<ByteBuffer> columns;
      private long timestamp;
      public getRowWithColumnsTs_call(ByteBuffer tableName, ByteBuffer row, List<ByteBuffer> columns, long timestamp, AsyncMethodCallback<getRowWithColumnsTs_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.tableName = tableName;
        this.row = row;
        this.columns = columns;
        this.timestamp = timestamp;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getRowWithColumnsTs", TMessageType.CALL, 0));
        getRowWithColumnsTs_args args = new getRowWithColumnsTs_args();
        args.setTableName(tableName);
        args.setRow(row);
        args.setColumns(columns);
        args.setTimestamp(timestamp);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<TRowResult> getResult() throws IOError, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getRowWithColumnsTs();
      }
    }

    public void getRows(ByteBuffer tableName, List<ByteBuffer> rows, AsyncMethodCallback<getRows_call> resultHandler) throws TException {
      checkReady();
      getRows_call method_call = new getRows_call(tableName, rows, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getRows_call extends TAsyncMethodCall {
      private ByteBuffer tableName;
      private List<ByteBuffer> rows;
      public getRows_call(ByteBuffer tableName, List<ByteBuffer> rows, AsyncMethodCallback<getRows_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.tableName = tableName;
        this.rows = rows;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getRows", TMessageType.CALL, 0));
        getRows_args args = new getRows_args();
        args.setTableName(tableName);
        args.setRows(rows);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<TRowResult> getResult() throws IOError, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getRows();
      }
    }

    public void getRowsWithColumns(ByteBuffer tableName, List<ByteBuffer> rows, List<ByteBuffer> columns, AsyncMethodCallback<getRowsWithColumns_call> resultHandler) throws TException {
      checkReady();
      getRowsWithColumns_call method_call = new getRowsWithColumns_call(tableName, rows, columns, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getRowsWithColumns_call extends TAsyncMethodCall {
      private ByteBuffer tableName;
      private List<ByteBuffer> rows;
      private List<ByteBuffer> columns;
      public getRowsWithColumns_call(ByteBuffer tableName, List<ByteBuffer> rows, List<ByteBuffer> columns, AsyncMethodCallback<getRowsWithColumns_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.tableName = tableName;
        this.rows = rows;
        this.columns = columns;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getRowsWithColumns", TMessageType.CALL, 0));
        getRowsWithColumns_args args = new getRowsWithColumns_args();
        args.setTableName(tableName);
        args.setRows(rows);
        args.setColumns(columns);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<TRowResult> getResult() throws IOError, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getRowsWithColumns();
      }
    }

    public void getRowsTs(ByteBuffer tableName, List<ByteBuffer> rows, long timestamp, AsyncMethodCallback<getRowsTs_call> resultHandler) throws TException {
      checkReady();
      getRowsTs_call method_call = new getRowsTs_call(tableName, rows, timestamp, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getRowsTs_call extends TAsyncMethodCall {
      private ByteBuffer tableName;
      private List<ByteBuffer> rows;
      private long timestamp;
      public getRowsTs_call(ByteBuffer tableName, List<ByteBuffer> rows, long timestamp, AsyncMethodCallback<getRowsTs_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.tableName = tableName;
        this.rows = rows;
        this.timestamp = timestamp;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getRowsTs", TMessageType.CALL, 0));
        getRowsTs_args args = new getRowsTs_args();
        args.setTableName(tableName);
        args.setRows(rows);
        args.setTimestamp(timestamp);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<TRowResult> getResult() throws IOError, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getRowsTs();
      }
    }

    public void getRowsWithColumnsTs(ByteBuffer tableName, List<ByteBuffer> rows, List<ByteBuffer> columns, long timestamp, AsyncMethodCallback<getRowsWithColumnsTs_call> resultHandler) throws TException {
      checkReady();
      getRowsWithColumnsTs_call method_call = new getRowsWithColumnsTs_call(tableName, rows, columns, timestamp, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getRowsWithColumnsTs_call extends TAsyncMethodCall {
      private ByteBuffer tableName;
      private List<ByteBuffer> rows;
      private List<ByteBuffer> columns;
      private long timestamp;
      public getRowsWithColumnsTs_call(ByteBuffer tableName, List<ByteBuffer> rows, List<ByteBuffer> columns, long timestamp, AsyncMethodCallback<getRowsWithColumnsTs_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.tableName = tableName;
        this.rows = rows;
        this.columns = columns;
        this.timestamp = timestamp;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getRowsWithColumnsTs", TMessageType.CALL, 0));
        getRowsWithColumnsTs_args args = new getRowsWithColumnsTs_args();
        args.setTableName(tableName);
        args.setRows(rows);
        args.setColumns(columns);
        args.setTimestamp(timestamp);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<TRowResult> getResult() throws IOError, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getRowsWithColumnsTs();
      }
    }

    public void mutateRow(ByteBuffer tableName, ByteBuffer row, List<Mutation> mutations, AsyncMethodCallback<mutateRow_call> resultHandler) throws TException {
      checkReady();
      mutateRow_call method_call = new mutateRow_call(tableName, row, mutations, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class mutateRow_call extends TAsyncMethodCall {
      private ByteBuffer tableName;
      private ByteBuffer row;
      private List<Mutation> mutations;
      public mutateRow_call(ByteBuffer tableName, ByteBuffer row, List<Mutation> mutations, AsyncMethodCallback<mutateRow_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.tableName = tableName;
        this.row = row;
        this.mutations = mutations;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("mutateRow", TMessageType.CALL, 0));
        mutateRow_args args = new mutateRow_args();
        args.setTableName(tableName);
        args.setRow(row);
        args.setMutations(mutations);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws IOError, IllegalArgument, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_mutateRow();
      }
    }

    public void mutateRowTs(ByteBuffer tableName, ByteBuffer row, List<Mutation> mutations, long timestamp, AsyncMethodCallback<mutateRowTs_call> resultHandler) throws TException {
      checkReady();
      mutateRowTs_call method_call = new mutateRowTs_call(tableName, row, mutations, timestamp, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class mutateRowTs_call extends TAsyncMethodCall {
      private ByteBuffer tableName;
      private ByteBuffer row;
      private List<Mutation> mutations;
      private long timestamp;
      public mutateRowTs_call(ByteBuffer tableName, ByteBuffer row, List<Mutation> mutations, long timestamp, AsyncMethodCallback<mutateRowTs_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.tableName = tableName;
        this.row = row;
        this.mutations = mutations;
        this.timestamp = timestamp;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("mutateRowTs", TMessageType.CALL, 0));
        mutateRowTs_args args = new mutateRowTs_args();
        args.setTableName(tableName);
        args.setRow(row);
        args.setMutations(mutations);
        args.setTimestamp(timestamp);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws IOError, IllegalArgument, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_mutateRowTs();
      }
    }

    public void mutateRows(ByteBuffer tableName, List<BatchMutation> rowBatches, AsyncMethodCallback<mutateRows_call> resultHandler) throws TException {
      checkReady();
      mutateRows_call method_call = new mutateRows_call(tableName, rowBatches, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class mutateRows_call extends TAsyncMethodCall {
      private ByteBuffer tableName;
      private List<BatchMutation> rowBatches;
      public mutateRows_call(ByteBuffer tableName, List<BatchMutation> rowBatches, AsyncMethodCallback<mutateRows_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.tableName = tableName;
        this.rowBatches = rowBatches;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("mutateRows", TMessageType.CALL, 0));
        mutateRows_args args = new mutateRows_args();
        args.setTableName(tableName);
        args.setRowBatches(rowBatches);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws IOError, IllegalArgument, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_mutateRows();
      }
    }

    public void mutateRowsTs(ByteBuffer tableName, List<BatchMutation> rowBatches, long timestamp, AsyncMethodCallback<mutateRowsTs_call> resultHandler) throws TException {
      checkReady();
      mutateRowsTs_call method_call = new mutateRowsTs_call(tableName, rowBatches, timestamp, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class mutateRowsTs_call extends TAsyncMethodCall {
      private ByteBuffer tableName;
      private List<BatchMutation> rowBatches;
      private long timestamp;
      public mutateRowsTs_call(ByteBuffer tableName, List<BatchMutation> rowBatches, long timestamp, AsyncMethodCallback<mutateRowsTs_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.tableName = tableName;
        this.rowBatches = rowBatches;
        this.timestamp = timestamp;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("mutateRowsTs", TMessageType.CALL, 0));
        mutateRowsTs_args args = new mutateRowsTs_args();
        args.setTableName(tableName);
        args.setRowBatches(rowBatches);
        args.setTimestamp(timestamp);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws IOError, IllegalArgument, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_mutateRowsTs();
      }
    }

    public void atomicIncrement(ByteBuffer tableName, ByteBuffer row, ByteBuffer column, long value, AsyncMethodCallback<atomicIncrement_call> resultHandler) throws TException {
      checkReady();
      atomicIncrement_call method_call = new atomicIncrement_call(tableName, row, column, value, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class atomicIncrement_call extends TAsyncMethodCall {
      private ByteBuffer tableName;
      private ByteBuffer row;
      private ByteBuffer column;
      private long value;
      public atomicIncrement_call(ByteBuffer tableName, ByteBuffer row, ByteBuffer column, long value, AsyncMethodCallback<atomicIncrement_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.tableName = tableName;
        this.row = row;
        this.column = column;
        this.value = value;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("atomicIncrement", TMessageType.CALL, 0));
        atomicIncrement_args args = new atomicIncrement_args();
        args.setTableName(tableName);
        args.setRow(row);
        args.setColumn(column);
        args.setValue(value);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public long getResult() throws IOError, IllegalArgument, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_atomicIncrement();
      }
    }

    public void deleteAll(ByteBuffer tableName, ByteBuffer row, ByteBuffer column, AsyncMethodCallback<deleteAll_call> resultHandler) throws TException {
      checkReady();
      deleteAll_call method_call = new deleteAll_call(tableName, row, column, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class deleteAll_call extends TAsyncMethodCall {
      private ByteBuffer tableName;
      private ByteBuffer row;
      private ByteBuffer column;
      public deleteAll_call(ByteBuffer tableName, ByteBuffer row, ByteBuffer column, AsyncMethodCallback<deleteAll_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.tableName = tableName;
        this.row = row;
        this.column = column;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("deleteAll", TMessageType.CALL, 0));
        deleteAll_args args = new deleteAll_args();
        args.setTableName(tableName);
        args.setRow(row);
        args.setColumn(column);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws IOError, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_deleteAll();
      }
    }

    public void deleteAllTs(ByteBuffer tableName, ByteBuffer row, ByteBuffer column, long timestamp, AsyncMethodCallback<deleteAllTs_call> resultHandler) throws TException {
      checkReady();
      deleteAllTs_call method_call = new deleteAllTs_call(tableName, row, column, timestamp, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class deleteAllTs_call extends TAsyncMethodCall {
      private ByteBuffer tableName;
      private ByteBuffer row;
      private ByteBuffer column;
      private long timestamp;
      public deleteAllTs_call(ByteBuffer tableName, ByteBuffer row, ByteBuffer column, long timestamp, AsyncMethodCallback<deleteAllTs_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.tableName = tableName;
        this.row = row;
        this.column = column;
        this.timestamp = timestamp;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("deleteAllTs", TMessageType.CALL, 0));
        deleteAllTs_args args = new deleteAllTs_args();
        args.setTableName(tableName);
        args.setRow(row);
        args.setColumn(column);
        args.setTimestamp(timestamp);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws IOError, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_deleteAllTs();
      }
    }

    public void deleteAllRow(ByteBuffer tableName, ByteBuffer row, AsyncMethodCallback<deleteAllRow_call> resultHandler) throws TException {
      checkReady();
      deleteAllRow_call method_call = new deleteAllRow_call(tableName, row, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class deleteAllRow_call extends TAsyncMethodCall {
      private ByteBuffer tableName;
      private ByteBuffer row;
      public deleteAllRow_call(ByteBuffer tableName, ByteBuffer row, AsyncMethodCallback<deleteAllRow_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.tableName = tableName;
        this.row = row;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("deleteAllRow", TMessageType.CALL, 0));
        deleteAllRow_args args = new deleteAllRow_args();
        args.setTableName(tableName);
        args.setRow(row);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws IOError, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_deleteAllRow();
      }
    }

    public void deleteAllRowTs(ByteBuffer tableName, ByteBuffer row, long timestamp, AsyncMethodCallback<deleteAllRowTs_call> resultHandler) throws TException {
      checkReady();
      deleteAllRowTs_call method_call = new deleteAllRowTs_call(tableName, row, timestamp, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class deleteAllRowTs_call extends TAsyncMethodCall {
      private ByteBuffer tableName;
      private ByteBuffer row;
      private long timestamp;
      public deleteAllRowTs_call(ByteBuffer tableName, ByteBuffer row, long timestamp, AsyncMethodCallback<deleteAllRowTs_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.tableName = tableName;
        this.row = row;
        this.timestamp = timestamp;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("deleteAllRowTs", TMessageType.CALL, 0));
        deleteAllRowTs_args args = new deleteAllRowTs_args();
        args.setTableName(tableName);
        args.setRow(row);
        args.setTimestamp(timestamp);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws IOError, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_deleteAllRowTs();
      }
    }

    public void scannerOpen(ByteBuffer tableName, ByteBuffer startRow, List<ByteBuffer> columns, AsyncMethodCallback<scannerOpen_call> resultHandler) throws TException {
      checkReady();
      scannerOpen_call method_call = new scannerOpen_call(tableName, startRow, columns, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class scannerOpen_call extends TAsyncMethodCall {
      private ByteBuffer tableName;
      private ByteBuffer startRow;
      private List<ByteBuffer> columns;
      public scannerOpen_call(ByteBuffer tableName, ByteBuffer startRow, List<ByteBuffer> columns, AsyncMethodCallback<scannerOpen_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.tableName = tableName;
        this.startRow = startRow;
        this.columns = columns;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("scannerOpen", TMessageType.CALL, 0));
        scannerOpen_args args = new scannerOpen_args();
        args.setTableName(tableName);
        args.setStartRow(startRow);
        args.setColumns(columns);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public int getResult() throws IOError, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_scannerOpen();
      }
    }

    public void scannerOpenWithStop(ByteBuffer tableName, ByteBuffer startRow, ByteBuffer stopRow, List<ByteBuffer> columns, AsyncMethodCallback<scannerOpenWithStop_call> resultHandler) throws TException {
      checkReady();
      scannerOpenWithStop_call method_call = new scannerOpenWithStop_call(tableName, startRow, stopRow, columns, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class scannerOpenWithStop_call extends TAsyncMethodCall {
      private ByteBuffer tableName;
      private ByteBuffer startRow;
      private ByteBuffer stopRow;
      private List<ByteBuffer> columns;
      public scannerOpenWithStop_call(ByteBuffer tableName, ByteBuffer startRow, ByteBuffer stopRow, List<ByteBuffer> columns, AsyncMethodCallback<scannerOpenWithStop_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.tableName = tableName;
        this.startRow = startRow;
        this.stopRow = stopRow;
        this.columns = columns;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("scannerOpenWithStop", TMessageType.CALL, 0));
        scannerOpenWithStop_args args = new scannerOpenWithStop_args();
        args.setTableName(tableName);
        args.setStartRow(startRow);
        args.setStopRow(stopRow);
        args.setColumns(columns);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public int getResult() throws IOError, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_scannerOpenWithStop();
      }
    }

    public void scannerOpenWithPrefix(ByteBuffer tableName, ByteBuffer startAndPrefix, List<ByteBuffer> columns, AsyncMethodCallback<scannerOpenWithPrefix_call> resultHandler) throws TException {
      checkReady();
      scannerOpenWithPrefix_call method_call = new scannerOpenWithPrefix_call(tableName, startAndPrefix, columns, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class scannerOpenWithPrefix_call extends TAsyncMethodCall {
      private ByteBuffer tableName;
      private ByteBuffer startAndPrefix;
      private List<ByteBuffer> columns;
      public scannerOpenWithPrefix_call(ByteBuffer tableName, ByteBuffer startAndPrefix, List<ByteBuffer> columns, AsyncMethodCallback<scannerOpenWithPrefix_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.tableName = tableName;
        this.startAndPrefix = startAndPrefix;
        this.columns = columns;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("scannerOpenWithPrefix", TMessageType.CALL, 0));
        scannerOpenWithPrefix_args args = new scannerOpenWithPrefix_args();
        args.setTableName(tableName);
        args.setStartAndPrefix(startAndPrefix);
        args.setColumns(columns);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public int getResult() throws IOError, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_scannerOpenWithPrefix();
      }
    }

    public void scannerOpenTs(ByteBuffer tableName, ByteBuffer startRow, List<ByteBuffer> columns, long timestamp, AsyncMethodCallback<scannerOpenTs_call> resultHandler) throws TException {
      checkReady();
      scannerOpenTs_call method_call = new scannerOpenTs_call(tableName, startRow, columns, timestamp, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class scannerOpenTs_call extends TAsyncMethodCall {
      private ByteBuffer tableName;
      private ByteBuffer startRow;
      private List<ByteBuffer> columns;
      private long timestamp;
      public scannerOpenTs_call(ByteBuffer tableName, ByteBuffer startRow, List<ByteBuffer> columns, long timestamp, AsyncMethodCallback<scannerOpenTs_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.tableName = tableName;
        this.startRow = startRow;
        this.columns = columns;
        this.timestamp = timestamp;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("scannerOpenTs", TMessageType.CALL, 0));
        scannerOpenTs_args args = new scannerOpenTs_args();
        args.setTableName(tableName);
        args.setStartRow(startRow);
        args.setColumns(columns);
        args.setTimestamp(timestamp);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public int getResult() throws IOError, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_scannerOpenTs();
      }
    }

    public void scannerOpenWithStopTs(ByteBuffer tableName, ByteBuffer startRow, ByteBuffer stopRow, List<ByteBuffer> columns, long timestamp, AsyncMethodCallback<scannerOpenWithStopTs_call> resultHandler) throws TException {
      checkReady();
      scannerOpenWithStopTs_call method_call = new scannerOpenWithStopTs_call(tableName, startRow, stopRow, columns, timestamp, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class scannerOpenWithStopTs_call extends TAsyncMethodCall {
      private ByteBuffer tableName;
      private ByteBuffer startRow;
      private ByteBuffer stopRow;
      private List<ByteBuffer> columns;
      private long timestamp;
      public scannerOpenWithStopTs_call(ByteBuffer tableName, ByteBuffer startRow, ByteBuffer stopRow, List<ByteBuffer> columns, long timestamp, AsyncMethodCallback<scannerOpenWithStopTs_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.tableName = tableName;
        this.startRow = startRow;
        this.stopRow = stopRow;
        this.columns = columns;
        this.timestamp = timestamp;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("scannerOpenWithStopTs", TMessageType.CALL, 0));
        scannerOpenWithStopTs_args args = new scannerOpenWithStopTs_args();
        args.setTableName(tableName);
        args.setStartRow(startRow);
        args.setStopRow(stopRow);
        args.setColumns(columns);
        args.setTimestamp(timestamp);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public int getResult() throws IOError, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_scannerOpenWithStopTs();
      }
    }

    public void scannerGet(int id, AsyncMethodCallback<scannerGet_call> resultHandler) throws TException {
      checkReady();
      scannerGet_call method_call = new scannerGet_call(id, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class scannerGet_call extends TAsyncMethodCall {
      private int id;
      public scannerGet_call(int id, AsyncMethodCallback<scannerGet_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.id = id;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("scannerGet", TMessageType.CALL, 0));
        scannerGet_args args = new scannerGet_args();
        args.setId(id);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<TRowResult> getResult() throws IOError, IllegalArgument, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_scannerGet();
      }
    }

    public void scannerGetList(int id, int nbRows, AsyncMethodCallback<scannerGetList_call> resultHandler) throws TException {
      checkReady();
      scannerGetList_call method_call = new scannerGetList_call(id, nbRows, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class scannerGetList_call extends TAsyncMethodCall {
      private int id;
      private int nbRows;
      public scannerGetList_call(int id, int nbRows, AsyncMethodCallback<scannerGetList_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.id = id;
        this.nbRows = nbRows;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("scannerGetList", TMessageType.CALL, 0));
        scannerGetList_args args = new scannerGetList_args();
        args.setId(id);
        args.setNbRows(nbRows);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<TRowResult> getResult() throws IOError, IllegalArgument, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_scannerGetList();
      }
    }

    public void scannerClose(int id, AsyncMethodCallback<scannerClose_call> resultHandler) throws TException {
      checkReady();
      scannerClose_call method_call = new scannerClose_call(id, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class scannerClose_call extends TAsyncMethodCall {
      private int id;
      public scannerClose_call(int id, AsyncMethodCallback<scannerClose_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.id = id;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("scannerClose", TMessageType.CALL, 0));
        scannerClose_args args = new scannerClose_args();
        args.setId(id);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws IOError, IllegalArgument, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_scannerClose();
      }
    }

    public void parallelGet(ByteBuffer tableName, ByteBuffer column, List<ByteBuffer> rows, AsyncMethodCallback<parallelGet_call> resultHandler) throws TException {
      checkReady();
      parallelGet_call method_call = new parallelGet_call(tableName, column, rows, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class parallelGet_call extends TAsyncMethodCall {
      private ByteBuffer tableName;
      private ByteBuffer column;
      private List<ByteBuffer> rows;
      public parallelGet_call(ByteBuffer tableName, ByteBuffer column, List<ByteBuffer> rows, AsyncMethodCallback<parallelGet_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.tableName = tableName;
        this.column = column;
        this.rows = rows;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("parallelGet", TMessageType.CALL, 0));
        parallelGet_args args = new parallelGet_args();
        args.setTableName(tableName);
        args.setColumn(column);
        args.setRows(rows);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<TRowResult> getResult() throws IOError, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_parallelGet();
      }
    }

    public void asyncAtomicIncrements(List<Increment> increments, AsyncMethodCallback<asyncAtomicIncrements_call> resultHandler) throws TException {
      checkReady();
      asyncAtomicIncrements_call method_call = new asyncAtomicIncrements_call(increments, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class asyncAtomicIncrements_call extends TAsyncMethodCall {
      private List<Increment> increments;
      public asyncAtomicIncrements_call(List<Increment> increments, AsyncMethodCallback<asyncAtomicIncrements_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, true);
        this.increments = increments;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("asyncAtomicIncrements", TMessageType.CALL, 0));
        asyncAtomicIncrements_args args = new asyncAtomicIncrements_args();
        args.setIncrements(increments);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
      }
    }

    public void queueIncrementColumnValues(List<Increment> increments, AsyncMethodCallback<queueIncrementColumnValues_call> resultHandler) throws TException {
      checkReady();
      queueIncrementColumnValues_call method_call = new queueIncrementColumnValues_call(increments, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class queueIncrementColumnValues_call extends TAsyncMethodCall {
      private List<Increment> increments;
      public queueIncrementColumnValues_call(List<Increment> increments, AsyncMethodCallback<queueIncrementColumnValues_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.increments = increments;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("queueIncrementColumnValues", TMessageType.CALL, 0));
        queueIncrementColumnValues_args args = new queueIncrementColumnValues_args();
        args.setIncrements(increments);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public boolean getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_queueIncrementColumnValues();
      }
    }

  }

  public static class Processor implements TProcessor {
    private static final Logger LOGGER = LoggerFactory.getLogger(Processor.class.getName());
    public Processor(Iface iface)
    {
      iface_ = iface;
      processMap_.put("enableTable", new enableTable());
      processMap_.put("disableTable", new disableTable());
      processMap_.put("isTableEnabled", new isTableEnabled());
      processMap_.put("compact", new compact());
      processMap_.put("majorCompact", new majorCompact());
      processMap_.put("getTableNames", new getTableNames());
      processMap_.put("getColumnDescriptors", new getColumnDescriptors());
      processMap_.put("getTableRegions", new getTableRegions());
      processMap_.put("createTable", new createTable());
      processMap_.put("deleteTable", new deleteTable());
      processMap_.put("get", new get());
      processMap_.put("getVer", new getVer());
      processMap_.put("getVerTs", new getVerTs());
      processMap_.put("getRow", new getRow());
      processMap_.put("getRowWithColumns", new getRowWithColumns());
      processMap_.put("getRowTs", new getRowTs());
      processMap_.put("getRowWithColumnsTs", new getRowWithColumnsTs());
      processMap_.put("getRows", new getRows());
      processMap_.put("getRowsWithColumns", new getRowsWithColumns());
      processMap_.put("getRowsTs", new getRowsTs());
      processMap_.put("getRowsWithColumnsTs", new getRowsWithColumnsTs());
      processMap_.put("mutateRow", new mutateRow());
      processMap_.put("mutateRowTs", new mutateRowTs());
      processMap_.put("mutateRows", new mutateRows());
      processMap_.put("mutateRowsTs", new mutateRowsTs());
      processMap_.put("atomicIncrement", new atomicIncrement());
      processMap_.put("deleteAll", new deleteAll());
      processMap_.put("deleteAllTs", new deleteAllTs());
      processMap_.put("deleteAllRow", new deleteAllRow());
      processMap_.put("deleteAllRowTs", new deleteAllRowTs());
      processMap_.put("scannerOpen", new scannerOpen());
      processMap_.put("scannerOpenWithStop", new scannerOpenWithStop());
      processMap_.put("scannerOpenWithPrefix", new scannerOpenWithPrefix());
      processMap_.put("scannerOpenTs", new scannerOpenTs());
      processMap_.put("scannerOpenWithStopTs", new scannerOpenWithStopTs());
      processMap_.put("scannerGet", new scannerGet());
      processMap_.put("scannerGetList", new scannerGetList());
      processMap_.put("scannerClose", new scannerClose());
      processMap_.put("parallelGet", new parallelGet());
      processMap_.put("asyncAtomicIncrements", new asyncAtomicIncrements());
      processMap_.put("queueIncrementColumnValues", new queueIncrementColumnValues());
    }

    protected static interface ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException;
    }

    private Iface iface_;
    protected final HashMap<String,ProcessFunction> processMap_ = new HashMap<String,ProcessFunction>();

    public boolean process(TProtocol iprot, TProtocol oprot) throws TException
    {
      TMessage msg = iprot.readMessageBegin();
      ProcessFunction fn = processMap_.get(msg.name);
      if (fn == null) {
        TProtocolUtil.skip(iprot, TType.STRUCT);
        iprot.readMessageEnd();
        TApplicationException x = new TApplicationException(TApplicationException.UNKNOWN_METHOD, "Invalid method name: '"+msg.name+"'");
        oprot.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
        x.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        return true;
      }
      fn.process(msg.seqid, iprot, oprot);
      return true;
    }

    private class enableTable implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        enableTable_args args = new enableTable_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("enableTable", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        enableTable_result result = new enableTable_result();
        try {
          iface_.enableTable(args.tableName);
        } catch (IOError io) {
          result.io = io;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing enableTable", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing enableTable");
          oprot.writeMessageBegin(new TMessage("enableTable", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("enableTable", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class disableTable implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        disableTable_args args = new disableTable_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("disableTable", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        disableTable_result result = new disableTable_result();
        try {
          iface_.disableTable(args.tableName);
        } catch (IOError io) {
          result.io = io;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing disableTable", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing disableTable");
          oprot.writeMessageBegin(new TMessage("disableTable", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("disableTable", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class isTableEnabled implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        isTableEnabled_args args = new isTableEnabled_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("isTableEnabled", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        isTableEnabled_result result = new isTableEnabled_result();
        try {
          result.success = iface_.isTableEnabled(args.tableName);
          result.setSuccessIsSet(true);
        } catch (IOError io) {
          result.io = io;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing isTableEnabled", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing isTableEnabled");
          oprot.writeMessageBegin(new TMessage("isTableEnabled", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("isTableEnabled", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class compact implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        compact_args args = new compact_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("compact", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        compact_result result = new compact_result();
        try {
          iface_.compact(args.tableNameOrRegionName);
        } catch (IOError io) {
          result.io = io;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing compact", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing compact");
          oprot.writeMessageBegin(new TMessage("compact", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("compact", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class majorCompact implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        majorCompact_args args = new majorCompact_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("majorCompact", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        majorCompact_result result = new majorCompact_result();
        try {
          iface_.majorCompact(args.tableNameOrRegionName);
        } catch (IOError io) {
          result.io = io;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing majorCompact", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing majorCompact");
          oprot.writeMessageBegin(new TMessage("majorCompact", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("majorCompact", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getTableNames implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getTableNames_args args = new getTableNames_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getTableNames", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getTableNames_result result = new getTableNames_result();
        try {
          result.success = iface_.getTableNames();
        } catch (IOError io) {
          result.io = io;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing getTableNames", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing getTableNames");
          oprot.writeMessageBegin(new TMessage("getTableNames", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getTableNames", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getColumnDescriptors implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getColumnDescriptors_args args = new getColumnDescriptors_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getColumnDescriptors", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getColumnDescriptors_result result = new getColumnDescriptors_result();
        try {
          result.success = iface_.getColumnDescriptors(args.tableName);
        } catch (IOError io) {
          result.io = io;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing getColumnDescriptors", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing getColumnDescriptors");
          oprot.writeMessageBegin(new TMessage("getColumnDescriptors", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getColumnDescriptors", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getTableRegions implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getTableRegions_args args = new getTableRegions_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getTableRegions", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getTableRegions_result result = new getTableRegions_result();
        try {
          result.success = iface_.getTableRegions(args.tableName);
        } catch (IOError io) {
          result.io = io;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing getTableRegions", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing getTableRegions");
          oprot.writeMessageBegin(new TMessage("getTableRegions", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getTableRegions", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class createTable implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        createTable_args args = new createTable_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("createTable", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        createTable_result result = new createTable_result();
        try {
          iface_.createTable(args.tableName, args.columnFamilies);
        } catch (IOError io) {
          result.io = io;
        } catch (IllegalArgument ia) {
          result.ia = ia;
        } catch (AlreadyExists exist) {
          result.exist = exist;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing createTable", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing createTable");
          oprot.writeMessageBegin(new TMessage("createTable", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("createTable", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class deleteTable implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        deleteTable_args args = new deleteTable_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("deleteTable", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        deleteTable_result result = new deleteTable_result();
        try {
          iface_.deleteTable(args.tableName);
        } catch (IOError io) {
          result.io = io;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing deleteTable", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing deleteTable");
          oprot.writeMessageBegin(new TMessage("deleteTable", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("deleteTable", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_args args = new get_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("get", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        get_result result = new get_result();
        try {
          result.success = iface_.get(args.tableName, args.row, args.column);
        } catch (IOError io) {
          result.io = io;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get");
          oprot.writeMessageBegin(new TMessage("get", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getVer implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getVer_args args = new getVer_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getVer", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getVer_result result = new getVer_result();
        try {
          result.success = iface_.getVer(args.tableName, args.row, args.column, args.numVersions);
        } catch (IOError io) {
          result.io = io;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing getVer", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing getVer");
          oprot.writeMessageBegin(new TMessage("getVer", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getVer", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getVerTs implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getVerTs_args args = new getVerTs_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getVerTs", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getVerTs_result result = new getVerTs_result();
        try {
          result.success = iface_.getVerTs(args.tableName, args.row, args.column, args.timestamp, args.numVersions);
        } catch (IOError io) {
          result.io = io;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing getVerTs", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing getVerTs");
          oprot.writeMessageBegin(new TMessage("getVerTs", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getVerTs", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getRow implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getRow_args args = new getRow_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getRow", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getRow_result result = new getRow_result();
        try {
          result.success = iface_.getRow(args.tableName, args.row);
        } catch (IOError io) {
          result.io = io;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing getRow", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing getRow");
          oprot.writeMessageBegin(new TMessage("getRow", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getRow", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getRowWithColumns implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getRowWithColumns_args args = new getRowWithColumns_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getRowWithColumns", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getRowWithColumns_result result = new getRowWithColumns_result();
        try {
          result.success = iface_.getRowWithColumns(args.tableName, args.row, args.columns);
        } catch (IOError io) {
          result.io = io;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing getRowWithColumns", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing getRowWithColumns");
          oprot.writeMessageBegin(new TMessage("getRowWithColumns", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getRowWithColumns", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getRowTs implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getRowTs_args args = new getRowTs_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getRowTs", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getRowTs_result result = new getRowTs_result();
        try {
          result.success = iface_.getRowTs(args.tableName, args.row, args.timestamp);
        } catch (IOError io) {
          result.io = io;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing getRowTs", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing getRowTs");
          oprot.writeMessageBegin(new TMessage("getRowTs", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getRowTs", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getRowWithColumnsTs implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getRowWithColumnsTs_args args = new getRowWithColumnsTs_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getRowWithColumnsTs", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getRowWithColumnsTs_result result = new getRowWithColumnsTs_result();
        try {
          result.success = iface_.getRowWithColumnsTs(args.tableName, args.row, args.columns, args.timestamp);
        } catch (IOError io) {
          result.io = io;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing getRowWithColumnsTs", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing getRowWithColumnsTs");
          oprot.writeMessageBegin(new TMessage("getRowWithColumnsTs", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getRowWithColumnsTs", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getRows implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getRows_args args = new getRows_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getRows", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getRows_result result = new getRows_result();
        try {
          result.success = iface_.getRows(args.tableName, args.rows);
        } catch (IOError io) {
          result.io = io;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing getRows", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing getRows");
          oprot.writeMessageBegin(new TMessage("getRows", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getRows", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getRowsWithColumns implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getRowsWithColumns_args args = new getRowsWithColumns_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getRowsWithColumns", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getRowsWithColumns_result result = new getRowsWithColumns_result();
        try {
          result.success = iface_.getRowsWithColumns(args.tableName, args.rows, args.columns);
        } catch (IOError io) {
          result.io = io;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing getRowsWithColumns", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing getRowsWithColumns");
          oprot.writeMessageBegin(new TMessage("getRowsWithColumns", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getRowsWithColumns", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getRowsTs implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getRowsTs_args args = new getRowsTs_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getRowsTs", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getRowsTs_result result = new getRowsTs_result();
        try {
          result.success = iface_.getRowsTs(args.tableName, args.rows, args.timestamp);
        } catch (IOError io) {
          result.io = io;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing getRowsTs", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing getRowsTs");
          oprot.writeMessageBegin(new TMessage("getRowsTs", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getRowsTs", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getRowsWithColumnsTs implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getRowsWithColumnsTs_args args = new getRowsWithColumnsTs_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getRowsWithColumnsTs", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getRowsWithColumnsTs_result result = new getRowsWithColumnsTs_result();
        try {
          result.success = iface_.getRowsWithColumnsTs(args.tableName, args.rows, args.columns, args.timestamp);
        } catch (IOError io) {
          result.io = io;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing getRowsWithColumnsTs", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing getRowsWithColumnsTs");
          oprot.writeMessageBegin(new TMessage("getRowsWithColumnsTs", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getRowsWithColumnsTs", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class mutateRow implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        mutateRow_args args = new mutateRow_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("mutateRow", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        mutateRow_result result = new mutateRow_result();
        try {
          iface_.mutateRow(args.tableName, args.row, args.mutations);
        } catch (IOError io) {
          result.io = io;
        } catch (IllegalArgument ia) {
          result.ia = ia;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing mutateRow", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing mutateRow");
          oprot.writeMessageBegin(new TMessage("mutateRow", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("mutateRow", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class mutateRowTs implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        mutateRowTs_args args = new mutateRowTs_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("mutateRowTs", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        mutateRowTs_result result = new mutateRowTs_result();
        try {
          iface_.mutateRowTs(args.tableName, args.row, args.mutations, args.timestamp);
        } catch (IOError io) {
          result.io = io;
        } catch (IllegalArgument ia) {
          result.ia = ia;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing mutateRowTs", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing mutateRowTs");
          oprot.writeMessageBegin(new TMessage("mutateRowTs", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("mutateRowTs", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class mutateRows implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        mutateRows_args args = new mutateRows_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("mutateRows", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        mutateRows_result result = new mutateRows_result();
        try {
          iface_.mutateRows(args.tableName, args.rowBatches);
        } catch (IOError io) {
          result.io = io;
        } catch (IllegalArgument ia) {
          result.ia = ia;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing mutateRows", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing mutateRows");
          oprot.writeMessageBegin(new TMessage("mutateRows", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("mutateRows", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class mutateRowsTs implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        mutateRowsTs_args args = new mutateRowsTs_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("mutateRowsTs", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        mutateRowsTs_result result = new mutateRowsTs_result();
        try {
          iface_.mutateRowsTs(args.tableName, args.rowBatches, args.timestamp);
        } catch (IOError io) {
          result.io = io;
        } catch (IllegalArgument ia) {
          result.ia = ia;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing mutateRowsTs", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing mutateRowsTs");
          oprot.writeMessageBegin(new TMessage("mutateRowsTs", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("mutateRowsTs", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class atomicIncrement implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        atomicIncrement_args args = new atomicIncrement_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("atomicIncrement", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        atomicIncrement_result result = new atomicIncrement_result();
        try {
          result.success = iface_.atomicIncrement(args.tableName, args.row, args.column, args.value);
          result.setSuccessIsSet(true);
        } catch (IOError io) {
          result.io = io;
        } catch (IllegalArgument ia) {
          result.ia = ia;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing atomicIncrement", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing atomicIncrement");
          oprot.writeMessageBegin(new TMessage("atomicIncrement", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("atomicIncrement", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class deleteAll implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        deleteAll_args args = new deleteAll_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("deleteAll", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        deleteAll_result result = new deleteAll_result();
        try {
          iface_.deleteAll(args.tableName, args.row, args.column);
        } catch (IOError io) {
          result.io = io;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing deleteAll", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing deleteAll");
          oprot.writeMessageBegin(new TMessage("deleteAll", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("deleteAll", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class deleteAllTs implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        deleteAllTs_args args = new deleteAllTs_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("deleteAllTs", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        deleteAllTs_result result = new deleteAllTs_result();
        try {
          iface_.deleteAllTs(args.tableName, args.row, args.column, args.timestamp);
        } catch (IOError io) {
          result.io = io;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing deleteAllTs", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing deleteAllTs");
          oprot.writeMessageBegin(new TMessage("deleteAllTs", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("deleteAllTs", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class deleteAllRow implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        deleteAllRow_args args = new deleteAllRow_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("deleteAllRow", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        deleteAllRow_result result = new deleteAllRow_result();
        try {
          iface_.deleteAllRow(args.tableName, args.row);
        } catch (IOError io) {
          result.io = io;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing deleteAllRow", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing deleteAllRow");
          oprot.writeMessageBegin(new TMessage("deleteAllRow", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("deleteAllRow", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class deleteAllRowTs implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        deleteAllRowTs_args args = new deleteAllRowTs_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("deleteAllRowTs", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        deleteAllRowTs_result result = new deleteAllRowTs_result();
        try {
          iface_.deleteAllRowTs(args.tableName, args.row, args.timestamp);
        } catch (IOError io) {
          result.io = io;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing deleteAllRowTs", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing deleteAllRowTs");
          oprot.writeMessageBegin(new TMessage("deleteAllRowTs", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("deleteAllRowTs", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class scannerOpen implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        scannerOpen_args args = new scannerOpen_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("scannerOpen", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        scannerOpen_result result = new scannerOpen_result();
        try {
          result.success = iface_.scannerOpen(args.tableName, args.startRow, args.columns);
          result.setSuccessIsSet(true);
        } catch (IOError io) {
          result.io = io;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing scannerOpen", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing scannerOpen");
          oprot.writeMessageBegin(new TMessage("scannerOpen", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("scannerOpen", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class scannerOpenWithStop implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        scannerOpenWithStop_args args = new scannerOpenWithStop_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("scannerOpenWithStop", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        scannerOpenWithStop_result result = new scannerOpenWithStop_result();
        try {
          result.success = iface_.scannerOpenWithStop(args.tableName, args.startRow, args.stopRow, args.columns);
          result.setSuccessIsSet(true);
        } catch (IOError io) {
          result.io = io;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing scannerOpenWithStop", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing scannerOpenWithStop");
          oprot.writeMessageBegin(new TMessage("scannerOpenWithStop", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("scannerOpenWithStop", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class scannerOpenWithPrefix implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        scannerOpenWithPrefix_args args = new scannerOpenWithPrefix_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("scannerOpenWithPrefix", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        scannerOpenWithPrefix_result result = new scannerOpenWithPrefix_result();
        try {
          result.success = iface_.scannerOpenWithPrefix(args.tableName, args.startAndPrefix, args.columns);
          result.setSuccessIsSet(true);
        } catch (IOError io) {
          result.io = io;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing scannerOpenWithPrefix", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing scannerOpenWithPrefix");
          oprot.writeMessageBegin(new TMessage("scannerOpenWithPrefix", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("scannerOpenWithPrefix", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class scannerOpenTs implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        scannerOpenTs_args args = new scannerOpenTs_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("scannerOpenTs", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        scannerOpenTs_result result = new scannerOpenTs_result();
        try {
          result.success = iface_.scannerOpenTs(args.tableName, args.startRow, args.columns, args.timestamp);
          result.setSuccessIsSet(true);
        } catch (IOError io) {
          result.io = io;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing scannerOpenTs", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing scannerOpenTs");
          oprot.writeMessageBegin(new TMessage("scannerOpenTs", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("scannerOpenTs", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class scannerOpenWithStopTs implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        scannerOpenWithStopTs_args args = new scannerOpenWithStopTs_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("scannerOpenWithStopTs", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        scannerOpenWithStopTs_result result = new scannerOpenWithStopTs_result();
        try {
          result.success = iface_.scannerOpenWithStopTs(args.tableName, args.startRow, args.stopRow, args.columns, args.timestamp);
          result.setSuccessIsSet(true);
        } catch (IOError io) {
          result.io = io;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing scannerOpenWithStopTs", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing scannerOpenWithStopTs");
          oprot.writeMessageBegin(new TMessage("scannerOpenWithStopTs", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("scannerOpenWithStopTs", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class scannerGet implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        scannerGet_args args = new scannerGet_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("scannerGet", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        scannerGet_result result = new scannerGet_result();
        try {
          result.success = iface_.scannerGet(args.id);
        } catch (IOError io) {
          result.io = io;
        } catch (IllegalArgument ia) {
          result.ia = ia;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing scannerGet", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing scannerGet");
          oprot.writeMessageBegin(new TMessage("scannerGet", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("scannerGet", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class scannerGetList implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        scannerGetList_args args = new scannerGetList_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("scannerGetList", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        scannerGetList_result result = new scannerGetList_result();
        try {
          result.success = iface_.scannerGetList(args.id, args.nbRows);
        } catch (IOError io) {
          result.io = io;
        } catch (IllegalArgument ia) {
          result.ia = ia;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing scannerGetList", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing scannerGetList");
          oprot.writeMessageBegin(new TMessage("scannerGetList", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("scannerGetList", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class scannerClose implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        scannerClose_args args = new scannerClose_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("scannerClose", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        scannerClose_result result = new scannerClose_result();
        try {
          iface_.scannerClose(args.id);
        } catch (IOError io) {
          result.io = io;
        } catch (IllegalArgument ia) {
          result.ia = ia;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing scannerClose", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing scannerClose");
          oprot.writeMessageBegin(new TMessage("scannerClose", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("scannerClose", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class parallelGet implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        parallelGet_args args = new parallelGet_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("parallelGet", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        parallelGet_result result = new parallelGet_result();
        try {
          result.success = iface_.parallelGet(args.tableName, args.column, args.rows);
        } catch (IOError io) {
          result.io = io;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing parallelGet", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing parallelGet");
          oprot.writeMessageBegin(new TMessage("parallelGet", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("parallelGet", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class asyncAtomicIncrements implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        asyncAtomicIncrements_args args = new asyncAtomicIncrements_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("asyncAtomicIncrements", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        iface_.asyncAtomicIncrements(args.increments);
        return;
      }
    }

    private class queueIncrementColumnValues implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        queueIncrementColumnValues_args args = new queueIncrementColumnValues_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("queueIncrementColumnValues", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        queueIncrementColumnValues_result result = new queueIncrementColumnValues_result();
        result.success = iface_.queueIncrementColumnValues(args.increments);
        result.setSuccessIsSet(true);
        oprot.writeMessageBegin(new TMessage("queueIncrementColumnValues", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

  }

  public static class enableTable_args implements TBase<enableTable_args, enableTable_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("enableTable_args");

    private static final TField TABLE_NAME_FIELD_DESC = new TField("tableName", TType.STRING, (short)1);

    /**
     * name of the table
     */
    public ByteBuffer tableName;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      /**
       * name of the table
       */
      TABLE_NAME((short)1, "tableName");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // TABLE_NAME
            return TABLE_NAME;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.TABLE_NAME, new FieldMetaData("tableName", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Bytes")));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(enableTable_args.class, metaDataMap);
    }

    public enableTable_args() {
    }

    public enableTable_args(
      ByteBuffer tableName)
    {
      this();
      this.tableName = tableName;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public enableTable_args(enableTable_args other) {
      if (other.isSetTableName()) {
        this.tableName = other.tableName;
      }
    }

    public enableTable_args deepCopy() {
      return new enableTable_args(this);
    }

    @Override
    public void clear() {
      this.tableName = null;
    }

    /**
     * name of the table
     */
    public byte[] getTableName() {
      setTableName(TBaseHelper.rightSize(tableName));
      return tableName.array();
    }

    public ByteBuffer BufferForTableName() {
      return tableName;
    }

    /**
     * name of the table
     */
    public enableTable_args setTableName(byte[] tableName) {
      setTableName(ByteBuffer.wrap(tableName));
      return this;
    }

    public enableTable_args setTableName(ByteBuffer tableName) {
      this.tableName = tableName;
      return this;
    }

    public void unsetTableName() {
      this.tableName = null;
    }

    /** Returns true if field tableName is set (has been asigned a value) and false otherwise */
    public boolean isSetTableName() {
      return this.tableName != null;
    }

    public void setTableNameIsSet(boolean value) {
      if (!value) {
        this.tableName = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TABLE_NAME:
        if (value == null) {
          unsetTableName();
        } else {
          setTableName((ByteBuffer)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return getTableName();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case TABLE_NAME:
        return isSetTableName();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof enableTable_args)
        return this.equals((enableTable_args)that);
      return false;
    }

    public boolean equals(enableTable_args that) {
      if (that == null)
        return false;

      boolean this_present_tableName = true && this.isSetTableName();
      boolean that_present_tableName = true && that.isSetTableName();
      if (this_present_tableName || that_present_tableName) {
        if (!(this_present_tableName && that_present_tableName))
          return false;
        if (!this.tableName.equals(that.tableName))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(enableTable_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      enableTable_args typedOther = (enableTable_args)other;

      lastComparison = Boolean.valueOf(isSetTableName()).compareTo(typedOther.isSetTableName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTableName()) {
        lastComparison = TBaseHelper.compareTo(this.tableName, typedOther.tableName);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 1: // TABLE_NAME
            if (field.type == TType.STRING) {
              this.tableName = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tableName != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeBinary(this.tableName);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("enableTable_args(");
      boolean first = true;

      sb.append("tableName:");
      if (this.tableName == null) {
        sb.append("null");
      } else {
        sb.append(this.tableName);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class enableTable_result implements TBase<enableTable_result, enableTable_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("enableTable_result");

    private static final TField IO_FIELD_DESC = new TField("io", TType.STRUCT, (short)1);

    public IOError io;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      IO((short)1, "io");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // IO
            return IO;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.IO, new FieldMetaData("io", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(enableTable_result.class, metaDataMap);
    }

    public enableTable_result() {
    }

    public enableTable_result(
      IOError io)
    {
      this();
      this.io = io;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public enableTable_result(enableTable_result other) {
      if (other.isSetIo()) {
        this.io = new IOError(other.io);
      }
    }

    public enableTable_result deepCopy() {
      return new enableTable_result(this);
    }

    @Override
    public void clear() {
      this.io = null;
    }

    public IOError getIo() {
      return this.io;
    }

    public enableTable_result setIo(IOError io) {
      this.io = io;
      return this;
    }

    public void unsetIo() {
      this.io = null;
    }

    /** Returns true if field io is set (has been asigned a value) and false otherwise */
    public boolean isSetIo() {
      return this.io != null;
    }

    public void setIoIsSet(boolean value) {
      if (!value) {
        this.io = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case IO:
        if (value == null) {
          unsetIo();
        } else {
          setIo((IOError)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case IO:
        return getIo();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case IO:
        return isSetIo();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof enableTable_result)
        return this.equals((enableTable_result)that);
      return false;
    }

    public boolean equals(enableTable_result that) {
      if (that == null)
        return false;

      boolean this_present_io = true && this.isSetIo();
      boolean that_present_io = true && that.isSetIo();
      if (this_present_io || that_present_io) {
        if (!(this_present_io && that_present_io))
          return false;
        if (!this.io.equals(that.io))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(enableTable_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      enableTable_result typedOther = (enableTable_result)other;

      lastComparison = Boolean.valueOf(isSetIo()).compareTo(typedOther.isSetIo());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetIo()) {
        lastComparison = TBaseHelper.compareTo(this.io, typedOther.io);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 1: // IO
            if (field.type == TType.STRUCT) {
              this.io = new IOError();
              this.io.read(iprot);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetIo()) {
        oprot.writeFieldBegin(IO_FIELD_DESC);
        this.io.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("enableTable_result(");
      boolean first = true;

      sb.append("io:");
      if (this.io == null) {
        sb.append("null");
      } else {
        sb.append(this.io);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class disableTable_args implements TBase<disableTable_args, disableTable_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("disableTable_args");

    private static final TField TABLE_NAME_FIELD_DESC = new TField("tableName", TType.STRING, (short)1);

    /**
     * name of the table
     */
    public ByteBuffer tableName;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      /**
       * name of the table
       */
      TABLE_NAME((short)1, "tableName");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // TABLE_NAME
            return TABLE_NAME;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.TABLE_NAME, new FieldMetaData("tableName", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Bytes")));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(disableTable_args.class, metaDataMap);
    }

    public disableTable_args() {
    }

    public disableTable_args(
      ByteBuffer tableName)
    {
      this();
      this.tableName = tableName;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public disableTable_args(disableTable_args other) {
      if (other.isSetTableName()) {
        this.tableName = other.tableName;
      }
    }

    public disableTable_args deepCopy() {
      return new disableTable_args(this);
    }

    @Override
    public void clear() {
      this.tableName = null;
    }

    /**
     * name of the table
     */
    public byte[] getTableName() {
      setTableName(TBaseHelper.rightSize(tableName));
      return tableName.array();
    }

    public ByteBuffer BufferForTableName() {
      return tableName;
    }

    /**
     * name of the table
     */
    public disableTable_args setTableName(byte[] tableName) {
      setTableName(ByteBuffer.wrap(tableName));
      return this;
    }

    public disableTable_args setTableName(ByteBuffer tableName) {
      this.tableName = tableName;
      return this;
    }

    public void unsetTableName() {
      this.tableName = null;
    }

    /** Returns true if field tableName is set (has been asigned a value) and false otherwise */
    public boolean isSetTableName() {
      return this.tableName != null;
    }

    public void setTableNameIsSet(boolean value) {
      if (!value) {
        this.tableName = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TABLE_NAME:
        if (value == null) {
          unsetTableName();
        } else {
          setTableName((ByteBuffer)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return getTableName();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case TABLE_NAME:
        return isSetTableName();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof disableTable_args)
        return this.equals((disableTable_args)that);
      return false;
    }

    public boolean equals(disableTable_args that) {
      if (that == null)
        return false;

      boolean this_present_tableName = true && this.isSetTableName();
      boolean that_present_tableName = true && that.isSetTableName();
      if (this_present_tableName || that_present_tableName) {
        if (!(this_present_tableName && that_present_tableName))
          return false;
        if (!this.tableName.equals(that.tableName))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(disableTable_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      disableTable_args typedOther = (disableTable_args)other;

      lastComparison = Boolean.valueOf(isSetTableName()).compareTo(typedOther.isSetTableName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTableName()) {
        lastComparison = TBaseHelper.compareTo(this.tableName, typedOther.tableName);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 1: // TABLE_NAME
            if (field.type == TType.STRING) {
              this.tableName = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tableName != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeBinary(this.tableName);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("disableTable_args(");
      boolean first = true;

      sb.append("tableName:");
      if (this.tableName == null) {
        sb.append("null");
      } else {
        sb.append(this.tableName);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class disableTable_result implements TBase<disableTable_result, disableTable_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("disableTable_result");

    private static final TField IO_FIELD_DESC = new TField("io", TType.STRUCT, (short)1);

    public IOError io;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      IO((short)1, "io");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // IO
            return IO;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.IO, new FieldMetaData("io", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(disableTable_result.class, metaDataMap);
    }

    public disableTable_result() {
    }

    public disableTable_result(
      IOError io)
    {
      this();
      this.io = io;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public disableTable_result(disableTable_result other) {
      if (other.isSetIo()) {
        this.io = new IOError(other.io);
      }
    }

    public disableTable_result deepCopy() {
      return new disableTable_result(this);
    }

    @Override
    public void clear() {
      this.io = null;
    }

    public IOError getIo() {
      return this.io;
    }

    public disableTable_result setIo(IOError io) {
      this.io = io;
      return this;
    }

    public void unsetIo() {
      this.io = null;
    }

    /** Returns true if field io is set (has been asigned a value) and false otherwise */
    public boolean isSetIo() {
      return this.io != null;
    }

    public void setIoIsSet(boolean value) {
      if (!value) {
        this.io = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case IO:
        if (value == null) {
          unsetIo();
        } else {
          setIo((IOError)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case IO:
        return getIo();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case IO:
        return isSetIo();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof disableTable_result)
        return this.equals((disableTable_result)that);
      return false;
    }

    public boolean equals(disableTable_result that) {
      if (that == null)
        return false;

      boolean this_present_io = true && this.isSetIo();
      boolean that_present_io = true && that.isSetIo();
      if (this_present_io || that_present_io) {
        if (!(this_present_io && that_present_io))
          return false;
        if (!this.io.equals(that.io))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(disableTable_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      disableTable_result typedOther = (disableTable_result)other;

      lastComparison = Boolean.valueOf(isSetIo()).compareTo(typedOther.isSetIo());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetIo()) {
        lastComparison = TBaseHelper.compareTo(this.io, typedOther.io);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 1: // IO
            if (field.type == TType.STRUCT) {
              this.io = new IOError();
              this.io.read(iprot);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetIo()) {
        oprot.writeFieldBegin(IO_FIELD_DESC);
        this.io.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("disableTable_result(");
      boolean first = true;

      sb.append("io:");
      if (this.io == null) {
        sb.append("null");
      } else {
        sb.append(this.io);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class isTableEnabled_args implements TBase<isTableEnabled_args, isTableEnabled_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("isTableEnabled_args");

    private static final TField TABLE_NAME_FIELD_DESC = new TField("tableName", TType.STRING, (short)1);

    /**
     * name of the table to check
     */
    public ByteBuffer tableName;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      /**
       * name of the table to check
       */
      TABLE_NAME((short)1, "tableName");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // TABLE_NAME
            return TABLE_NAME;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.TABLE_NAME, new FieldMetaData("tableName", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Bytes")));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(isTableEnabled_args.class, metaDataMap);
    }

    public isTableEnabled_args() {
    }

    public isTableEnabled_args(
      ByteBuffer tableName)
    {
      this();
      this.tableName = tableName;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public isTableEnabled_args(isTableEnabled_args other) {
      if (other.isSetTableName()) {
        this.tableName = other.tableName;
      }
    }

    public isTableEnabled_args deepCopy() {
      return new isTableEnabled_args(this);
    }

    @Override
    public void clear() {
      this.tableName = null;
    }

    /**
     * name of the table to check
     */
    public byte[] getTableName() {
      setTableName(TBaseHelper.rightSize(tableName));
      return tableName.array();
    }

    public ByteBuffer BufferForTableName() {
      return tableName;
    }

    /**
     * name of the table to check
     */
    public isTableEnabled_args setTableName(byte[] tableName) {
      setTableName(ByteBuffer.wrap(tableName));
      return this;
    }

    public isTableEnabled_args setTableName(ByteBuffer tableName) {
      this.tableName = tableName;
      return this;
    }

    public void unsetTableName() {
      this.tableName = null;
    }

    /** Returns true if field tableName is set (has been asigned a value) and false otherwise */
    public boolean isSetTableName() {
      return this.tableName != null;
    }

    public void setTableNameIsSet(boolean value) {
      if (!value) {
        this.tableName = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TABLE_NAME:
        if (value == null) {
          unsetTableName();
        } else {
          setTableName((ByteBuffer)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return getTableName();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case TABLE_NAME:
        return isSetTableName();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof isTableEnabled_args)
        return this.equals((isTableEnabled_args)that);
      return false;
    }

    public boolean equals(isTableEnabled_args that) {
      if (that == null)
        return false;

      boolean this_present_tableName = true && this.isSetTableName();
      boolean that_present_tableName = true && that.isSetTableName();
      if (this_present_tableName || that_present_tableName) {
        if (!(this_present_tableName && that_present_tableName))
          return false;
        if (!this.tableName.equals(that.tableName))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(isTableEnabled_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      isTableEnabled_args typedOther = (isTableEnabled_args)other;

      lastComparison = Boolean.valueOf(isSetTableName()).compareTo(typedOther.isSetTableName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTableName()) {
        lastComparison = TBaseHelper.compareTo(this.tableName, typedOther.tableName);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 1: // TABLE_NAME
            if (field.type == TType.STRING) {
              this.tableName = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tableName != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeBinary(this.tableName);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("isTableEnabled_args(");
      boolean first = true;

      sb.append("tableName:");
      if (this.tableName == null) {
        sb.append("null");
      } else {
        sb.append(this.tableName);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class isTableEnabled_result implements TBase<isTableEnabled_result, isTableEnabled_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("isTableEnabled_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.BOOL, (short)0);
    private static final TField IO_FIELD_DESC = new TField("io", TType.STRUCT, (short)1);

    public boolean success;
    public IOError io;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      IO((short)1, "io");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // IO
            return IO;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.BOOL)));
      tmpMap.put(_Fields.IO, new FieldMetaData("io", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(isTableEnabled_result.class, metaDataMap);
    }

    public isTableEnabled_result() {
    }

    public isTableEnabled_result(
      boolean success,
      IOError io)
    {
      this();
      this.success = success;
      setSuccessIsSet(true);
      this.io = io;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public isTableEnabled_result(isTableEnabled_result other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.success = other.success;
      if (other.isSetIo()) {
        this.io = new IOError(other.io);
      }
    }

    public isTableEnabled_result deepCopy() {
      return new isTableEnabled_result(this);
    }

    @Override
    public void clear() {
      setSuccessIsSet(false);
      this.success = false;
      this.io = null;
    }

    public boolean isSuccess() {
      return this.success;
    }

    public isTableEnabled_result setSuccess(boolean success) {
      this.success = success;
      setSuccessIsSet(true);
      return this;
    }

    public void unsetSuccess() {
      __isset_bit_vector.clear(__SUCCESS_ISSET_ID);
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return __isset_bit_vector.get(__SUCCESS_ISSET_ID);
    }

    public void setSuccessIsSet(boolean value) {
      __isset_bit_vector.set(__SUCCESS_ISSET_ID, value);
    }

    public IOError getIo() {
      return this.io;
    }

    public isTableEnabled_result setIo(IOError io) {
      this.io = io;
      return this;
    }

    public void unsetIo() {
      this.io = null;
    }

    /** Returns true if field io is set (has been asigned a value) and false otherwise */
    public boolean isSetIo() {
      return this.io != null;
    }

    public void setIoIsSet(boolean value) {
      if (!value) {
        this.io = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Boolean)value);
        }
        break;

      case IO:
        if (value == null) {
          unsetIo();
        } else {
          setIo((IOError)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return new Boolean(isSuccess());

      case IO:
        return getIo();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case IO:
        return isSetIo();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof isTableEnabled_result)
        return this.equals((isTableEnabled_result)that);
      return false;
    }

    public boolean equals(isTableEnabled_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_io = true && this.isSetIo();
      boolean that_present_io = true && that.isSetIo();
      if (this_present_io || that_present_io) {
        if (!(this_present_io && that_present_io))
          return false;
        if (!this.io.equals(that.io))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(isTableEnabled_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      isTableEnabled_result typedOther = (isTableEnabled_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetIo()).compareTo(typedOther.isSetIo());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetIo()) {
        lastComparison = TBaseHelper.compareTo(this.io, typedOther.io);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.BOOL) {
              this.success = iprot.readBool();
              setSuccessIsSet(true);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // IO
            if (field.type == TType.STRUCT) {
              this.io = new IOError();
              this.io.read(iprot);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeBool(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetIo()) {
        oprot.writeFieldBegin(IO_FIELD_DESC);
        this.io.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("isTableEnabled_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("io:");
      if (this.io == null) {
        sb.append("null");
      } else {
        sb.append(this.io);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class compact_args implements TBase<compact_args, compact_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("compact_args");

    private static final TField TABLE_NAME_OR_REGION_NAME_FIELD_DESC = new TField("tableNameOrRegionName", TType.STRING, (short)1);

    public ByteBuffer tableNameOrRegionName;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      TABLE_NAME_OR_REGION_NAME((short)1, "tableNameOrRegionName");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // TABLE_NAME_OR_REGION_NAME
            return TABLE_NAME_OR_REGION_NAME;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.TABLE_NAME_OR_REGION_NAME, new FieldMetaData("tableNameOrRegionName", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Bytes")));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(compact_args.class, metaDataMap);
    }

    public compact_args() {
    }

    public compact_args(
      ByteBuffer tableNameOrRegionName)
    {
      this();
      this.tableNameOrRegionName = tableNameOrRegionName;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public compact_args(compact_args other) {
      if (other.isSetTableNameOrRegionName()) {
        this.tableNameOrRegionName = other.tableNameOrRegionName;
      }
    }

    public compact_args deepCopy() {
      return new compact_args(this);
    }

    @Override
    public void clear() {
      this.tableNameOrRegionName = null;
    }

    public byte[] getTableNameOrRegionName() {
      setTableNameOrRegionName(TBaseHelper.rightSize(tableNameOrRegionName));
      return tableNameOrRegionName.array();
    }

    public ByteBuffer BufferForTableNameOrRegionName() {
      return tableNameOrRegionName;
    }

    public compact_args setTableNameOrRegionName(byte[] tableNameOrRegionName) {
      setTableNameOrRegionName(ByteBuffer.wrap(tableNameOrRegionName));
      return this;
    }

    public compact_args setTableNameOrRegionName(ByteBuffer tableNameOrRegionName) {
      this.tableNameOrRegionName = tableNameOrRegionName;
      return this;
    }

    public void unsetTableNameOrRegionName() {
      this.tableNameOrRegionName = null;
    }

    /** Returns true if field tableNameOrRegionName is set (has been asigned a value) and false otherwise */
    public boolean isSetTableNameOrRegionName() {
      return this.tableNameOrRegionName != null;
    }

    public void setTableNameOrRegionNameIsSet(boolean value) {
      if (!value) {
        this.tableNameOrRegionName = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TABLE_NAME_OR_REGION_NAME:
        if (value == null) {
          unsetTableNameOrRegionName();
        } else {
          setTableNameOrRegionName((ByteBuffer)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TABLE_NAME_OR_REGION_NAME:
        return getTableNameOrRegionName();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case TABLE_NAME_OR_REGION_NAME:
        return isSetTableNameOrRegionName();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof compact_args)
        return this.equals((compact_args)that);
      return false;
    }

    public boolean equals(compact_args that) {
      if (that == null)
        return false;

      boolean this_present_tableNameOrRegionName = true && this.isSetTableNameOrRegionName();
      boolean that_present_tableNameOrRegionName = true && that.isSetTableNameOrRegionName();
      if (this_present_tableNameOrRegionName || that_present_tableNameOrRegionName) {
        if (!(this_present_tableNameOrRegionName && that_present_tableNameOrRegionName))
          return false;
        if (!this.tableNameOrRegionName.equals(that.tableNameOrRegionName))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(compact_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      compact_args typedOther = (compact_args)other;

      lastComparison = Boolean.valueOf(isSetTableNameOrRegionName()).compareTo(typedOther.isSetTableNameOrRegionName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTableNameOrRegionName()) {
        lastComparison = TBaseHelper.compareTo(this.tableNameOrRegionName, typedOther.tableNameOrRegionName);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 1: // TABLE_NAME_OR_REGION_NAME
            if (field.type == TType.STRING) {
              this.tableNameOrRegionName = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tableNameOrRegionName != null) {
        oprot.writeFieldBegin(TABLE_NAME_OR_REGION_NAME_FIELD_DESC);
        oprot.writeBinary(this.tableNameOrRegionName);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("compact_args(");
      boolean first = true;

      sb.append("tableNameOrRegionName:");
      if (this.tableNameOrRegionName == null) {
        sb.append("null");
      } else {
        sb.append(this.tableNameOrRegionName);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class compact_result implements TBase<compact_result, compact_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("compact_result");

    private static final TField IO_FIELD_DESC = new TField("io", TType.STRUCT, (short)1);

    public IOError io;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      IO((short)1, "io");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // IO
            return IO;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.IO, new FieldMetaData("io", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(compact_result.class, metaDataMap);
    }

    public compact_result() {
    }

    public compact_result(
      IOError io)
    {
      this();
      this.io = io;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public compact_result(compact_result other) {
      if (other.isSetIo()) {
        this.io = new IOError(other.io);
      }
    }

    public compact_result deepCopy() {
      return new compact_result(this);
    }

    @Override
    public void clear() {
      this.io = null;
    }

    public IOError getIo() {
      return this.io;
    }

    public compact_result setIo(IOError io) {
      this.io = io;
      return this;
    }

    public void unsetIo() {
      this.io = null;
    }

    /** Returns true if field io is set (has been asigned a value) and false otherwise */
    public boolean isSetIo() {
      return this.io != null;
    }

    public void setIoIsSet(boolean value) {
      if (!value) {
        this.io = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case IO:
        if (value == null) {
          unsetIo();
        } else {
          setIo((IOError)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case IO:
        return getIo();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case IO:
        return isSetIo();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof compact_result)
        return this.equals((compact_result)that);
      return false;
    }

    public boolean equals(compact_result that) {
      if (that == null)
        return false;

      boolean this_present_io = true && this.isSetIo();
      boolean that_present_io = true && that.isSetIo();
      if (this_present_io || that_present_io) {
        if (!(this_present_io && that_present_io))
          return false;
        if (!this.io.equals(that.io))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(compact_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      compact_result typedOther = (compact_result)other;

      lastComparison = Boolean.valueOf(isSetIo()).compareTo(typedOther.isSetIo());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetIo()) {
        lastComparison = TBaseHelper.compareTo(this.io, typedOther.io);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 1: // IO
            if (field.type == TType.STRUCT) {
              this.io = new IOError();
              this.io.read(iprot);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetIo()) {
        oprot.writeFieldBegin(IO_FIELD_DESC);
        this.io.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("compact_result(");
      boolean first = true;

      sb.append("io:");
      if (this.io == null) {
        sb.append("null");
      } else {
        sb.append(this.io);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class majorCompact_args implements TBase<majorCompact_args, majorCompact_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("majorCompact_args");

    private static final TField TABLE_NAME_OR_REGION_NAME_FIELD_DESC = new TField("tableNameOrRegionName", TType.STRING, (short)1);

    public ByteBuffer tableNameOrRegionName;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      TABLE_NAME_OR_REGION_NAME((short)1, "tableNameOrRegionName");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // TABLE_NAME_OR_REGION_NAME
            return TABLE_NAME_OR_REGION_NAME;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.TABLE_NAME_OR_REGION_NAME, new FieldMetaData("tableNameOrRegionName", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Bytes")));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(majorCompact_args.class, metaDataMap);
    }

    public majorCompact_args() {
    }

    public majorCompact_args(
      ByteBuffer tableNameOrRegionName)
    {
      this();
      this.tableNameOrRegionName = tableNameOrRegionName;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public majorCompact_args(majorCompact_args other) {
      if (other.isSetTableNameOrRegionName()) {
        this.tableNameOrRegionName = other.tableNameOrRegionName;
      }
    }

    public majorCompact_args deepCopy() {
      return new majorCompact_args(this);
    }

    @Override
    public void clear() {
      this.tableNameOrRegionName = null;
    }

    public byte[] getTableNameOrRegionName() {
      setTableNameOrRegionName(TBaseHelper.rightSize(tableNameOrRegionName));
      return tableNameOrRegionName.array();
    }

    public ByteBuffer BufferForTableNameOrRegionName() {
      return tableNameOrRegionName;
    }

    public majorCompact_args setTableNameOrRegionName(byte[] tableNameOrRegionName) {
      setTableNameOrRegionName(ByteBuffer.wrap(tableNameOrRegionName));
      return this;
    }

    public majorCompact_args setTableNameOrRegionName(ByteBuffer tableNameOrRegionName) {
      this.tableNameOrRegionName = tableNameOrRegionName;
      return this;
    }

    public void unsetTableNameOrRegionName() {
      this.tableNameOrRegionName = null;
    }

    /** Returns true if field tableNameOrRegionName is set (has been asigned a value) and false otherwise */
    public boolean isSetTableNameOrRegionName() {
      return this.tableNameOrRegionName != null;
    }

    public void setTableNameOrRegionNameIsSet(boolean value) {
      if (!value) {
        this.tableNameOrRegionName = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TABLE_NAME_OR_REGION_NAME:
        if (value == null) {
          unsetTableNameOrRegionName();
        } else {
          setTableNameOrRegionName((ByteBuffer)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TABLE_NAME_OR_REGION_NAME:
        return getTableNameOrRegionName();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case TABLE_NAME_OR_REGION_NAME:
        return isSetTableNameOrRegionName();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof majorCompact_args)
        return this.equals((majorCompact_args)that);
      return false;
    }

    public boolean equals(majorCompact_args that) {
      if (that == null)
        return false;

      boolean this_present_tableNameOrRegionName = true && this.isSetTableNameOrRegionName();
      boolean that_present_tableNameOrRegionName = true && that.isSetTableNameOrRegionName();
      if (this_present_tableNameOrRegionName || that_present_tableNameOrRegionName) {
        if (!(this_present_tableNameOrRegionName && that_present_tableNameOrRegionName))
          return false;
        if (!this.tableNameOrRegionName.equals(that.tableNameOrRegionName))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(majorCompact_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      majorCompact_args typedOther = (majorCompact_args)other;

      lastComparison = Boolean.valueOf(isSetTableNameOrRegionName()).compareTo(typedOther.isSetTableNameOrRegionName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTableNameOrRegionName()) {
        lastComparison = TBaseHelper.compareTo(this.tableNameOrRegionName, typedOther.tableNameOrRegionName);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 1: // TABLE_NAME_OR_REGION_NAME
            if (field.type == TType.STRING) {
              this.tableNameOrRegionName = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tableNameOrRegionName != null) {
        oprot.writeFieldBegin(TABLE_NAME_OR_REGION_NAME_FIELD_DESC);
        oprot.writeBinary(this.tableNameOrRegionName);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("majorCompact_args(");
      boolean first = true;

      sb.append("tableNameOrRegionName:");
      if (this.tableNameOrRegionName == null) {
        sb.append("null");
      } else {
        sb.append(this.tableNameOrRegionName);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class majorCompact_result implements TBase<majorCompact_result, majorCompact_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("majorCompact_result");

    private static final TField IO_FIELD_DESC = new TField("io", TType.STRUCT, (short)1);

    public IOError io;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      IO((short)1, "io");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // IO
            return IO;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.IO, new FieldMetaData("io", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(majorCompact_result.class, metaDataMap);
    }

    public majorCompact_result() {
    }

    public majorCompact_result(
      IOError io)
    {
      this();
      this.io = io;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public majorCompact_result(majorCompact_result other) {
      if (other.isSetIo()) {
        this.io = new IOError(other.io);
      }
    }

    public majorCompact_result deepCopy() {
      return new majorCompact_result(this);
    }

    @Override
    public void clear() {
      this.io = null;
    }

    public IOError getIo() {
      return this.io;
    }

    public majorCompact_result setIo(IOError io) {
      this.io = io;
      return this;
    }

    public void unsetIo() {
      this.io = null;
    }

    /** Returns true if field io is set (has been asigned a value) and false otherwise */
    public boolean isSetIo() {
      return this.io != null;
    }

    public void setIoIsSet(boolean value) {
      if (!value) {
        this.io = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case IO:
        if (value == null) {
          unsetIo();
        } else {
          setIo((IOError)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case IO:
        return getIo();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case IO:
        return isSetIo();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof majorCompact_result)
        return this.equals((majorCompact_result)that);
      return false;
    }

    public boolean equals(majorCompact_result that) {
      if (that == null)
        return false;

      boolean this_present_io = true && this.isSetIo();
      boolean that_present_io = true && that.isSetIo();
      if (this_present_io || that_present_io) {
        if (!(this_present_io && that_present_io))
          return false;
        if (!this.io.equals(that.io))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(majorCompact_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      majorCompact_result typedOther = (majorCompact_result)other;

      lastComparison = Boolean.valueOf(isSetIo()).compareTo(typedOther.isSetIo());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetIo()) {
        lastComparison = TBaseHelper.compareTo(this.io, typedOther.io);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 1: // IO
            if (field.type == TType.STRUCT) {
              this.io = new IOError();
              this.io.read(iprot);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetIo()) {
        oprot.writeFieldBegin(IO_FIELD_DESC);
        this.io.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("majorCompact_result(");
      boolean first = true;

      sb.append("io:");
      if (this.io == null) {
        sb.append("null");
      } else {
        sb.append(this.io);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getTableNames_args implements TBase<getTableNames_args, getTableNames_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getTableNames_args");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getTableNames_args.class, metaDataMap);
    }

    public getTableNames_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getTableNames_args(getTableNames_args other) {
    }

    public getTableNames_args deepCopy() {
      return new getTableNames_args(this);
    }

    @Override
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getTableNames_args)
        return this.equals((getTableNames_args)that);
      return false;
    }

    public boolean equals(getTableNames_args that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getTableNames_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getTableNames_args typedOther = (getTableNames_args)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getTableNames_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getTableNames_result implements TBase<getTableNames_result, getTableNames_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getTableNames_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField IO_FIELD_DESC = new TField("io", TType.STRUCT, (short)1);

    public List<ByteBuffer> success;
    public IOError io;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      IO((short)1, "io");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // IO
            return IO;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT,
          new ListMetaData(TType.LIST,
              new FieldValueMetaData(TType.STRING              , "Text"))));
      tmpMap.put(_Fields.IO, new FieldMetaData("io", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getTableNames_result.class, metaDataMap);
    }

    public getTableNames_result() {
    }

    public getTableNames_result(
      List<ByteBuffer> success,
      IOError io)
    {
      this();
      this.success = success;
      this.io = io;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getTableNames_result(getTableNames_result other) {
      if (other.isSetSuccess()) {
        List<ByteBuffer> __this__success = new ArrayList<ByteBuffer>();
        for (ByteBuffer other_element : other.success) {
          __this__success.add(other_element);
        }
        this.success = __this__success;
      }
      if (other.isSetIo()) {
        this.io = new IOError(other.io);
      }
    }

    public getTableNames_result deepCopy() {
      return new getTableNames_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.io = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<ByteBuffer> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(ByteBuffer elem) {
      if (this.success == null) {
        this.success = new ArrayList<ByteBuffer>();
      }
      this.success.add(elem);
    }

    public List<ByteBuffer> getSuccess() {
      return this.success;
    }

    public getTableNames_result setSuccess(List<ByteBuffer> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public IOError getIo() {
      return this.io;
    }

    public getTableNames_result setIo(IOError io) {
      this.io = io;
      return this;
    }

    public void unsetIo() {
      this.io = null;
    }

    /** Returns true if field io is set (has been asigned a value) and false otherwise */
    public boolean isSetIo() {
      return this.io != null;
    }

    public void setIoIsSet(boolean value) {
      if (!value) {
        this.io = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<ByteBuffer>)value);
        }
        break;

      case IO:
        if (value == null) {
          unsetIo();
        } else {
          setIo((IOError)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case IO:
        return getIo();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case IO:
        return isSetIo();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getTableNames_result)
        return this.equals((getTableNames_result)that);
      return false;
    }

    public boolean equals(getTableNames_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_io = true && this.isSetIo();
      boolean that_present_io = true && that.isSetIo();
      if (this_present_io || that_present_io) {
        if (!(this_present_io && that_present_io))
          return false;
        if (!this.io.equals(that.io))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getTableNames_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getTableNames_result typedOther = (getTableNames_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetIo()).compareTo(typedOther.isSetIo());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetIo()) {
        lastComparison = TBaseHelper.compareTo(this.io, typedOther.io);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list9 = iprot.readListBegin();
                this.success = new ArrayList<ByteBuffer>(_list9.size);
                for (int _i10 = 0; _i10 < _list9.size; ++_i10)
                {
                  ByteBuffer _elem11;
                  _elem11 = iprot.readBinary();
                  this.success.add(_elem11);
                }
                iprot.readListEnd();
              }
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // IO
            if (field.type == TType.STRUCT) {
              this.io = new IOError();
              this.io.read(iprot);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.success.size()));
          for (ByteBuffer _iter12 : this.success)
          {
            oprot.writeBinary(_iter12);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetIo()) {
        oprot.writeFieldBegin(IO_FIELD_DESC);
        this.io.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getTableNames_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("io:");
      if (this.io == null) {
        sb.append("null");
      } else {
        sb.append(this.io);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getColumnDescriptors_args implements TBase<getColumnDescriptors_args, getColumnDescriptors_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getColumnDescriptors_args");

    private static final TField TABLE_NAME_FIELD_DESC = new TField("tableName", TType.STRING, (short)1);

    /**
     * table name
     */
    public ByteBuffer tableName;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      /**
       * table name
       */
      TABLE_NAME((short)1, "tableName");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // TABLE_NAME
            return TABLE_NAME;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.TABLE_NAME, new FieldMetaData("tableName", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Text")));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getColumnDescriptors_args.class, metaDataMap);
    }

    public getColumnDescriptors_args() {
    }

    public getColumnDescriptors_args(
      ByteBuffer tableName)
    {
      this();
      this.tableName = tableName;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getColumnDescriptors_args(getColumnDescriptors_args other) {
      if (other.isSetTableName()) {
        this.tableName = other.tableName;
      }
    }

    public getColumnDescriptors_args deepCopy() {
      return new getColumnDescriptors_args(this);
    }

    @Override
    public void clear() {
      this.tableName = null;
    }

    /**
     * table name
     */
    public byte[] getTableName() {
      setTableName(TBaseHelper.rightSize(tableName));
      return tableName.array();
    }

    public ByteBuffer BufferForTableName() {
      return tableName;
    }

    /**
     * table name
     */
    public getColumnDescriptors_args setTableName(byte[] tableName) {
      setTableName(ByteBuffer.wrap(tableName));
      return this;
    }

    public getColumnDescriptors_args setTableName(ByteBuffer tableName) {
      this.tableName = tableName;
      return this;
    }

    public void unsetTableName() {
      this.tableName = null;
    }

    /** Returns true if field tableName is set (has been asigned a value) and false otherwise */
    public boolean isSetTableName() {
      return this.tableName != null;
    }

    public void setTableNameIsSet(boolean value) {
      if (!value) {
        this.tableName = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TABLE_NAME:
        if (value == null) {
          unsetTableName();
        } else {
          setTableName((ByteBuffer)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return getTableName();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case TABLE_NAME:
        return isSetTableName();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getColumnDescriptors_args)
        return this.equals((getColumnDescriptors_args)that);
      return false;
    }

    public boolean equals(getColumnDescriptors_args that) {
      if (that == null)
        return false;

      boolean this_present_tableName = true && this.isSetTableName();
      boolean that_present_tableName = true && that.isSetTableName();
      if (this_present_tableName || that_present_tableName) {
        if (!(this_present_tableName && that_present_tableName))
          return false;
        if (!this.tableName.equals(that.tableName))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getColumnDescriptors_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getColumnDescriptors_args typedOther = (getColumnDescriptors_args)other;

      lastComparison = Boolean.valueOf(isSetTableName()).compareTo(typedOther.isSetTableName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTableName()) {
        lastComparison = TBaseHelper.compareTo(this.tableName, typedOther.tableName);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 1: // TABLE_NAME
            if (field.type == TType.STRING) {
              this.tableName = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tableName != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeBinary(this.tableName);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getColumnDescriptors_args(");
      boolean first = true;

      sb.append("tableName:");
      if (this.tableName == null) {
        sb.append("null");
      } else {
        sb.append(this.tableName);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getColumnDescriptors_result implements TBase<getColumnDescriptors_result, getColumnDescriptors_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getColumnDescriptors_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.MAP, (short)0);
    private static final TField IO_FIELD_DESC = new TField("io", TType.STRUCT, (short)1);

    public Map<ByteBuffer,ColumnDescriptor> success;
    public IOError io;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      IO((short)1, "io");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // IO
            return IO;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT,
          new MapMetaData(TType.MAP,
              new FieldValueMetaData(TType.STRING              , "Text"),
              new StructMetaData(TType.STRUCT, ColumnDescriptor.class))));
      tmpMap.put(_Fields.IO, new FieldMetaData("io", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getColumnDescriptors_result.class, metaDataMap);
    }

    public getColumnDescriptors_result() {
    }

    public getColumnDescriptors_result(
      Map<ByteBuffer,ColumnDescriptor> success,
      IOError io)
    {
      this();
      this.success = success;
      this.io = io;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getColumnDescriptors_result(getColumnDescriptors_result other) {
      if (other.isSetSuccess()) {
        Map<ByteBuffer,ColumnDescriptor> __this__success = new HashMap<ByteBuffer,ColumnDescriptor>();
        for (Map.Entry<ByteBuffer, ColumnDescriptor> other_element : other.success.entrySet()) {

          ByteBuffer other_element_key = other_element.getKey();
          ColumnDescriptor other_element_value = other_element.getValue();

          ByteBuffer __this__success_copy_key = other_element_key;

          ColumnDescriptor __this__success_copy_value = new ColumnDescriptor(other_element_value);

          __this__success.put(__this__success_copy_key, __this__success_copy_value);
        }
        this.success = __this__success;
      }
      if (other.isSetIo()) {
        this.io = new IOError(other.io);
      }
    }

    public getColumnDescriptors_result deepCopy() {
      return new getColumnDescriptors_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.io = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public void putToSuccess(ByteBuffer key, ColumnDescriptor val) {
      if (this.success == null) {
        this.success = new HashMap<ByteBuffer,ColumnDescriptor>();
      }
      this.success.put(key, val);
    }

    public Map<ByteBuffer,ColumnDescriptor> getSuccess() {
      return this.success;
    }

    public getColumnDescriptors_result setSuccess(Map<ByteBuffer,ColumnDescriptor> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public IOError getIo() {
      return this.io;
    }

    public getColumnDescriptors_result setIo(IOError io) {
      this.io = io;
      return this;
    }

    public void unsetIo() {
      this.io = null;
    }

    /** Returns true if field io is set (has been asigned a value) and false otherwise */
    public boolean isSetIo() {
      return this.io != null;
    }

    public void setIoIsSet(boolean value) {
      if (!value) {
        this.io = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Map<ByteBuffer,ColumnDescriptor>)value);
        }
        break;

      case IO:
        if (value == null) {
          unsetIo();
        } else {
          setIo((IOError)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case IO:
        return getIo();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case IO:
        return isSetIo();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getColumnDescriptors_result)
        return this.equals((getColumnDescriptors_result)that);
      return false;
    }

    public boolean equals(getColumnDescriptors_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_io = true && this.isSetIo();
      boolean that_present_io = true && that.isSetIo();
      if (this_present_io || that_present_io) {
        if (!(this_present_io && that_present_io))
          return false;
        if (!this.io.equals(that.io))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getColumnDescriptors_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getColumnDescriptors_result typedOther = (getColumnDescriptors_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetIo()).compareTo(typedOther.isSetIo());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetIo()) {
        lastComparison = TBaseHelper.compareTo(this.io, typedOther.io);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.MAP) {
              {
                TMap _map13 = iprot.readMapBegin();
                this.success = new HashMap<ByteBuffer,ColumnDescriptor>(2*_map13.size);
                for (int _i14 = 0; _i14 < _map13.size; ++_i14)
                {
                  ByteBuffer _key15;
                  ColumnDescriptor _val16;
                  _key15 = iprot.readBinary();
                  _val16 = new ColumnDescriptor();
                  _val16.read(iprot);
                  this.success.put(_key15, _val16);
                }
                iprot.readMapEnd();
              }
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // IO
            if (field.type == TType.STRUCT) {
              this.io = new IOError();
              this.io.read(iprot);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeMapBegin(new TMap(TType.STRING, TType.STRUCT, this.success.size()));
          for (Map.Entry<ByteBuffer, ColumnDescriptor> _iter17 : this.success.entrySet())
          {
            oprot.writeBinary(_iter17.getKey());
            _iter17.getValue().write(oprot);
          }
          oprot.writeMapEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetIo()) {
        oprot.writeFieldBegin(IO_FIELD_DESC);
        this.io.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getColumnDescriptors_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("io:");
      if (this.io == null) {
        sb.append("null");
      } else {
        sb.append(this.io);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getTableRegions_args implements TBase<getTableRegions_args, getTableRegions_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getTableRegions_args");

    private static final TField TABLE_NAME_FIELD_DESC = new TField("tableName", TType.STRING, (short)1);

    /**
     * table name
     */
    public ByteBuffer tableName;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      /**
       * table name
       */
      TABLE_NAME((short)1, "tableName");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // TABLE_NAME
            return TABLE_NAME;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.TABLE_NAME, new FieldMetaData("tableName", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Text")));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getTableRegions_args.class, metaDataMap);
    }

    public getTableRegions_args() {
    }

    public getTableRegions_args(
      ByteBuffer tableName)
    {
      this();
      this.tableName = tableName;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getTableRegions_args(getTableRegions_args other) {
      if (other.isSetTableName()) {
        this.tableName = other.tableName;
      }
    }

    public getTableRegions_args deepCopy() {
      return new getTableRegions_args(this);
    }

    @Override
    public void clear() {
      this.tableName = null;
    }

    /**
     * table name
     */
    public byte[] getTableName() {
      setTableName(TBaseHelper.rightSize(tableName));
      return tableName.array();
    }

    public ByteBuffer BufferForTableName() {
      return tableName;
    }

    /**
     * table name
     */
    public getTableRegions_args setTableName(byte[] tableName) {
      setTableName(ByteBuffer.wrap(tableName));
      return this;
    }

    public getTableRegions_args setTableName(ByteBuffer tableName) {
      this.tableName = tableName;
      return this;
    }

    public void unsetTableName() {
      this.tableName = null;
    }

    /** Returns true if field tableName is set (has been asigned a value) and false otherwise */
    public boolean isSetTableName() {
      return this.tableName != null;
    }

    public void setTableNameIsSet(boolean value) {
      if (!value) {
        this.tableName = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TABLE_NAME:
        if (value == null) {
          unsetTableName();
        } else {
          setTableName((ByteBuffer)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return getTableName();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case TABLE_NAME:
        return isSetTableName();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getTableRegions_args)
        return this.equals((getTableRegions_args)that);
      return false;
    }

    public boolean equals(getTableRegions_args that) {
      if (that == null)
        return false;

      boolean this_present_tableName = true && this.isSetTableName();
      boolean that_present_tableName = true && that.isSetTableName();
      if (this_present_tableName || that_present_tableName) {
        if (!(this_present_tableName && that_present_tableName))
          return false;
        if (!this.tableName.equals(that.tableName))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getTableRegions_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getTableRegions_args typedOther = (getTableRegions_args)other;

      lastComparison = Boolean.valueOf(isSetTableName()).compareTo(typedOther.isSetTableName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTableName()) {
        lastComparison = TBaseHelper.compareTo(this.tableName, typedOther.tableName);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 1: // TABLE_NAME
            if (field.type == TType.STRING) {
              this.tableName = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tableName != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeBinary(this.tableName);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getTableRegions_args(");
      boolean first = true;

      sb.append("tableName:");
      if (this.tableName == null) {
        sb.append("null");
      } else {
        sb.append(this.tableName);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getTableRegions_result implements TBase<getTableRegions_result, getTableRegions_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getTableRegions_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField IO_FIELD_DESC = new TField("io", TType.STRUCT, (short)1);

    public List<TRegionInfo> success;
    public IOError io;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      IO((short)1, "io");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // IO
            return IO;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT,
          new ListMetaData(TType.LIST,
              new StructMetaData(TType.STRUCT, TRegionInfo.class))));
      tmpMap.put(_Fields.IO, new FieldMetaData("io", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getTableRegions_result.class, metaDataMap);
    }

    public getTableRegions_result() {
    }

    public getTableRegions_result(
      List<TRegionInfo> success,
      IOError io)
    {
      this();
      this.success = success;
      this.io = io;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getTableRegions_result(getTableRegions_result other) {
      if (other.isSetSuccess()) {
        List<TRegionInfo> __this__success = new ArrayList<TRegionInfo>();
        for (TRegionInfo other_element : other.success) {
          __this__success.add(new TRegionInfo(other_element));
        }
        this.success = __this__success;
      }
      if (other.isSetIo()) {
        this.io = new IOError(other.io);
      }
    }

    public getTableRegions_result deepCopy() {
      return new getTableRegions_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.io = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<TRegionInfo> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(TRegionInfo elem) {
      if (this.success == null) {
        this.success = new ArrayList<TRegionInfo>();
      }
      this.success.add(elem);
    }

    public List<TRegionInfo> getSuccess() {
      return this.success;
    }

    public getTableRegions_result setSuccess(List<TRegionInfo> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public IOError getIo() {
      return this.io;
    }

    public getTableRegions_result setIo(IOError io) {
      this.io = io;
      return this;
    }

    public void unsetIo() {
      this.io = null;
    }

    /** Returns true if field io is set (has been asigned a value) and false otherwise */
    public boolean isSetIo() {
      return this.io != null;
    }

    public void setIoIsSet(boolean value) {
      if (!value) {
        this.io = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<TRegionInfo>)value);
        }
        break;

      case IO:
        if (value == null) {
          unsetIo();
        } else {
          setIo((IOError)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case IO:
        return getIo();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case IO:
        return isSetIo();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getTableRegions_result)
        return this.equals((getTableRegions_result)that);
      return false;
    }

    public boolean equals(getTableRegions_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_io = true && this.isSetIo();
      boolean that_present_io = true && that.isSetIo();
      if (this_present_io || that_present_io) {
        if (!(this_present_io && that_present_io))
          return false;
        if (!this.io.equals(that.io))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getTableRegions_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getTableRegions_result typedOther = (getTableRegions_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetIo()).compareTo(typedOther.isSetIo());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetIo()) {
        lastComparison = TBaseHelper.compareTo(this.io, typedOther.io);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list18 = iprot.readListBegin();
                this.success = new ArrayList<TRegionInfo>(_list18.size);
                for (int _i19 = 0; _i19 < _list18.size; ++_i19)
                {
                  TRegionInfo _elem20;
                  _elem20 = new TRegionInfo();
                  _elem20.read(iprot);
                  this.success.add(_elem20);
                }
                iprot.readListEnd();
              }
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // IO
            if (field.type == TType.STRUCT) {
              this.io = new IOError();
              this.io.read(iprot);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (TRegionInfo _iter21 : this.success)
          {
            _iter21.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetIo()) {
        oprot.writeFieldBegin(IO_FIELD_DESC);
        this.io.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getTableRegions_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("io:");
      if (this.io == null) {
        sb.append("null");
      } else {
        sb.append(this.io);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class createTable_args implements TBase<createTable_args, createTable_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("createTable_args");

    private static final TField TABLE_NAME_FIELD_DESC = new TField("tableName", TType.STRING, (short)1);
    private static final TField COLUMN_FAMILIES_FIELD_DESC = new TField("columnFamilies", TType.LIST, (short)2);

    /**
     * name of table to create
     */
    public ByteBuffer tableName;
    /**
     * list of column family descriptors
     */
    public List<ColumnDescriptor> columnFamilies;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      /**
       * name of table to create
       */
      TABLE_NAME((short)1, "tableName"),
      /**
       * list of column family descriptors
       */
      COLUMN_FAMILIES((short)2, "columnFamilies");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // TABLE_NAME
            return TABLE_NAME;
          case 2: // COLUMN_FAMILIES
            return COLUMN_FAMILIES;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.TABLE_NAME, new FieldMetaData("tableName", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Text")));
      tmpMap.put(_Fields.COLUMN_FAMILIES, new FieldMetaData("columnFamilies", TFieldRequirementType.DEFAULT,
          new ListMetaData(TType.LIST,
              new StructMetaData(TType.STRUCT, ColumnDescriptor.class))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(createTable_args.class, metaDataMap);
    }

    public createTable_args() {
    }

    public createTable_args(
      ByteBuffer tableName,
      List<ColumnDescriptor> columnFamilies)
    {
      this();
      this.tableName = tableName;
      this.columnFamilies = columnFamilies;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createTable_args(createTable_args other) {
      if (other.isSetTableName()) {
        this.tableName = other.tableName;
      }
      if (other.isSetColumnFamilies()) {
        List<ColumnDescriptor> __this__columnFamilies = new ArrayList<ColumnDescriptor>();
        for (ColumnDescriptor other_element : other.columnFamilies) {
          __this__columnFamilies.add(new ColumnDescriptor(other_element));
        }
        this.columnFamilies = __this__columnFamilies;
      }
    }

    public createTable_args deepCopy() {
      return new createTable_args(this);
    }

    @Override
    public void clear() {
      this.tableName = null;
      this.columnFamilies = null;
    }

    /**
     * name of table to create
     */
    public byte[] getTableName() {
      setTableName(TBaseHelper.rightSize(tableName));
      return tableName.array();
    }

    public ByteBuffer BufferForTableName() {
      return tableName;
    }

    /**
     * name of table to create
     */
    public createTable_args setTableName(byte[] tableName) {
      setTableName(ByteBuffer.wrap(tableName));
      return this;
    }

    public createTable_args setTableName(ByteBuffer tableName) {
      this.tableName = tableName;
      return this;
    }

    public void unsetTableName() {
      this.tableName = null;
    }

    /** Returns true if field tableName is set (has been asigned a value) and false otherwise */
    public boolean isSetTableName() {
      return this.tableName != null;
    }

    public void setTableNameIsSet(boolean value) {
      if (!value) {
        this.tableName = null;
      }
    }

    public int getColumnFamiliesSize() {
      return (this.columnFamilies == null) ? 0 : this.columnFamilies.size();
    }

    public java.util.Iterator<ColumnDescriptor> getColumnFamiliesIterator() {
      return (this.columnFamilies == null) ? null : this.columnFamilies.iterator();
    }

    public void addToColumnFamilies(ColumnDescriptor elem) {
      if (this.columnFamilies == null) {
        this.columnFamilies = new ArrayList<ColumnDescriptor>();
      }
      this.columnFamilies.add(elem);
    }

    /**
     * list of column family descriptors
     */
    public List<ColumnDescriptor> getColumnFamilies() {
      return this.columnFamilies;
    }

    /**
     * list of column family descriptors
     */
    public createTable_args setColumnFamilies(List<ColumnDescriptor> columnFamilies) {
      this.columnFamilies = columnFamilies;
      return this;
    }

    public void unsetColumnFamilies() {
      this.columnFamilies = null;
    }

    /** Returns true if field columnFamilies is set (has been asigned a value) and false otherwise */
    public boolean isSetColumnFamilies() {
      return this.columnFamilies != null;
    }

    public void setColumnFamiliesIsSet(boolean value) {
      if (!value) {
        this.columnFamilies = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TABLE_NAME:
        if (value == null) {
          unsetTableName();
        } else {
          setTableName((ByteBuffer)value);
        }
        break;

      case COLUMN_FAMILIES:
        if (value == null) {
          unsetColumnFamilies();
        } else {
          setColumnFamilies((List<ColumnDescriptor>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return getTableName();

      case COLUMN_FAMILIES:
        return getColumnFamilies();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case TABLE_NAME:
        return isSetTableName();
      case COLUMN_FAMILIES:
        return isSetColumnFamilies();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof createTable_args)
        return this.equals((createTable_args)that);
      return false;
    }

    public boolean equals(createTable_args that) {
      if (that == null)
        return false;

      boolean this_present_tableName = true && this.isSetTableName();
      boolean that_present_tableName = true && that.isSetTableName();
      if (this_present_tableName || that_present_tableName) {
        if (!(this_present_tableName && that_present_tableName))
          return false;
        if (!this.tableName.equals(that.tableName))
          return false;
      }

      boolean this_present_columnFamilies = true && this.isSetColumnFamilies();
      boolean that_present_columnFamilies = true && that.isSetColumnFamilies();
      if (this_present_columnFamilies || that_present_columnFamilies) {
        if (!(this_present_columnFamilies && that_present_columnFamilies))
          return false;
        if (!this.columnFamilies.equals(that.columnFamilies))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(createTable_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      createTable_args typedOther = (createTable_args)other;

      lastComparison = Boolean.valueOf(isSetTableName()).compareTo(typedOther.isSetTableName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTableName()) {
        lastComparison = TBaseHelper.compareTo(this.tableName, typedOther.tableName);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetColumnFamilies()).compareTo(typedOther.isSetColumnFamilies());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetColumnFamilies()) {
        lastComparison = TBaseHelper.compareTo(this.columnFamilies, typedOther.columnFamilies);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 1: // TABLE_NAME
            if (field.type == TType.STRING) {
              this.tableName = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // COLUMN_FAMILIES
            if (field.type == TType.LIST) {
              {
                TList _list22 = iprot.readListBegin();
                this.columnFamilies = new ArrayList<ColumnDescriptor>(_list22.size);
                for (int _i23 = 0; _i23 < _list22.size; ++_i23)
                {
                  ColumnDescriptor _elem24;
                  _elem24 = new ColumnDescriptor();
                  _elem24.read(iprot);
                  this.columnFamilies.add(_elem24);
                }
                iprot.readListEnd();
              }
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tableName != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeBinary(this.tableName);
        oprot.writeFieldEnd();
      }
      if (this.columnFamilies != null) {
        oprot.writeFieldBegin(COLUMN_FAMILIES_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.columnFamilies.size()));
          for (ColumnDescriptor _iter25 : this.columnFamilies)
          {
            _iter25.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("createTable_args(");
      boolean first = true;

      sb.append("tableName:");
      if (this.tableName == null) {
        sb.append("null");
      } else {
        sb.append(this.tableName);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("columnFamilies:");
      if (this.columnFamilies == null) {
        sb.append("null");
      } else {
        sb.append(this.columnFamilies);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class createTable_result implements TBase<createTable_result, createTable_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("createTable_result");

    private static final TField IO_FIELD_DESC = new TField("io", TType.STRUCT, (short)1);
    private static final TField IA_FIELD_DESC = new TField("ia", TType.STRUCT, (short)2);
    private static final TField EXIST_FIELD_DESC = new TField("exist", TType.STRUCT, (short)3);

    public IOError io;
    public IllegalArgument ia;
    public AlreadyExists exist;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      IO((short)1, "io"),
      IA((short)2, "ia"),
      EXIST((short)3, "exist");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // IO
            return IO;
          case 2: // IA
            return IA;
          case 3: // EXIST
            return EXIST;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.IO, new FieldMetaData("io", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRUCT)));
      tmpMap.put(_Fields.IA, new FieldMetaData("ia", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRUCT)));
      tmpMap.put(_Fields.EXIST, new FieldMetaData("exist", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(createTable_result.class, metaDataMap);
    }

    public createTable_result() {
    }

    public createTable_result(
      IOError io,
      IllegalArgument ia,
      AlreadyExists exist)
    {
      this();
      this.io = io;
      this.ia = ia;
      this.exist = exist;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createTable_result(createTable_result other) {
      if (other.isSetIo()) {
        this.io = new IOError(other.io);
      }
      if (other.isSetIa()) {
        this.ia = new IllegalArgument(other.ia);
      }
      if (other.isSetExist()) {
        this.exist = new AlreadyExists(other.exist);
      }
    }

    public createTable_result deepCopy() {
      return new createTable_result(this);
    }

    @Override
    public void clear() {
      this.io = null;
      this.ia = null;
      this.exist = null;
    }

    public IOError getIo() {
      return this.io;
    }

    public createTable_result setIo(IOError io) {
      this.io = io;
      return this;
    }

    public void unsetIo() {
      this.io = null;
    }

    /** Returns true if field io is set (has been asigned a value) and false otherwise */
    public boolean isSetIo() {
      return this.io != null;
    }

    public void setIoIsSet(boolean value) {
      if (!value) {
        this.io = null;
      }
    }

    public IllegalArgument getIa() {
      return this.ia;
    }

    public createTable_result setIa(IllegalArgument ia) {
      this.ia = ia;
      return this;
    }

    public void unsetIa() {
      this.ia = null;
    }

    /** Returns true if field ia is set (has been asigned a value) and false otherwise */
    public boolean isSetIa() {
      return this.ia != null;
    }

    public void setIaIsSet(boolean value) {
      if (!value) {
        this.ia = null;
      }
    }

    public AlreadyExists getExist() {
      return this.exist;
    }

    public createTable_result setExist(AlreadyExists exist) {
      this.exist = exist;
      return this;
    }

    public void unsetExist() {
      this.exist = null;
    }

    /** Returns true if field exist is set (has been asigned a value) and false otherwise */
    public boolean isSetExist() {
      return this.exist != null;
    }

    public void setExistIsSet(boolean value) {
      if (!value) {
        this.exist = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case IO:
        if (value == null) {
          unsetIo();
        } else {
          setIo((IOError)value);
        }
        break;

      case IA:
        if (value == null) {
          unsetIa();
        } else {
          setIa((IllegalArgument)value);
        }
        break;

      case EXIST:
        if (value == null) {
          unsetExist();
        } else {
          setExist((AlreadyExists)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case IO:
        return getIo();

      case IA:
        return getIa();

      case EXIST:
        return getExist();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case IO:
        return isSetIo();
      case IA:
        return isSetIa();
      case EXIST:
        return isSetExist();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof createTable_result)
        return this.equals((createTable_result)that);
      return false;
    }

    public boolean equals(createTable_result that) {
      if (that == null)
        return false;

      boolean this_present_io = true && this.isSetIo();
      boolean that_present_io = true && that.isSetIo();
      if (this_present_io || that_present_io) {
        if (!(this_present_io && that_present_io))
          return false;
        if (!this.io.equals(that.io))
          return false;
      }

      boolean this_present_ia = true && this.isSetIa();
      boolean that_present_ia = true && that.isSetIa();
      if (this_present_ia || that_present_ia) {
        if (!(this_present_ia && that_present_ia))
          return false;
        if (!this.ia.equals(that.ia))
          return false;
      }

      boolean this_present_exist = true && this.isSetExist();
      boolean that_present_exist = true && that.isSetExist();
      if (this_present_exist || that_present_exist) {
        if (!(this_present_exist && that_present_exist))
          return false;
        if (!this.exist.equals(that.exist))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(createTable_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      createTable_result typedOther = (createTable_result)other;

      lastComparison = Boolean.valueOf(isSetIo()).compareTo(typedOther.isSetIo());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetIo()) {
        lastComparison = TBaseHelper.compareTo(this.io, typedOther.io);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetIa()).compareTo(typedOther.isSetIa());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetIa()) {
        lastComparison = TBaseHelper.compareTo(this.ia, typedOther.ia);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetExist()).compareTo(typedOther.isSetExist());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetExist()) {
        lastComparison = TBaseHelper.compareTo(this.exist, typedOther.exist);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 1: // IO
            if (field.type == TType.STRUCT) {
              this.io = new IOError();
              this.io.read(iprot);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // IA
            if (field.type == TType.STRUCT) {
              this.ia = new IllegalArgument();
              this.ia.read(iprot);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // EXIST
            if (field.type == TType.STRUCT) {
              this.exist = new AlreadyExists();
              this.exist.read(iprot);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetIo()) {
        oprot.writeFieldBegin(IO_FIELD_DESC);
        this.io.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetIa()) {
        oprot.writeFieldBegin(IA_FIELD_DESC);
        this.ia.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetExist()) {
        oprot.writeFieldBegin(EXIST_FIELD_DESC);
        this.exist.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("createTable_result(");
      boolean first = true;

      sb.append("io:");
      if (this.io == null) {
        sb.append("null");
      } else {
        sb.append(this.io);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ia:");
      if (this.ia == null) {
        sb.append("null");
      } else {
        sb.append(this.ia);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("exist:");
      if (this.exist == null) {
        sb.append("null");
      } else {
        sb.append(this.exist);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class deleteTable_args implements TBase<deleteTable_args, deleteTable_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("deleteTable_args");

    private static final TField TABLE_NAME_FIELD_DESC = new TField("tableName", TType.STRING, (short)1);

    /**
     * name of table to delete
     */
    public ByteBuffer tableName;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      /**
       * name of table to delete
       */
      TABLE_NAME((short)1, "tableName");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // TABLE_NAME
            return TABLE_NAME;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.TABLE_NAME, new FieldMetaData("tableName", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Text")));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(deleteTable_args.class, metaDataMap);
    }

    public deleteTable_args() {
    }

    public deleteTable_args(
      ByteBuffer tableName)
    {
      this();
      this.tableName = tableName;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public deleteTable_args(deleteTable_args other) {
      if (other.isSetTableName()) {
        this.tableName = other.tableName;
      }
    }

    public deleteTable_args deepCopy() {
      return new deleteTable_args(this);
    }

    @Override
    public void clear() {
      this.tableName = null;
    }

    /**
     * name of table to delete
     */
    public byte[] getTableName() {
      setTableName(TBaseHelper.rightSize(tableName));
      return tableName.array();
    }

    public ByteBuffer BufferForTableName() {
      return tableName;
    }

    /**
     * name of table to delete
     */
    public deleteTable_args setTableName(byte[] tableName) {
      setTableName(ByteBuffer.wrap(tableName));
      return this;
    }

    public deleteTable_args setTableName(ByteBuffer tableName) {
      this.tableName = tableName;
      return this;
    }

    public void unsetTableName() {
      this.tableName = null;
    }

    /** Returns true if field tableName is set (has been asigned a value) and false otherwise */
    public boolean isSetTableName() {
      return this.tableName != null;
    }

    public void setTableNameIsSet(boolean value) {
      if (!value) {
        this.tableName = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TABLE_NAME:
        if (value == null) {
          unsetTableName();
        } else {
          setTableName((ByteBuffer)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return getTableName();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case TABLE_NAME:
        return isSetTableName();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof deleteTable_args)
        return this.equals((deleteTable_args)that);
      return false;
    }

    public boolean equals(deleteTable_args that) {
      if (that == null)
        return false;

      boolean this_present_tableName = true && this.isSetTableName();
      boolean that_present_tableName = true && that.isSetTableName();
      if (this_present_tableName || that_present_tableName) {
        if (!(this_present_tableName && that_present_tableName))
          return false;
        if (!this.tableName.equals(that.tableName))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(deleteTable_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      deleteTable_args typedOther = (deleteTable_args)other;

      lastComparison = Boolean.valueOf(isSetTableName()).compareTo(typedOther.isSetTableName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTableName()) {
        lastComparison = TBaseHelper.compareTo(this.tableName, typedOther.tableName);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 1: // TABLE_NAME
            if (field.type == TType.STRING) {
              this.tableName = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tableName != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeBinary(this.tableName);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("deleteTable_args(");
      boolean first = true;

      sb.append("tableName:");
      if (this.tableName == null) {
        sb.append("null");
      } else {
        sb.append(this.tableName);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class deleteTable_result implements TBase<deleteTable_result, deleteTable_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("deleteTable_result");

    private static final TField IO_FIELD_DESC = new TField("io", TType.STRUCT, (short)1);

    public IOError io;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      IO((short)1, "io");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // IO
            return IO;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.IO, new FieldMetaData("io", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(deleteTable_result.class, metaDataMap);
    }

    public deleteTable_result() {
    }

    public deleteTable_result(
      IOError io)
    {
      this();
      this.io = io;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public deleteTable_result(deleteTable_result other) {
      if (other.isSetIo()) {
        this.io = new IOError(other.io);
      }
    }

    public deleteTable_result deepCopy() {
      return new deleteTable_result(this);
    }

    @Override
    public void clear() {
      this.io = null;
    }

    public IOError getIo() {
      return this.io;
    }

    public deleteTable_result setIo(IOError io) {
      this.io = io;
      return this;
    }

    public void unsetIo() {
      this.io = null;
    }

    /** Returns true if field io is set (has been asigned a value) and false otherwise */
    public boolean isSetIo() {
      return this.io != null;
    }

    public void setIoIsSet(boolean value) {
      if (!value) {
        this.io = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case IO:
        if (value == null) {
          unsetIo();
        } else {
          setIo((IOError)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case IO:
        return getIo();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case IO:
        return isSetIo();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof deleteTable_result)
        return this.equals((deleteTable_result)that);
      return false;
    }

    public boolean equals(deleteTable_result that) {
      if (that == null)
        return false;

      boolean this_present_io = true && this.isSetIo();
      boolean that_present_io = true && that.isSetIo();
      if (this_present_io || that_present_io) {
        if (!(this_present_io && that_present_io))
          return false;
        if (!this.io.equals(that.io))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(deleteTable_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      deleteTable_result typedOther = (deleteTable_result)other;

      lastComparison = Boolean.valueOf(isSetIo()).compareTo(typedOther.isSetIo());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetIo()) {
        lastComparison = TBaseHelper.compareTo(this.io, typedOther.io);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 1: // IO
            if (field.type == TType.STRUCT) {
              this.io = new IOError();
              this.io.read(iprot);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetIo()) {
        oprot.writeFieldBegin(IO_FIELD_DESC);
        this.io.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("deleteTable_result(");
      boolean first = true;

      sb.append("io:");
      if (this.io == null) {
        sb.append("null");
      } else {
        sb.append(this.io);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_args implements TBase<get_args, get_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_args");

    private static final TField TABLE_NAME_FIELD_DESC = new TField("tableName", TType.STRING, (short)1);
    private static final TField ROW_FIELD_DESC = new TField("row", TType.STRING, (short)2);
    private static final TField COLUMN_FIELD_DESC = new TField("column", TType.STRING, (short)3);

    /**
     * name of table
     */
    public ByteBuffer tableName;
    /**
     * row key
     */
    public ByteBuffer row;
    /**
     * column name
     */
    public ByteBuffer column;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      /**
       * name of table
       */
      TABLE_NAME((short)1, "tableName"),
      /**
       * row key
       */
      ROW((short)2, "row"),
      /**
       * column name
       */
      COLUMN((short)3, "column");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // TABLE_NAME
            return TABLE_NAME;
          case 2: // ROW
            return ROW;
          case 3: // COLUMN
            return COLUMN;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.TABLE_NAME, new FieldMetaData("tableName", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Text")));
      tmpMap.put(_Fields.ROW, new FieldMetaData("row", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Text")));
      tmpMap.put(_Fields.COLUMN, new FieldMetaData("column", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Text")));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_args.class, metaDataMap);
    }

    public get_args() {
    }

    public get_args(
      ByteBuffer tableName,
      ByteBuffer row,
      ByteBuffer column)
    {
      this();
      this.tableName = tableName;
      this.row = row;
      this.column = column;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_args(get_args other) {
      if (other.isSetTableName()) {
        this.tableName = other.tableName;
      }
      if (other.isSetRow()) {
        this.row = other.row;
      }
      if (other.isSetColumn()) {
        this.column = other.column;
      }
    }

    public get_args deepCopy() {
      return new get_args(this);
    }

    @Override
    public void clear() {
      this.tableName = null;
      this.row = null;
      this.column = null;
    }

    /**
     * name of table
     */
    public byte[] getTableName() {
      setTableName(TBaseHelper.rightSize(tableName));
      return tableName.array();
    }

    public ByteBuffer BufferForTableName() {
      return tableName;
    }

    /**
     * name of table
     */
    public get_args setTableName(byte[] tableName) {
      setTableName(ByteBuffer.wrap(tableName));
      return this;
    }

    public get_args setTableName(ByteBuffer tableName) {
      this.tableName = tableName;
      return this;
    }

    public void unsetTableName() {
      this.tableName = null;
    }

    /** Returns true if field tableName is set (has been asigned a value) and false otherwise */
    public boolean isSetTableName() {
      return this.tableName != null;
    }

    public void setTableNameIsSet(boolean value) {
      if (!value) {
        this.tableName = null;
      }
    }

    /**
     * row key
     */
    public byte[] getRow() {
      setRow(TBaseHelper.rightSize(row));
      return row.array();
    }

    public ByteBuffer BufferForRow() {
      return row;
    }

    /**
     * row key
     */
    public get_args setRow(byte[] row) {
      setRow(ByteBuffer.wrap(row));
      return this;
    }

    public get_args setRow(ByteBuffer row) {
      this.row = row;
      return this;
    }

    public void unsetRow() {
      this.row = null;
    }

    /** Returns true if field row is set (has been asigned a value) and false otherwise */
    public boolean isSetRow() {
      return this.row != null;
    }

    public void setRowIsSet(boolean value) {
      if (!value) {
        this.row = null;
      }
    }

    /**
     * column name
     */
    public byte[] getColumn() {
      setColumn(TBaseHelper.rightSize(column));
      return column.array();
    }

    public ByteBuffer BufferForColumn() {
      return column;
    }

    /**
     * column name
     */
    public get_args setColumn(byte[] column) {
      setColumn(ByteBuffer.wrap(column));
      return this;
    }

    public get_args setColumn(ByteBuffer column) {
      this.column = column;
      return this;
    }

    public void unsetColumn() {
      this.column = null;
    }

    /** Returns true if field column is set (has been asigned a value) and false otherwise */
    public boolean isSetColumn() {
      return this.column != null;
    }

    public void setColumnIsSet(boolean value) {
      if (!value) {
        this.column = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TABLE_NAME:
        if (value == null) {
          unsetTableName();
        } else {
          setTableName((ByteBuffer)value);
        }
        break;

      case ROW:
        if (value == null) {
          unsetRow();
        } else {
          setRow((ByteBuffer)value);
        }
        break;

      case COLUMN:
        if (value == null) {
          unsetColumn();
        } else {
          setColumn((ByteBuffer)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return getTableName();

      case ROW:
        return getRow();

      case COLUMN:
        return getColumn();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case TABLE_NAME:
        return isSetTableName();
      case ROW:
        return isSetRow();
      case COLUMN:
        return isSetColumn();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_args)
        return this.equals((get_args)that);
      return false;
    }

    public boolean equals(get_args that) {
      if (that == null)
        return false;

      boolean this_present_tableName = true && this.isSetTableName();
      boolean that_present_tableName = true && that.isSetTableName();
      if (this_present_tableName || that_present_tableName) {
        if (!(this_present_tableName && that_present_tableName))
          return false;
        if (!this.tableName.equals(that.tableName))
          return false;
      }

      boolean this_present_row = true && this.isSetRow();
      boolean that_present_row = true && that.isSetRow();
      if (this_present_row || that_present_row) {
        if (!(this_present_row && that_present_row))
          return false;
        if (!this.row.equals(that.row))
          return false;
      }

      boolean this_present_column = true && this.isSetColumn();
      boolean that_present_column = true && that.isSetColumn();
      if (this_present_column || that_present_column) {
        if (!(this_present_column && that_present_column))
          return false;
        if (!this.column.equals(that.column))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_args typedOther = (get_args)other;

      lastComparison = Boolean.valueOf(isSetTableName()).compareTo(typedOther.isSetTableName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTableName()) {
        lastComparison = TBaseHelper.compareTo(this.tableName, typedOther.tableName);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetRow()).compareTo(typedOther.isSetRow());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetRow()) {
        lastComparison = TBaseHelper.compareTo(this.row, typedOther.row);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetColumn()).compareTo(typedOther.isSetColumn());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetColumn()) {
        lastComparison = TBaseHelper.compareTo(this.column, typedOther.column);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 1: // TABLE_NAME
            if (field.type == TType.STRING) {
              this.tableName = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // ROW
            if (field.type == TType.STRING) {
              this.row = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // COLUMN
            if (field.type == TType.STRING) {
              this.column = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tableName != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeBinary(this.tableName);
        oprot.writeFieldEnd();
      }
      if (this.row != null) {
        oprot.writeFieldBegin(ROW_FIELD_DESC);
        oprot.writeBinary(this.row);
        oprot.writeFieldEnd();
      }
      if (this.column != null) {
        oprot.writeFieldBegin(COLUMN_FIELD_DESC);
        oprot.writeBinary(this.column);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_args(");
      boolean first = true;

      sb.append("tableName:");
      if (this.tableName == null) {
        sb.append("null");
      } else {
        sb.append(this.tableName);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("row:");
      if (this.row == null) {
        sb.append("null");
      } else {
        sb.append(this.row);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("column:");
      if (this.column == null) {
        sb.append("null");
      } else {
        sb.append(this.column);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_result implements TBase<get_result, get_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField IO_FIELD_DESC = new TField("io", TType.STRUCT, (short)1);

    public List<TCell> success;
    public IOError io;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      IO((short)1, "io");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // IO
            return IO;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT,
          new ListMetaData(TType.LIST,
              new StructMetaData(TType.STRUCT, TCell.class))));
      tmpMap.put(_Fields.IO, new FieldMetaData("io", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_result.class, metaDataMap);
    }

    public get_result() {
    }

    public get_result(
      List<TCell> success,
      IOError io)
    {
      this();
      this.success = success;
      this.io = io;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_result(get_result other) {
      if (other.isSetSuccess()) {
        List<TCell> __this__success = new ArrayList<TCell>();
        for (TCell other_element : other.success) {
          __this__success.add(new TCell(other_element));
        }
        this.success = __this__success;
      }
      if (other.isSetIo()) {
        this.io = new IOError(other.io);
      }
    }

    public get_result deepCopy() {
      return new get_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.io = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<TCell> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(TCell elem) {
      if (this.success == null) {
        this.success = new ArrayList<TCell>();
      }
      this.success.add(elem);
    }

    public List<TCell> getSuccess() {
      return this.success;
    }

    public get_result setSuccess(List<TCell> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public IOError getIo() {
      return this.io;
    }

    public get_result setIo(IOError io) {
      this.io = io;
      return this;
    }

    public void unsetIo() {
      this.io = null;
    }

    /** Returns true if field io is set (has been asigned a value) and false otherwise */
    public boolean isSetIo() {
      return this.io != null;
    }

    public void setIoIsSet(boolean value) {
      if (!value) {
        this.io = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<TCell>)value);
        }
        break;

      case IO:
        if (value == null) {
          unsetIo();
        } else {
          setIo((IOError)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case IO:
        return getIo();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case IO:
        return isSetIo();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_result)
        return this.equals((get_result)that);
      return false;
    }

    public boolean equals(get_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_io = true && this.isSetIo();
      boolean that_present_io = true && that.isSetIo();
      if (this_present_io || that_present_io) {
        if (!(this_present_io && that_present_io))
          return false;
        if (!this.io.equals(that.io))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_result typedOther = (get_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetIo()).compareTo(typedOther.isSetIo());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetIo()) {
        lastComparison = TBaseHelper.compareTo(this.io, typedOther.io);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list26 = iprot.readListBegin();
                this.success = new ArrayList<TCell>(_list26.size);
                for (int _i27 = 0; _i27 < _list26.size; ++_i27)
                {
                  TCell _elem28;
                  _elem28 = new TCell();
                  _elem28.read(iprot);
                  this.success.add(_elem28);
                }
                iprot.readListEnd();
              }
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // IO
            if (field.type == TType.STRUCT) {
              this.io = new IOError();
              this.io.read(iprot);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (TCell _iter29 : this.success)
          {
            _iter29.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetIo()) {
        oprot.writeFieldBegin(IO_FIELD_DESC);
        this.io.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("io:");
      if (this.io == null) {
        sb.append("null");
      } else {
        sb.append(this.io);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getVer_args implements TBase<getVer_args, getVer_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getVer_args");

    private static final TField TABLE_NAME_FIELD_DESC = new TField("tableName", TType.STRING, (short)1);
    private static final TField ROW_FIELD_DESC = new TField("row", TType.STRING, (short)2);
    private static final TField COLUMN_FIELD_DESC = new TField("column", TType.STRING, (short)3);
    private static final TField NUM_VERSIONS_FIELD_DESC = new TField("numVersions", TType.I32, (short)4);

    /**
     * name of table
     */
    public ByteBuffer tableName;
    /**
     * row key
     */
    public ByteBuffer row;
    /**
     * column name
     */
    public ByteBuffer column;
    /**
     * number of versions to retrieve
     */
    public int numVersions;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      /**
       * name of table
       */
      TABLE_NAME((short)1, "tableName"),
      /**
       * row key
       */
      ROW((short)2, "row"),
      /**
       * column name
       */
      COLUMN((short)3, "column"),
      /**
       * number of versions to retrieve
       */
      NUM_VERSIONS((short)4, "numVersions");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // TABLE_NAME
            return TABLE_NAME;
          case 2: // ROW
            return ROW;
          case 3: // COLUMN
            return COLUMN;
          case 4: // NUM_VERSIONS
            return NUM_VERSIONS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __NUMVERSIONS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.TABLE_NAME, new FieldMetaData("tableName", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Text")));
      tmpMap.put(_Fields.ROW, new FieldMetaData("row", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Text")));
      tmpMap.put(_Fields.COLUMN, new FieldMetaData("column", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Text")));
      tmpMap.put(_Fields.NUM_VERSIONS, new FieldMetaData("numVersions", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.I32)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getVer_args.class, metaDataMap);
    }

    public getVer_args() {
    }

    public getVer_args(
      ByteBuffer tableName,
      ByteBuffer row,
      ByteBuffer column,
      int numVersions)
    {
      this();
      this.tableName = tableName;
      this.row = row;
      this.column = column;
      this.numVersions = numVersions;
      setNumVersionsIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getVer_args(getVer_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      if (other.isSetTableName()) {
        this.tableName = other.tableName;
      }
      if (other.isSetRow()) {
        this.row = other.row;
      }
      if (other.isSetColumn()) {
        this.column = other.column;
      }
      this.numVersions = other.numVersions;
    }

    public getVer_args deepCopy() {
      return new getVer_args(this);
    }

    @Override
    public void clear() {
      this.tableName = null;
      this.row = null;
      this.column = null;
      setNumVersionsIsSet(false);
      this.numVersions = 0;
    }

    /**
     * name of table
     */
    public byte[] getTableName() {
      setTableName(TBaseHelper.rightSize(tableName));
      return tableName.array();
    }

    public ByteBuffer BufferForTableName() {
      return tableName;
    }

    /**
     * name of table
     */
    public getVer_args setTableName(byte[] tableName) {
      setTableName(ByteBuffer.wrap(tableName));
      return this;
    }

    public getVer_args setTableName(ByteBuffer tableName) {
      this.tableName = tableName;
      return this;
    }

    public void unsetTableName() {
      this.tableName = null;
    }

    /** Returns true if field tableName is set (has been asigned a value) and false otherwise */
    public boolean isSetTableName() {
      return this.tableName != null;
    }

    public void setTableNameIsSet(boolean value) {
      if (!value) {
        this.tableName = null;
      }
    }

    /**
     * row key
     */
    public byte[] getRow() {
      setRow(TBaseHelper.rightSize(row));
      return row.array();
    }

    public ByteBuffer BufferForRow() {
      return row;
    }

    /**
     * row key
     */
    public getVer_args setRow(byte[] row) {
      setRow(ByteBuffer.wrap(row));
      return this;
    }

    public getVer_args setRow(ByteBuffer row) {
      this.row = row;
      return this;
    }

    public void unsetRow() {
      this.row = null;
    }

    /** Returns true if field row is set (has been asigned a value) and false otherwise */
    public boolean isSetRow() {
      return this.row != null;
    }

    public void setRowIsSet(boolean value) {
      if (!value) {
        this.row = null;
      }
    }

    /**
     * column name
     */
    public byte[] getColumn() {
      setColumn(TBaseHelper.rightSize(column));
      return column.array();
    }

    public ByteBuffer BufferForColumn() {
      return column;
    }

    /**
     * column name
     */
    public getVer_args setColumn(byte[] column) {
      setColumn(ByteBuffer.wrap(column));
      return this;
    }

    public getVer_args setColumn(ByteBuffer column) {
      this.column = column;
      return this;
    }

    public void unsetColumn() {
      this.column = null;
    }

    /** Returns true if field column is set (has been asigned a value) and false otherwise */
    public boolean isSetColumn() {
      return this.column != null;
    }

    public void setColumnIsSet(boolean value) {
      if (!value) {
        this.column = null;
      }
    }

    /**
     * number of versions to retrieve
     */
    public int getNumVersions() {
      return this.numVersions;
    }

    /**
     * number of versions to retrieve
     */
    public getVer_args setNumVersions(int numVersions) {
      this.numVersions = numVersions;
      setNumVersionsIsSet(true);
      return this;
    }

    public void unsetNumVersions() {
      __isset_bit_vector.clear(__NUMVERSIONS_ISSET_ID);
    }

    /** Returns true if field numVersions is set (has been asigned a value) and false otherwise */
    public boolean isSetNumVersions() {
      return __isset_bit_vector.get(__NUMVERSIONS_ISSET_ID);
    }

    public void setNumVersionsIsSet(boolean value) {
      __isset_bit_vector.set(__NUMVERSIONS_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TABLE_NAME:
        if (value == null) {
          unsetTableName();
        } else {
          setTableName((ByteBuffer)value);
        }
        break;

      case ROW:
        if (value == null) {
          unsetRow();
        } else {
          setRow((ByteBuffer)value);
        }
        break;

      case COLUMN:
        if (value == null) {
          unsetColumn();
        } else {
          setColumn((ByteBuffer)value);
        }
        break;

      case NUM_VERSIONS:
        if (value == null) {
          unsetNumVersions();
        } else {
          setNumVersions((Integer)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return getTableName();

      case ROW:
        return getRow();

      case COLUMN:
        return getColumn();

      case NUM_VERSIONS:
        return new Integer(getNumVersions());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case TABLE_NAME:
        return isSetTableName();
      case ROW:
        return isSetRow();
      case COLUMN:
        return isSetColumn();
      case NUM_VERSIONS:
        return isSetNumVersions();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getVer_args)
        return this.equals((getVer_args)that);
      return false;
    }

    public boolean equals(getVer_args that) {
      if (that == null)
        return false;

      boolean this_present_tableName = true && this.isSetTableName();
      boolean that_present_tableName = true && that.isSetTableName();
      if (this_present_tableName || that_present_tableName) {
        if (!(this_present_tableName && that_present_tableName))
          return false;
        if (!this.tableName.equals(that.tableName))
          return false;
      }

      boolean this_present_row = true && this.isSetRow();
      boolean that_present_row = true && that.isSetRow();
      if (this_present_row || that_present_row) {
        if (!(this_present_row && that_present_row))
          return false;
        if (!this.row.equals(that.row))
          return false;
      }

      boolean this_present_column = true && this.isSetColumn();
      boolean that_present_column = true && that.isSetColumn();
      if (this_present_column || that_present_column) {
        if (!(this_present_column && that_present_column))
          return false;
        if (!this.column.equals(that.column))
          return false;
      }

      boolean this_present_numVersions = true;
      boolean that_present_numVersions = true;
      if (this_present_numVersions || that_present_numVersions) {
        if (!(this_present_numVersions && that_present_numVersions))
          return false;
        if (this.numVersions != that.numVersions)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getVer_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getVer_args typedOther = (getVer_args)other;

      lastComparison = Boolean.valueOf(isSetTableName()).compareTo(typedOther.isSetTableName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTableName()) {
        lastComparison = TBaseHelper.compareTo(this.tableName, typedOther.tableName);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetRow()).compareTo(typedOther.isSetRow());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetRow()) {
        lastComparison = TBaseHelper.compareTo(this.row, typedOther.row);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetColumn()).compareTo(typedOther.isSetColumn());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetColumn()) {
        lastComparison = TBaseHelper.compareTo(this.column, typedOther.column);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetNumVersions()).compareTo(typedOther.isSetNumVersions());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetNumVersions()) {
        lastComparison = TBaseHelper.compareTo(this.numVersions, typedOther.numVersions);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 1: // TABLE_NAME
            if (field.type == TType.STRING) {
              this.tableName = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // ROW
            if (field.type == TType.STRING) {
              this.row = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // COLUMN
            if (field.type == TType.STRING) {
              this.column = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 4: // NUM_VERSIONS
            if (field.type == TType.I32) {
              this.numVersions = iprot.readI32();
              setNumVersionsIsSet(true);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tableName != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeBinary(this.tableName);
        oprot.writeFieldEnd();
      }
      if (this.row != null) {
        oprot.writeFieldBegin(ROW_FIELD_DESC);
        oprot.writeBinary(this.row);
        oprot.writeFieldEnd();
      }
      if (this.column != null) {
        oprot.writeFieldBegin(COLUMN_FIELD_DESC);
        oprot.writeBinary(this.column);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(NUM_VERSIONS_FIELD_DESC);
      oprot.writeI32(this.numVersions);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getVer_args(");
      boolean first = true;

      sb.append("tableName:");
      if (this.tableName == null) {
        sb.append("null");
      } else {
        sb.append(this.tableName);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("row:");
      if (this.row == null) {
        sb.append("null");
      } else {
        sb.append(this.row);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("column:");
      if (this.column == null) {
        sb.append("null");
      } else {
        sb.append(this.column);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("numVersions:");
      sb.append(this.numVersions);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getVer_result implements TBase<getVer_result, getVer_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getVer_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField IO_FIELD_DESC = new TField("io", TType.STRUCT, (short)1);

    public List<TCell> success;
    public IOError io;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      IO((short)1, "io");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // IO
            return IO;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT,
          new ListMetaData(TType.LIST,
              new StructMetaData(TType.STRUCT, TCell.class))));
      tmpMap.put(_Fields.IO, new FieldMetaData("io", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getVer_result.class, metaDataMap);
    }

    public getVer_result() {
    }

    public getVer_result(
      List<TCell> success,
      IOError io)
    {
      this();
      this.success = success;
      this.io = io;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getVer_result(getVer_result other) {
      if (other.isSetSuccess()) {
        List<TCell> __this__success = new ArrayList<TCell>();
        for (TCell other_element : other.success) {
          __this__success.add(new TCell(other_element));
        }
        this.success = __this__success;
      }
      if (other.isSetIo()) {
        this.io = new IOError(other.io);
      }
    }

    public getVer_result deepCopy() {
      return new getVer_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.io = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<TCell> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(TCell elem) {
      if (this.success == null) {
        this.success = new ArrayList<TCell>();
      }
      this.success.add(elem);
    }

    public List<TCell> getSuccess() {
      return this.success;
    }

    public getVer_result setSuccess(List<TCell> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public IOError getIo() {
      return this.io;
    }

    public getVer_result setIo(IOError io) {
      this.io = io;
      return this;
    }

    public void unsetIo() {
      this.io = null;
    }

    /** Returns true if field io is set (has been asigned a value) and false otherwise */
    public boolean isSetIo() {
      return this.io != null;
    }

    public void setIoIsSet(boolean value) {
      if (!value) {
        this.io = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<TCell>)value);
        }
        break;

      case IO:
        if (value == null) {
          unsetIo();
        } else {
          setIo((IOError)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case IO:
        return getIo();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case IO:
        return isSetIo();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getVer_result)
        return this.equals((getVer_result)that);
      return false;
    }

    public boolean equals(getVer_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_io = true && this.isSetIo();
      boolean that_present_io = true && that.isSetIo();
      if (this_present_io || that_present_io) {
        if (!(this_present_io && that_present_io))
          return false;
        if (!this.io.equals(that.io))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getVer_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getVer_result typedOther = (getVer_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetIo()).compareTo(typedOther.isSetIo());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetIo()) {
        lastComparison = TBaseHelper.compareTo(this.io, typedOther.io);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list30 = iprot.readListBegin();
                this.success = new ArrayList<TCell>(_list30.size);
                for (int _i31 = 0; _i31 < _list30.size; ++_i31)
                {
                  TCell _elem32;
                  _elem32 = new TCell();
                  _elem32.read(iprot);
                  this.success.add(_elem32);
                }
                iprot.readListEnd();
              }
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // IO
            if (field.type == TType.STRUCT) {
              this.io = new IOError();
              this.io.read(iprot);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (TCell _iter33 : this.success)
          {
            _iter33.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetIo()) {
        oprot.writeFieldBegin(IO_FIELD_DESC);
        this.io.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getVer_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("io:");
      if (this.io == null) {
        sb.append("null");
      } else {
        sb.append(this.io);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getVerTs_args implements TBase<getVerTs_args, getVerTs_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getVerTs_args");

    private static final TField TABLE_NAME_FIELD_DESC = new TField("tableName", TType.STRING, (short)1);
    private static final TField ROW_FIELD_DESC = new TField("row", TType.STRING, (short)2);
    private static final TField COLUMN_FIELD_DESC = new TField("column", TType.STRING, (short)3);
    private static final TField TIMESTAMP_FIELD_DESC = new TField("timestamp", TType.I64, (short)4);
    private static final TField NUM_VERSIONS_FIELD_DESC = new TField("numVersions", TType.I32, (short)5);

    /**
     * name of table
     */
    public ByteBuffer tableName;
    /**
     * row key
     */
    public ByteBuffer row;
    /**
     * column name
     */
    public ByteBuffer column;
    /**
     * timestamp
     */
    public long timestamp;
    /**
     * number of versions to retrieve
     */
    public int numVersions;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      /**
       * name of table
       */
      TABLE_NAME((short)1, "tableName"),
      /**
       * row key
       */
      ROW((short)2, "row"),
      /**
       * column name
       */
      COLUMN((short)3, "column"),
      /**
       * timestamp
       */
      TIMESTAMP((short)4, "timestamp"),
      /**
       * number of versions to retrieve
       */
      NUM_VERSIONS((short)5, "numVersions");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // TABLE_NAME
            return TABLE_NAME;
          case 2: // ROW
            return ROW;
          case 3: // COLUMN
            return COLUMN;
          case 4: // TIMESTAMP
            return TIMESTAMP;
          case 5: // NUM_VERSIONS
            return NUM_VERSIONS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __TIMESTAMP_ISSET_ID = 0;
    private static final int __NUMVERSIONS_ISSET_ID = 1;
    private BitSet __isset_bit_vector = new BitSet(2);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.TABLE_NAME, new FieldMetaData("tableName", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Text")));
      tmpMap.put(_Fields.ROW, new FieldMetaData("row", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Text")));
      tmpMap.put(_Fields.COLUMN, new FieldMetaData("column", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Text")));
      tmpMap.put(_Fields.TIMESTAMP, new FieldMetaData("timestamp", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.I64)));
      tmpMap.put(_Fields.NUM_VERSIONS, new FieldMetaData("numVersions", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.I32)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getVerTs_args.class, metaDataMap);
    }

    public getVerTs_args() {
    }

    public getVerTs_args(
      ByteBuffer tableName,
      ByteBuffer row,
      ByteBuffer column,
      long timestamp,
      int numVersions)
    {
      this();
      this.tableName = tableName;
      this.row = row;
      this.column = column;
      this.timestamp = timestamp;
      setTimestampIsSet(true);
      this.numVersions = numVersions;
      setNumVersionsIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getVerTs_args(getVerTs_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      if (other.isSetTableName()) {
        this.tableName = other.tableName;
      }
      if (other.isSetRow()) {
        this.row = other.row;
      }
      if (other.isSetColumn()) {
        this.column = other.column;
      }
      this.timestamp = other.timestamp;
      this.numVersions = other.numVersions;
    }

    public getVerTs_args deepCopy() {
      return new getVerTs_args(this);
    }

    @Override
    public void clear() {
      this.tableName = null;
      this.row = null;
      this.column = null;
      setTimestampIsSet(false);
      this.timestamp = 0;
      setNumVersionsIsSet(false);
      this.numVersions = 0;
    }

    /**
     * name of table
     */
    public byte[] getTableName() {
      setTableName(TBaseHelper.rightSize(tableName));
      return tableName.array();
    }

    public ByteBuffer BufferForTableName() {
      return tableName;
    }

    /**
     * name of table
     */
    public getVerTs_args setTableName(byte[] tableName) {
      setTableName(ByteBuffer.wrap(tableName));
      return this;
    }

    public getVerTs_args setTableName(ByteBuffer tableName) {
      this.tableName = tableName;
      return this;
    }

    public void unsetTableName() {
      this.tableName = null;
    }

    /** Returns true if field tableName is set (has been asigned a value) and false otherwise */
    public boolean isSetTableName() {
      return this.tableName != null;
    }

    public void setTableNameIsSet(boolean value) {
      if (!value) {
        this.tableName = null;
      }
    }

    /**
     * row key
     */
    public byte[] getRow() {
      setRow(TBaseHelper.rightSize(row));
      return row.array();
    }

    public ByteBuffer BufferForRow() {
      return row;
    }

    /**
     * row key
     */
    public getVerTs_args setRow(byte[] row) {
      setRow(ByteBuffer.wrap(row));
      return this;
    }

    public getVerTs_args setRow(ByteBuffer row) {
      this.row = row;
      return this;
    }

    public void unsetRow() {
      this.row = null;
    }

    /** Returns true if field row is set (has been asigned a value) and false otherwise */
    public boolean isSetRow() {
      return this.row != null;
    }

    public void setRowIsSet(boolean value) {
      if (!value) {
        this.row = null;
      }
    }

    /**
     * column name
     */
    public byte[] getColumn() {
      setColumn(TBaseHelper.rightSize(column));
      return column.array();
    }

    public ByteBuffer BufferForColumn() {
      return column;
    }

    /**
     * column name
     */
    public getVerTs_args setColumn(byte[] column) {
      setColumn(ByteBuffer.wrap(column));
      return this;
    }

    public getVerTs_args setColumn(ByteBuffer column) {
      this.column = column;
      return this;
    }

    public void unsetColumn() {
      this.column = null;
    }

    /** Returns true if field column is set (has been asigned a value) and false otherwise */
    public boolean isSetColumn() {
      return this.column != null;
    }

    public void setColumnIsSet(boolean value) {
      if (!value) {
        this.column = null;
      }
    }

    /**
     * timestamp
     */
    public long getTimestamp() {
      return this.timestamp;
    }

    /**
     * timestamp
     */
    public getVerTs_args setTimestamp(long timestamp) {
      this.timestamp = timestamp;
      setTimestampIsSet(true);
      return this;
    }

    public void unsetTimestamp() {
      __isset_bit_vector.clear(__TIMESTAMP_ISSET_ID);
    }

    /** Returns true if field timestamp is set (has been asigned a value) and false otherwise */
    public boolean isSetTimestamp() {
      return __isset_bit_vector.get(__TIMESTAMP_ISSET_ID);
    }

    public void setTimestampIsSet(boolean value) {
      __isset_bit_vector.set(__TIMESTAMP_ISSET_ID, value);
    }

    /**
     * number of versions to retrieve
     */
    public int getNumVersions() {
      return this.numVersions;
    }

    /**
     * number of versions to retrieve
     */
    public getVerTs_args setNumVersions(int numVersions) {
      this.numVersions = numVersions;
      setNumVersionsIsSet(true);
      return this;
    }

    public void unsetNumVersions() {
      __isset_bit_vector.clear(__NUMVERSIONS_ISSET_ID);
    }

    /** Returns true if field numVersions is set (has been asigned a value) and false otherwise */
    public boolean isSetNumVersions() {
      return __isset_bit_vector.get(__NUMVERSIONS_ISSET_ID);
    }

    public void setNumVersionsIsSet(boolean value) {
      __isset_bit_vector.set(__NUMVERSIONS_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TABLE_NAME:
        if (value == null) {
          unsetTableName();
        } else {
          setTableName((ByteBuffer)value);
        }
        break;

      case ROW:
        if (value == null) {
          unsetRow();
        } else {
          setRow((ByteBuffer)value);
        }
        break;

      case COLUMN:
        if (value == null) {
          unsetColumn();
        } else {
          setColumn((ByteBuffer)value);
        }
        break;

      case TIMESTAMP:
        if (value == null) {
          unsetTimestamp();
        } else {
          setTimestamp((Long)value);
        }
        break;

      case NUM_VERSIONS:
        if (value == null) {
          unsetNumVersions();
        } else {
          setNumVersions((Integer)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return getTableName();

      case ROW:
        return getRow();

      case COLUMN:
        return getColumn();

      case TIMESTAMP:
        return new Long(getTimestamp());

      case NUM_VERSIONS:
        return new Integer(getNumVersions());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case TABLE_NAME:
        return isSetTableName();
      case ROW:
        return isSetRow();
      case COLUMN:
        return isSetColumn();
      case TIMESTAMP:
        return isSetTimestamp();
      case NUM_VERSIONS:
        return isSetNumVersions();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getVerTs_args)
        return this.equals((getVerTs_args)that);
      return false;
    }

    public boolean equals(getVerTs_args that) {
      if (that == null)
        return false;

      boolean this_present_tableName = true && this.isSetTableName();
      boolean that_present_tableName = true && that.isSetTableName();
      if (this_present_tableName || that_present_tableName) {
        if (!(this_present_tableName && that_present_tableName))
          return false;
        if (!this.tableName.equals(that.tableName))
          return false;
      }

      boolean this_present_row = true && this.isSetRow();
      boolean that_present_row = true && that.isSetRow();
      if (this_present_row || that_present_row) {
        if (!(this_present_row && that_present_row))
          return false;
        if (!this.row.equals(that.row))
          return false;
      }

      boolean this_present_column = true && this.isSetColumn();
      boolean that_present_column = true && that.isSetColumn();
      if (this_present_column || that_present_column) {
        if (!(this_present_column && that_present_column))
          return false;
        if (!this.column.equals(that.column))
          return false;
      }

      boolean this_present_timestamp = true;
      boolean that_present_timestamp = true;
      if (this_present_timestamp || that_present_timestamp) {
        if (!(this_present_timestamp && that_present_timestamp))
          return false;
        if (this.timestamp != that.timestamp)
          return false;
      }

      boolean this_present_numVersions = true;
      boolean that_present_numVersions = true;
      if (this_present_numVersions || that_present_numVersions) {
        if (!(this_present_numVersions && that_present_numVersions))
          return false;
        if (this.numVersions != that.numVersions)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getVerTs_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getVerTs_args typedOther = (getVerTs_args)other;

      lastComparison = Boolean.valueOf(isSetTableName()).compareTo(typedOther.isSetTableName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTableName()) {
        lastComparison = TBaseHelper.compareTo(this.tableName, typedOther.tableName);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetRow()).compareTo(typedOther.isSetRow());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetRow()) {
        lastComparison = TBaseHelper.compareTo(this.row, typedOther.row);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetColumn()).compareTo(typedOther.isSetColumn());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetColumn()) {
        lastComparison = TBaseHelper.compareTo(this.column, typedOther.column);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetTimestamp()).compareTo(typedOther.isSetTimestamp());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTimestamp()) {
        lastComparison = TBaseHelper.compareTo(this.timestamp, typedOther.timestamp);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetNumVersions()).compareTo(typedOther.isSetNumVersions());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetNumVersions()) {
        lastComparison = TBaseHelper.compareTo(this.numVersions, typedOther.numVersions);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 1: // TABLE_NAME
            if (field.type == TType.STRING) {
              this.tableName = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // ROW
            if (field.type == TType.STRING) {
              this.row = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // COLUMN
            if (field.type == TType.STRING) {
              this.column = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 4: // TIMESTAMP
            if (field.type == TType.I64) {
              this.timestamp = iprot.readI64();
              setTimestampIsSet(true);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 5: // NUM_VERSIONS
            if (field.type == TType.I32) {
              this.numVersions = iprot.readI32();
              setNumVersionsIsSet(true);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tableName != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeBinary(this.tableName);
        oprot.writeFieldEnd();
      }
      if (this.row != null) {
        oprot.writeFieldBegin(ROW_FIELD_DESC);
        oprot.writeBinary(this.row);
        oprot.writeFieldEnd();
      }
      if (this.column != null) {
        oprot.writeFieldBegin(COLUMN_FIELD_DESC);
        oprot.writeBinary(this.column);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(TIMESTAMP_FIELD_DESC);
      oprot.writeI64(this.timestamp);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(NUM_VERSIONS_FIELD_DESC);
      oprot.writeI32(this.numVersions);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getVerTs_args(");
      boolean first = true;

      sb.append("tableName:");
      if (this.tableName == null) {
        sb.append("null");
      } else {
        sb.append(this.tableName);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("row:");
      if (this.row == null) {
        sb.append("null");
      } else {
        sb.append(this.row);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("column:");
      if (this.column == null) {
        sb.append("null");
      } else {
        sb.append(this.column);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("timestamp:");
      sb.append(this.timestamp);
      first = false;
      if (!first) sb.append(", ");
      sb.append("numVersions:");
      sb.append(this.numVersions);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getVerTs_result implements TBase<getVerTs_result, getVerTs_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getVerTs_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField IO_FIELD_DESC = new TField("io", TType.STRUCT, (short)1);

    public List<TCell> success;
    public IOError io;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      IO((short)1, "io");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // IO
            return IO;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT,
          new ListMetaData(TType.LIST,
              new StructMetaData(TType.STRUCT, TCell.class))));
      tmpMap.put(_Fields.IO, new FieldMetaData("io", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getVerTs_result.class, metaDataMap);
    }

    public getVerTs_result() {
    }

    public getVerTs_result(
      List<TCell> success,
      IOError io)
    {
      this();
      this.success = success;
      this.io = io;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getVerTs_result(getVerTs_result other) {
      if (other.isSetSuccess()) {
        List<TCell> __this__success = new ArrayList<TCell>();
        for (TCell other_element : other.success) {
          __this__success.add(new TCell(other_element));
        }
        this.success = __this__success;
      }
      if (other.isSetIo()) {
        this.io = new IOError(other.io);
      }
    }

    public getVerTs_result deepCopy() {
      return new getVerTs_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.io = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<TCell> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(TCell elem) {
      if (this.success == null) {
        this.success = new ArrayList<TCell>();
      }
      this.success.add(elem);
    }

    public List<TCell> getSuccess() {
      return this.success;
    }

    public getVerTs_result setSuccess(List<TCell> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public IOError getIo() {
      return this.io;
    }

    public getVerTs_result setIo(IOError io) {
      this.io = io;
      return this;
    }

    public void unsetIo() {
      this.io = null;
    }

    /** Returns true if field io is set (has been asigned a value) and false otherwise */
    public boolean isSetIo() {
      return this.io != null;
    }

    public void setIoIsSet(boolean value) {
      if (!value) {
        this.io = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<TCell>)value);
        }
        break;

      case IO:
        if (value == null) {
          unsetIo();
        } else {
          setIo((IOError)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case IO:
        return getIo();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case IO:
        return isSetIo();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getVerTs_result)
        return this.equals((getVerTs_result)that);
      return false;
    }

    public boolean equals(getVerTs_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_io = true && this.isSetIo();
      boolean that_present_io = true && that.isSetIo();
      if (this_present_io || that_present_io) {
        if (!(this_present_io && that_present_io))
          return false;
        if (!this.io.equals(that.io))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getVerTs_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getVerTs_result typedOther = (getVerTs_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetIo()).compareTo(typedOther.isSetIo());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetIo()) {
        lastComparison = TBaseHelper.compareTo(this.io, typedOther.io);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list34 = iprot.readListBegin();
                this.success = new ArrayList<TCell>(_list34.size);
                for (int _i35 = 0; _i35 < _list34.size; ++_i35)
                {
                  TCell _elem36;
                  _elem36 = new TCell();
                  _elem36.read(iprot);
                  this.success.add(_elem36);
                }
                iprot.readListEnd();
              }
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // IO
            if (field.type == TType.STRUCT) {
              this.io = new IOError();
              this.io.read(iprot);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (TCell _iter37 : this.success)
          {
            _iter37.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetIo()) {
        oprot.writeFieldBegin(IO_FIELD_DESC);
        this.io.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getVerTs_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("io:");
      if (this.io == null) {
        sb.append("null");
      } else {
        sb.append(this.io);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getRow_args implements TBase<getRow_args, getRow_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getRow_args");

    private static final TField TABLE_NAME_FIELD_DESC = new TField("tableName", TType.STRING, (short)1);
    private static final TField ROW_FIELD_DESC = new TField("row", TType.STRING, (short)2);

    /**
     * name of table
     */
    public ByteBuffer tableName;
    /**
     * row key
     */
    public ByteBuffer row;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      /**
       * name of table
       */
      TABLE_NAME((short)1, "tableName"),
      /**
       * row key
       */
      ROW((short)2, "row");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // TABLE_NAME
            return TABLE_NAME;
          case 2: // ROW
            return ROW;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.TABLE_NAME, new FieldMetaData("tableName", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Text")));
      tmpMap.put(_Fields.ROW, new FieldMetaData("row", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Text")));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getRow_args.class, metaDataMap);
    }

    public getRow_args() {
    }

    public getRow_args(
      ByteBuffer tableName,
      ByteBuffer row)
    {
      this();
      this.tableName = tableName;
      this.row = row;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getRow_args(getRow_args other) {
      if (other.isSetTableName()) {
        this.tableName = other.tableName;
      }
      if (other.isSetRow()) {
        this.row = other.row;
      }
    }

    public getRow_args deepCopy() {
      return new getRow_args(this);
    }

    @Override
    public void clear() {
      this.tableName = null;
      this.row = null;
    }

    /**
     * name of table
     */
    public byte[] getTableName() {
      setTableName(TBaseHelper.rightSize(tableName));
      return tableName.array();
    }

    public ByteBuffer BufferForTableName() {
      return tableName;
    }

    /**
     * name of table
     */
    public getRow_args setTableName(byte[] tableName) {
      setTableName(ByteBuffer.wrap(tableName));
      return this;
    }

    public getRow_args setTableName(ByteBuffer tableName) {
      this.tableName = tableName;
      return this;
    }

    public void unsetTableName() {
      this.tableName = null;
    }

    /** Returns true if field tableName is set (has been asigned a value) and false otherwise */
    public boolean isSetTableName() {
      return this.tableName != null;
    }

    public void setTableNameIsSet(boolean value) {
      if (!value) {
        this.tableName = null;
      }
    }

    /**
     * row key
     */
    public byte[] getRow() {
      setRow(TBaseHelper.rightSize(row));
      return row.array();
    }

    public ByteBuffer BufferForRow() {
      return row;
    }

    /**
     * row key
     */
    public getRow_args setRow(byte[] row) {
      setRow(ByteBuffer.wrap(row));
      return this;
    }

    public getRow_args setRow(ByteBuffer row) {
      this.row = row;
      return this;
    }

    public void unsetRow() {
      this.row = null;
    }

    /** Returns true if field row is set (has been asigned a value) and false otherwise */
    public boolean isSetRow() {
      return this.row != null;
    }

    public void setRowIsSet(boolean value) {
      if (!value) {
        this.row = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TABLE_NAME:
        if (value == null) {
          unsetTableName();
        } else {
          setTableName((ByteBuffer)value);
        }
        break;

      case ROW:
        if (value == null) {
          unsetRow();
        } else {
          setRow((ByteBuffer)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return getTableName();

      case ROW:
        return getRow();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case TABLE_NAME:
        return isSetTableName();
      case ROW:
        return isSetRow();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getRow_args)
        return this.equals((getRow_args)that);
      return false;
    }

    public boolean equals(getRow_args that) {
      if (that == null)
        return false;

      boolean this_present_tableName = true && this.isSetTableName();
      boolean that_present_tableName = true && that.isSetTableName();
      if (this_present_tableName || that_present_tableName) {
        if (!(this_present_tableName && that_present_tableName))
          return false;
        if (!this.tableName.equals(that.tableName))
          return false;
      }

      boolean this_present_row = true && this.isSetRow();
      boolean that_present_row = true && that.isSetRow();
      if (this_present_row || that_present_row) {
        if (!(this_present_row && that_present_row))
          return false;
        if (!this.row.equals(that.row))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getRow_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getRow_args typedOther = (getRow_args)other;

      lastComparison = Boolean.valueOf(isSetTableName()).compareTo(typedOther.isSetTableName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTableName()) {
        lastComparison = TBaseHelper.compareTo(this.tableName, typedOther.tableName);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetRow()).compareTo(typedOther.isSetRow());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetRow()) {
        lastComparison = TBaseHelper.compareTo(this.row, typedOther.row);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 1: // TABLE_NAME
            if (field.type == TType.STRING) {
              this.tableName = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // ROW
            if (field.type == TType.STRING) {
              this.row = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tableName != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeBinary(this.tableName);
        oprot.writeFieldEnd();
      }
      if (this.row != null) {
        oprot.writeFieldBegin(ROW_FIELD_DESC);
        oprot.writeBinary(this.row);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getRow_args(");
      boolean first = true;

      sb.append("tableName:");
      if (this.tableName == null) {
        sb.append("null");
      } else {
        sb.append(this.tableName);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("row:");
      if (this.row == null) {
        sb.append("null");
      } else {
        sb.append(this.row);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getRow_result implements TBase<getRow_result, getRow_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getRow_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField IO_FIELD_DESC = new TField("io", TType.STRUCT, (short)1);

    public List<TRowResult> success;
    public IOError io;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      IO((short)1, "io");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // IO
            return IO;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT,
          new ListMetaData(TType.LIST,
              new StructMetaData(TType.STRUCT, TRowResult.class))));
      tmpMap.put(_Fields.IO, new FieldMetaData("io", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getRow_result.class, metaDataMap);
    }

    public getRow_result() {
    }

    public getRow_result(
      List<TRowResult> success,
      IOError io)
    {
      this();
      this.success = success;
      this.io = io;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getRow_result(getRow_result other) {
      if (other.isSetSuccess()) {
        List<TRowResult> __this__success = new ArrayList<TRowResult>();
        for (TRowResult other_element : other.success) {
          __this__success.add(new TRowResult(other_element));
        }
        this.success = __this__success;
      }
      if (other.isSetIo()) {
        this.io = new IOError(other.io);
      }
    }

    public getRow_result deepCopy() {
      return new getRow_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.io = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<TRowResult> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(TRowResult elem) {
      if (this.success == null) {
        this.success = new ArrayList<TRowResult>();
      }
      this.success.add(elem);
    }

    public List<TRowResult> getSuccess() {
      return this.success;
    }

    public getRow_result setSuccess(List<TRowResult> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public IOError getIo() {
      return this.io;
    }

    public getRow_result setIo(IOError io) {
      this.io = io;
      return this;
    }

    public void unsetIo() {
      this.io = null;
    }

    /** Returns true if field io is set (has been asigned a value) and false otherwise */
    public boolean isSetIo() {
      return this.io != null;
    }

    public void setIoIsSet(boolean value) {
      if (!value) {
        this.io = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<TRowResult>)value);
        }
        break;

      case IO:
        if (value == null) {
          unsetIo();
        } else {
          setIo((IOError)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case IO:
        return getIo();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case IO:
        return isSetIo();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getRow_result)
        return this.equals((getRow_result)that);
      return false;
    }

    public boolean equals(getRow_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_io = true && this.isSetIo();
      boolean that_present_io = true && that.isSetIo();
      if (this_present_io || that_present_io) {
        if (!(this_present_io && that_present_io))
          return false;
        if (!this.io.equals(that.io))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getRow_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getRow_result typedOther = (getRow_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetIo()).compareTo(typedOther.isSetIo());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetIo()) {
        lastComparison = TBaseHelper.compareTo(this.io, typedOther.io);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list38 = iprot.readListBegin();
                this.success = new ArrayList<TRowResult>(_list38.size);
                for (int _i39 = 0; _i39 < _list38.size; ++_i39)
                {
                  TRowResult _elem40;
                  _elem40 = new TRowResult();
                  _elem40.read(iprot);
                  this.success.add(_elem40);
                }
                iprot.readListEnd();
              }
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // IO
            if (field.type == TType.STRUCT) {
              this.io = new IOError();
              this.io.read(iprot);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (TRowResult _iter41 : this.success)
          {
            _iter41.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetIo()) {
        oprot.writeFieldBegin(IO_FIELD_DESC);
        this.io.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getRow_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("io:");
      if (this.io == null) {
        sb.append("null");
      } else {
        sb.append(this.io);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getRowWithColumns_args implements TBase<getRowWithColumns_args, getRowWithColumns_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getRowWithColumns_args");

    private static final TField TABLE_NAME_FIELD_DESC = new TField("tableName", TType.STRING, (short)1);
    private static final TField ROW_FIELD_DESC = new TField("row", TType.STRING, (short)2);
    private static final TField COLUMNS_FIELD_DESC = new TField("columns", TType.LIST, (short)3);

    /**
     * name of table
     */
    public ByteBuffer tableName;
    /**
     * row key
     */
    public ByteBuffer row;
    /**
     * List of columns to return, null for all columns
     */
    public List<ByteBuffer> columns;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      /**
       * name of table
       */
      TABLE_NAME((short)1, "tableName"),
      /**
       * row key
       */
      ROW((short)2, "row"),
      /**
       * List of columns to return, null for all columns
       */
      COLUMNS((short)3, "columns");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // TABLE_NAME
            return TABLE_NAME;
          case 2: // ROW
            return ROW;
          case 3: // COLUMNS
            return COLUMNS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.TABLE_NAME, new FieldMetaData("tableName", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Text")));
      tmpMap.put(_Fields.ROW, new FieldMetaData("row", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Text")));
      tmpMap.put(_Fields.COLUMNS, new FieldMetaData("columns", TFieldRequirementType.DEFAULT,
          new ListMetaData(TType.LIST,
              new FieldValueMetaData(TType.STRING              , "Text"))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getRowWithColumns_args.class, metaDataMap);
    }

    public getRowWithColumns_args() {
    }

    public getRowWithColumns_args(
      ByteBuffer tableName,
      ByteBuffer row,
      List<ByteBuffer> columns)
    {
      this();
      this.tableName = tableName;
      this.row = row;
      this.columns = columns;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getRowWithColumns_args(getRowWithColumns_args other) {
      if (other.isSetTableName()) {
        this.tableName = other.tableName;
      }
      if (other.isSetRow()) {
        this.row = other.row;
      }
      if (other.isSetColumns()) {
        List<ByteBuffer> __this__columns = new ArrayList<ByteBuffer>();
        for (ByteBuffer other_element : other.columns) {
          __this__columns.add(other_element);
        }
        this.columns = __this__columns;
      }
    }

    public getRowWithColumns_args deepCopy() {
      return new getRowWithColumns_args(this);
    }

    @Override
    public void clear() {
      this.tableName = null;
      this.row = null;
      this.columns = null;
    }

    /**
     * name of table
     */
    public byte[] getTableName() {
      setTableName(TBaseHelper.rightSize(tableName));
      return tableName.array();
    }

    public ByteBuffer BufferForTableName() {
      return tableName;
    }

    /**
     * name of table
     */
    public getRowWithColumns_args setTableName(byte[] tableName) {
      setTableName(ByteBuffer.wrap(tableName));
      return this;
    }

    public getRowWithColumns_args setTableName(ByteBuffer tableName) {
      this.tableName = tableName;
      return this;
    }

    public void unsetTableName() {
      this.tableName = null;
    }

    /** Returns true if field tableName is set (has been asigned a value) and false otherwise */
    public boolean isSetTableName() {
      return this.tableName != null;
    }

    public void setTableNameIsSet(boolean value) {
      if (!value) {
        this.tableName = null;
      }
    }

    /**
     * row key
     */
    public byte[] getRow() {
      setRow(TBaseHelper.rightSize(row));
      return row.array();
    }

    public ByteBuffer BufferForRow() {
      return row;
    }

    /**
     * row key
     */
    public getRowWithColumns_args setRow(byte[] row) {
      setRow(ByteBuffer.wrap(row));
      return this;
    }

    public getRowWithColumns_args setRow(ByteBuffer row) {
      this.row = row;
      return this;
    }

    public void unsetRow() {
      this.row = null;
    }

    /** Returns true if field row is set (has been asigned a value) and false otherwise */
    public boolean isSetRow() {
      return this.row != null;
    }

    public void setRowIsSet(boolean value) {
      if (!value) {
        this.row = null;
      }
    }

    public int getColumnsSize() {
      return (this.columns == null) ? 0 : this.columns.size();
    }

    public java.util.Iterator<ByteBuffer> getColumnsIterator() {
      return (this.columns == null) ? null : this.columns.iterator();
    }

    public void addToColumns(ByteBuffer elem) {
      if (this.columns == null) {
        this.columns = new ArrayList<ByteBuffer>();
      }
      this.columns.add(elem);
    }

    /**
     * List of columns to return, null for all columns
     */
    public List<ByteBuffer> getColumns() {
      return this.columns;
    }

    /**
     * List of columns to return, null for all columns
     */
    public getRowWithColumns_args setColumns(List<ByteBuffer> columns) {
      this.columns = columns;
      return this;
    }

    public void unsetColumns() {
      this.columns = null;
    }

    /** Returns true if field columns is set (has been asigned a value) and false otherwise */
    public boolean isSetColumns() {
      return this.columns != null;
    }

    public void setColumnsIsSet(boolean value) {
      if (!value) {
        this.columns = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TABLE_NAME:
        if (value == null) {
          unsetTableName();
        } else {
          setTableName((ByteBuffer)value);
        }
        break;

      case ROW:
        if (value == null) {
          unsetRow();
        } else {
          setRow((ByteBuffer)value);
        }
        break;

      case COLUMNS:
        if (value == null) {
          unsetColumns();
        } else {
          setColumns((List<ByteBuffer>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return getTableName();

      case ROW:
        return getRow();

      case COLUMNS:
        return getColumns();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case TABLE_NAME:
        return isSetTableName();
      case ROW:
        return isSetRow();
      case COLUMNS:
        return isSetColumns();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getRowWithColumns_args)
        return this.equals((getRowWithColumns_args)that);
      return false;
    }

    public boolean equals(getRowWithColumns_args that) {
      if (that == null)
        return false;

      boolean this_present_tableName = true && this.isSetTableName();
      boolean that_present_tableName = true && that.isSetTableName();
      if (this_present_tableName || that_present_tableName) {
        if (!(this_present_tableName && that_present_tableName))
          return false;
        if (!this.tableName.equals(that.tableName))
          return false;
      }

      boolean this_present_row = true && this.isSetRow();
      boolean that_present_row = true && that.isSetRow();
      if (this_present_row || that_present_row) {
        if (!(this_present_row && that_present_row))
          return false;
        if (!this.row.equals(that.row))
          return false;
      }

      boolean this_present_columns = true && this.isSetColumns();
      boolean that_present_columns = true && that.isSetColumns();
      if (this_present_columns || that_present_columns) {
        if (!(this_present_columns && that_present_columns))
          return false;
        if (!this.columns.equals(that.columns))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getRowWithColumns_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getRowWithColumns_args typedOther = (getRowWithColumns_args)other;

      lastComparison = Boolean.valueOf(isSetTableName()).compareTo(typedOther.isSetTableName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTableName()) {
        lastComparison = TBaseHelper.compareTo(this.tableName, typedOther.tableName);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetRow()).compareTo(typedOther.isSetRow());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetRow()) {
        lastComparison = TBaseHelper.compareTo(this.row, typedOther.row);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetColumns()).compareTo(typedOther.isSetColumns());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetColumns()) {
        lastComparison = TBaseHelper.compareTo(this.columns, typedOther.columns);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 1: // TABLE_NAME
            if (field.type == TType.STRING) {
              this.tableName = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // ROW
            if (field.type == TType.STRING) {
              this.row = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // COLUMNS
            if (field.type == TType.LIST) {
              {
                TList _list42 = iprot.readListBegin();
                this.columns = new ArrayList<ByteBuffer>(_list42.size);
                for (int _i43 = 0; _i43 < _list42.size; ++_i43)
                {
                  ByteBuffer _elem44;
                  _elem44 = iprot.readBinary();
                  this.columns.add(_elem44);
                }
                iprot.readListEnd();
              }
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tableName != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeBinary(this.tableName);
        oprot.writeFieldEnd();
      }
      if (this.row != null) {
        oprot.writeFieldBegin(ROW_FIELD_DESC);
        oprot.writeBinary(this.row);
        oprot.writeFieldEnd();
      }
      if (this.columns != null) {
        oprot.writeFieldBegin(COLUMNS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.columns.size()));
          for (ByteBuffer _iter45 : this.columns)
          {
            oprot.writeBinary(_iter45);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getRowWithColumns_args(");
      boolean first = true;

      sb.append("tableName:");
      if (this.tableName == null) {
        sb.append("null");
      } else {
        sb.append(this.tableName);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("row:");
      if (this.row == null) {
        sb.append("null");
      } else {
        sb.append(this.row);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("columns:");
      if (this.columns == null) {
        sb.append("null");
      } else {
        sb.append(this.columns);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getRowWithColumns_result implements TBase<getRowWithColumns_result, getRowWithColumns_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getRowWithColumns_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField IO_FIELD_DESC = new TField("io", TType.STRUCT, (short)1);

    public List<TRowResult> success;
    public IOError io;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      IO((short)1, "io");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // IO
            return IO;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT,
          new ListMetaData(TType.LIST,
              new StructMetaData(TType.STRUCT, TRowResult.class))));
      tmpMap.put(_Fields.IO, new FieldMetaData("io", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getRowWithColumns_result.class, metaDataMap);
    }

    public getRowWithColumns_result() {
    }

    public getRowWithColumns_result(
      List<TRowResult> success,
      IOError io)
    {
      this();
      this.success = success;
      this.io = io;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getRowWithColumns_result(getRowWithColumns_result other) {
      if (other.isSetSuccess()) {
        List<TRowResult> __this__success = new ArrayList<TRowResult>();
        for (TRowResult other_element : other.success) {
          __this__success.add(new TRowResult(other_element));
        }
        this.success = __this__success;
      }
      if (other.isSetIo()) {
        this.io = new IOError(other.io);
      }
    }

    public getRowWithColumns_result deepCopy() {
      return new getRowWithColumns_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.io = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<TRowResult> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(TRowResult elem) {
      if (this.success == null) {
        this.success = new ArrayList<TRowResult>();
      }
      this.success.add(elem);
    }

    public List<TRowResult> getSuccess() {
      return this.success;
    }

    public getRowWithColumns_result setSuccess(List<TRowResult> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public IOError getIo() {
      return this.io;
    }

    public getRowWithColumns_result setIo(IOError io) {
      this.io = io;
      return this;
    }

    public void unsetIo() {
      this.io = null;
    }

    /** Returns true if field io is set (has been asigned a value) and false otherwise */
    public boolean isSetIo() {
      return this.io != null;
    }

    public void setIoIsSet(boolean value) {
      if (!value) {
        this.io = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<TRowResult>)value);
        }
        break;

      case IO:
        if (value == null) {
          unsetIo();
        } else {
          setIo((IOError)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case IO:
        return getIo();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case IO:
        return isSetIo();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getRowWithColumns_result)
        return this.equals((getRowWithColumns_result)that);
      return false;
    }

    public boolean equals(getRowWithColumns_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_io = true && this.isSetIo();
      boolean that_present_io = true && that.isSetIo();
      if (this_present_io || that_present_io) {
        if (!(this_present_io && that_present_io))
          return false;
        if (!this.io.equals(that.io))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getRowWithColumns_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getRowWithColumns_result typedOther = (getRowWithColumns_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetIo()).compareTo(typedOther.isSetIo());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetIo()) {
        lastComparison = TBaseHelper.compareTo(this.io, typedOther.io);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list46 = iprot.readListBegin();
                this.success = new ArrayList<TRowResult>(_list46.size);
                for (int _i47 = 0; _i47 < _list46.size; ++_i47)
                {
                  TRowResult _elem48;
                  _elem48 = new TRowResult();
                  _elem48.read(iprot);
                  this.success.add(_elem48);
                }
                iprot.readListEnd();
              }
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // IO
            if (field.type == TType.STRUCT) {
              this.io = new IOError();
              this.io.read(iprot);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (TRowResult _iter49 : this.success)
          {
            _iter49.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetIo()) {
        oprot.writeFieldBegin(IO_FIELD_DESC);
        this.io.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getRowWithColumns_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("io:");
      if (this.io == null) {
        sb.append("null");
      } else {
        sb.append(this.io);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getRowTs_args implements TBase<getRowTs_args, getRowTs_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getRowTs_args");

    private static final TField TABLE_NAME_FIELD_DESC = new TField("tableName", TType.STRING, (short)1);
    private static final TField ROW_FIELD_DESC = new TField("row", TType.STRING, (short)2);
    private static final TField TIMESTAMP_FIELD_DESC = new TField("timestamp", TType.I64, (short)3);

    /**
     * name of the table
     */
    public ByteBuffer tableName;
    /**
     * row key
     */
    public ByteBuffer row;
    /**
     * timestamp
     */
    public long timestamp;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      /**
       * name of the table
       */
      TABLE_NAME((short)1, "tableName"),
      /**
       * row key
       */
      ROW((short)2, "row"),
      /**
       * timestamp
       */
      TIMESTAMP((short)3, "timestamp");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // TABLE_NAME
            return TABLE_NAME;
          case 2: // ROW
            return ROW;
          case 3: // TIMESTAMP
            return TIMESTAMP;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __TIMESTAMP_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.TABLE_NAME, new FieldMetaData("tableName", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Text")));
      tmpMap.put(_Fields.ROW, new FieldMetaData("row", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Text")));
      tmpMap.put(_Fields.TIMESTAMP, new FieldMetaData("timestamp", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.I64)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getRowTs_args.class, metaDataMap);
    }

    public getRowTs_args() {
    }

    public getRowTs_args(
      ByteBuffer tableName,
      ByteBuffer row,
      long timestamp)
    {
      this();
      this.tableName = tableName;
      this.row = row;
      this.timestamp = timestamp;
      setTimestampIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getRowTs_args(getRowTs_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      if (other.isSetTableName()) {
        this.tableName = other.tableName;
      }
      if (other.isSetRow()) {
        this.row = other.row;
      }
      this.timestamp = other.timestamp;
    }

    public getRowTs_args deepCopy() {
      return new getRowTs_args(this);
    }

    @Override
    public void clear() {
      this.tableName = null;
      this.row = null;
      setTimestampIsSet(false);
      this.timestamp = 0;
    }

    /**
     * name of the table
     */
    public byte[] getTableName() {
      setTableName(TBaseHelper.rightSize(tableName));
      return tableName.array();
    }

    public ByteBuffer BufferForTableName() {
      return tableName;
    }

    /**
     * name of the table
     */
    public getRowTs_args setTableName(byte[] tableName) {
      setTableName(ByteBuffer.wrap(tableName));
      return this;
    }

    public getRowTs_args setTableName(ByteBuffer tableName) {
      this.tableName = tableName;
      return this;
    }

    public void unsetTableName() {
      this.tableName = null;
    }

    /** Returns true if field tableName is set (has been asigned a value) and false otherwise */
    public boolean isSetTableName() {
      return this.tableName != null;
    }

    public void setTableNameIsSet(boolean value) {
      if (!value) {
        this.tableName = null;
      }
    }

    /**
     * row key
     */
    public byte[] getRow() {
      setRow(TBaseHelper.rightSize(row));
      return row.array();
    }

    public ByteBuffer BufferForRow() {
      return row;
    }

    /**
     * row key
     */
    public getRowTs_args setRow(byte[] row) {
      setRow(ByteBuffer.wrap(row));
      return this;
    }

    public getRowTs_args setRow(ByteBuffer row) {
      this.row = row;
      return this;
    }

    public void unsetRow() {
      this.row = null;
    }

    /** Returns true if field row is set (has been asigned a value) and false otherwise */
    public boolean isSetRow() {
      return this.row != null;
    }

    public void setRowIsSet(boolean value) {
      if (!value) {
        this.row = null;
      }
    }

    /**
     * timestamp
     */
    public long getTimestamp() {
      return this.timestamp;
    }

    /**
     * timestamp
     */
    public getRowTs_args setTimestamp(long timestamp) {
      this.timestamp = timestamp;
      setTimestampIsSet(true);
      return this;
    }

    public void unsetTimestamp() {
      __isset_bit_vector.clear(__TIMESTAMP_ISSET_ID);
    }

    /** Returns true if field timestamp is set (has been asigned a value) and false otherwise */
    public boolean isSetTimestamp() {
      return __isset_bit_vector.get(__TIMESTAMP_ISSET_ID);
    }

    public void setTimestampIsSet(boolean value) {
      __isset_bit_vector.set(__TIMESTAMP_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TABLE_NAME:
        if (value == null) {
          unsetTableName();
        } else {
          setTableName((ByteBuffer)value);
        }
        break;

      case ROW:
        if (value == null) {
          unsetRow();
        } else {
          setRow((ByteBuffer)value);
        }
        break;

      case TIMESTAMP:
        if (value == null) {
          unsetTimestamp();
        } else {
          setTimestamp((Long)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return getTableName();

      case ROW:
        return getRow();

      case TIMESTAMP:
        return new Long(getTimestamp());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case TABLE_NAME:
        return isSetTableName();
      case ROW:
        return isSetRow();
      case TIMESTAMP:
        return isSetTimestamp();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getRowTs_args)
        return this.equals((getRowTs_args)that);
      return false;
    }

    public boolean equals(getRowTs_args that) {
      if (that == null)
        return false;

      boolean this_present_tableName = true && this.isSetTableName();
      boolean that_present_tableName = true && that.isSetTableName();
      if (this_present_tableName || that_present_tableName) {
        if (!(this_present_tableName && that_present_tableName))
          return false;
        if (!this.tableName.equals(that.tableName))
          return false;
      }

      boolean this_present_row = true && this.isSetRow();
      boolean that_present_row = true && that.isSetRow();
      if (this_present_row || that_present_row) {
        if (!(this_present_row && that_present_row))
          return false;
        if (!this.row.equals(that.row))
          return false;
      }

      boolean this_present_timestamp = true;
      boolean that_present_timestamp = true;
      if (this_present_timestamp || that_present_timestamp) {
        if (!(this_present_timestamp && that_present_timestamp))
          return false;
        if (this.timestamp != that.timestamp)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getRowTs_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getRowTs_args typedOther = (getRowTs_args)other;

      lastComparison = Boolean.valueOf(isSetTableName()).compareTo(typedOther.isSetTableName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTableName()) {
        lastComparison = TBaseHelper.compareTo(this.tableName, typedOther.tableName);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetRow()).compareTo(typedOther.isSetRow());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetRow()) {
        lastComparison = TBaseHelper.compareTo(this.row, typedOther.row);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetTimestamp()).compareTo(typedOther.isSetTimestamp());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTimestamp()) {
        lastComparison = TBaseHelper.compareTo(this.timestamp, typedOther.timestamp);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 1: // TABLE_NAME
            if (field.type == TType.STRING) {
              this.tableName = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // ROW
            if (field.type == TType.STRING) {
              this.row = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // TIMESTAMP
            if (field.type == TType.I64) {
              this.timestamp = iprot.readI64();
              setTimestampIsSet(true);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tableName != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeBinary(this.tableName);
        oprot.writeFieldEnd();
      }
      if (this.row != null) {
        oprot.writeFieldBegin(ROW_FIELD_DESC);
        oprot.writeBinary(this.row);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(TIMESTAMP_FIELD_DESC);
      oprot.writeI64(this.timestamp);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getRowTs_args(");
      boolean first = true;

      sb.append("tableName:");
      if (this.tableName == null) {
        sb.append("null");
      } else {
        sb.append(this.tableName);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("row:");
      if (this.row == null) {
        sb.append("null");
      } else {
        sb.append(this.row);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("timestamp:");
      sb.append(this.timestamp);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getRowTs_result implements TBase<getRowTs_result, getRowTs_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getRowTs_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField IO_FIELD_DESC = new TField("io", TType.STRUCT, (short)1);

    public List<TRowResult> success;
    public IOError io;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      IO((short)1, "io");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // IO
            return IO;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT,
          new ListMetaData(TType.LIST,
              new StructMetaData(TType.STRUCT, TRowResult.class))));
      tmpMap.put(_Fields.IO, new FieldMetaData("io", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getRowTs_result.class, metaDataMap);
    }

    public getRowTs_result() {
    }

    public getRowTs_result(
      List<TRowResult> success,
      IOError io)
    {
      this();
      this.success = success;
      this.io = io;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getRowTs_result(getRowTs_result other) {
      if (other.isSetSuccess()) {
        List<TRowResult> __this__success = new ArrayList<TRowResult>();
        for (TRowResult other_element : other.success) {
          __this__success.add(new TRowResult(other_element));
        }
        this.success = __this__success;
      }
      if (other.isSetIo()) {
        this.io = new IOError(other.io);
      }
    }

    public getRowTs_result deepCopy() {
      return new getRowTs_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.io = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<TRowResult> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(TRowResult elem) {
      if (this.success == null) {
        this.success = new ArrayList<TRowResult>();
      }
      this.success.add(elem);
    }

    public List<TRowResult> getSuccess() {
      return this.success;
    }

    public getRowTs_result setSuccess(List<TRowResult> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public IOError getIo() {
      return this.io;
    }

    public getRowTs_result setIo(IOError io) {
      this.io = io;
      return this;
    }

    public void unsetIo() {
      this.io = null;
    }

    /** Returns true if field io is set (has been asigned a value) and false otherwise */
    public boolean isSetIo() {
      return this.io != null;
    }

    public void setIoIsSet(boolean value) {
      if (!value) {
        this.io = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<TRowResult>)value);
        }
        break;

      case IO:
        if (value == null) {
          unsetIo();
        } else {
          setIo((IOError)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case IO:
        return getIo();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case IO:
        return isSetIo();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getRowTs_result)
        return this.equals((getRowTs_result)that);
      return false;
    }

    public boolean equals(getRowTs_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_io = true && this.isSetIo();
      boolean that_present_io = true && that.isSetIo();
      if (this_present_io || that_present_io) {
        if (!(this_present_io && that_present_io))
          return false;
        if (!this.io.equals(that.io))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getRowTs_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getRowTs_result typedOther = (getRowTs_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetIo()).compareTo(typedOther.isSetIo());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetIo()) {
        lastComparison = TBaseHelper.compareTo(this.io, typedOther.io);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list50 = iprot.readListBegin();
                this.success = new ArrayList<TRowResult>(_list50.size);
                for (int _i51 = 0; _i51 < _list50.size; ++_i51)
                {
                  TRowResult _elem52;
                  _elem52 = new TRowResult();
                  _elem52.read(iprot);
                  this.success.add(_elem52);
                }
                iprot.readListEnd();
              }
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // IO
            if (field.type == TType.STRUCT) {
              this.io = new IOError();
              this.io.read(iprot);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (TRowResult _iter53 : this.success)
          {
            _iter53.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetIo()) {
        oprot.writeFieldBegin(IO_FIELD_DESC);
        this.io.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getRowTs_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("io:");
      if (this.io == null) {
        sb.append("null");
      } else {
        sb.append(this.io);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getRowWithColumnsTs_args implements TBase<getRowWithColumnsTs_args, getRowWithColumnsTs_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getRowWithColumnsTs_args");

    private static final TField TABLE_NAME_FIELD_DESC = new TField("tableName", TType.STRING, (short)1);
    private static final TField ROW_FIELD_DESC = new TField("row", TType.STRING, (short)2);
    private static final TField COLUMNS_FIELD_DESC = new TField("columns", TType.LIST, (short)3);
    private static final TField TIMESTAMP_FIELD_DESC = new TField("timestamp", TType.I64, (short)4);

    /**
     * name of table
     */
    public ByteBuffer tableName;
    /**
     * row key
     */
    public ByteBuffer row;
    /**
     * List of columns to return, null for all columns
     */
    public List<ByteBuffer> columns;
    public long timestamp;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      /**
       * name of table
       */
      TABLE_NAME((short)1, "tableName"),
      /**
       * row key
       */
      ROW((short)2, "row"),
      /**
       * List of columns to return, null for all columns
       */
      COLUMNS((short)3, "columns"),
      TIMESTAMP((short)4, "timestamp");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // TABLE_NAME
            return TABLE_NAME;
          case 2: // ROW
            return ROW;
          case 3: // COLUMNS
            return COLUMNS;
          case 4: // TIMESTAMP
            return TIMESTAMP;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __TIMESTAMP_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.TABLE_NAME, new FieldMetaData("tableName", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Text")));
      tmpMap.put(_Fields.ROW, new FieldMetaData("row", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Text")));
      tmpMap.put(_Fields.COLUMNS, new FieldMetaData("columns", TFieldRequirementType.DEFAULT,
          new ListMetaData(TType.LIST,
              new FieldValueMetaData(TType.STRING              , "Text"))));
      tmpMap.put(_Fields.TIMESTAMP, new FieldMetaData("timestamp", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.I64)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getRowWithColumnsTs_args.class, metaDataMap);
    }

    public getRowWithColumnsTs_args() {
    }

    public getRowWithColumnsTs_args(
      ByteBuffer tableName,
      ByteBuffer row,
      List<ByteBuffer> columns,
      long timestamp)
    {
      this();
      this.tableName = tableName;
      this.row = row;
      this.columns = columns;
      this.timestamp = timestamp;
      setTimestampIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getRowWithColumnsTs_args(getRowWithColumnsTs_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      if (other.isSetTableName()) {
        this.tableName = other.tableName;
      }
      if (other.isSetRow()) {
        this.row = other.row;
      }
      if (other.isSetColumns()) {
        List<ByteBuffer> __this__columns = new ArrayList<ByteBuffer>();
        for (ByteBuffer other_element : other.columns) {
          __this__columns.add(other_element);
        }
        this.columns = __this__columns;
      }
      this.timestamp = other.timestamp;
    }

    public getRowWithColumnsTs_args deepCopy() {
      return new getRowWithColumnsTs_args(this);
    }

    @Override
    public void clear() {
      this.tableName = null;
      this.row = null;
      this.columns = null;
      setTimestampIsSet(false);
      this.timestamp = 0;
    }

    /**
     * name of table
     */
    public byte[] getTableName() {
      setTableName(TBaseHelper.rightSize(tableName));
      return tableName.array();
    }

    public ByteBuffer BufferForTableName() {
      return tableName;
    }

    /**
     * name of table
     */
    public getRowWithColumnsTs_args setTableName(byte[] tableName) {
      setTableName(ByteBuffer.wrap(tableName));
      return this;
    }

    public getRowWithColumnsTs_args setTableName(ByteBuffer tableName) {
      this.tableName = tableName;
      return this;
    }

    public void unsetTableName() {
      this.tableName = null;
    }

    /** Returns true if field tableName is set (has been asigned a value) and false otherwise */
    public boolean isSetTableName() {
      return this.tableName != null;
    }

    public void setTableNameIsSet(boolean value) {
      if (!value) {
        this.tableName = null;
      }
    }

    /**
     * row key
     */
    public byte[] getRow() {
      setRow(TBaseHelper.rightSize(row));
      return row.array();
    }

    public ByteBuffer BufferForRow() {
      return row;
    }

    /**
     * row key
     */
    public getRowWithColumnsTs_args setRow(byte[] row) {
      setRow(ByteBuffer.wrap(row));
      return this;
    }

    public getRowWithColumnsTs_args setRow(ByteBuffer row) {
      this.row = row;
      return this;
    }

    public void unsetRow() {
      this.row = null;
    }

    /** Returns true if field row is set (has been asigned a value) and false otherwise */
    public boolean isSetRow() {
      return this.row != null;
    }

    public void setRowIsSet(boolean value) {
      if (!value) {
        this.row = null;
      }
    }

    public int getColumnsSize() {
      return (this.columns == null) ? 0 : this.columns.size();
    }

    public java.util.Iterator<ByteBuffer> getColumnsIterator() {
      return (this.columns == null) ? null : this.columns.iterator();
    }

    public void addToColumns(ByteBuffer elem) {
      if (this.columns == null) {
        this.columns = new ArrayList<ByteBuffer>();
      }
      this.columns.add(elem);
    }

    /**
     * List of columns to return, null for all columns
     */
    public List<ByteBuffer> getColumns() {
      return this.columns;
    }

    /**
     * List of columns to return, null for all columns
     */
    public getRowWithColumnsTs_args setColumns(List<ByteBuffer> columns) {
      this.columns = columns;
      return this;
    }

    public void unsetColumns() {
      this.columns = null;
    }

    /** Returns true if field columns is set (has been asigned a value) and false otherwise */
    public boolean isSetColumns() {
      return this.columns != null;
    }

    public void setColumnsIsSet(boolean value) {
      if (!value) {
        this.columns = null;
      }
    }

    public long getTimestamp() {
      return this.timestamp;
    }

    public getRowWithColumnsTs_args setTimestamp(long timestamp) {
      this.timestamp = timestamp;
      setTimestampIsSet(true);
      return this;
    }

    public void unsetTimestamp() {
      __isset_bit_vector.clear(__TIMESTAMP_ISSET_ID);
    }

    /** Returns true if field timestamp is set (has been asigned a value) and false otherwise */
    public boolean isSetTimestamp() {
      return __isset_bit_vector.get(__TIMESTAMP_ISSET_ID);
    }

    public void setTimestampIsSet(boolean value) {
      __isset_bit_vector.set(__TIMESTAMP_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TABLE_NAME:
        if (value == null) {
          unsetTableName();
        } else {
          setTableName((ByteBuffer)value);
        }
        break;

      case ROW:
        if (value == null) {
          unsetRow();
        } else {
          setRow((ByteBuffer)value);
        }
        break;

      case COLUMNS:
        if (value == null) {
          unsetColumns();
        } else {
          setColumns((List<ByteBuffer>)value);
        }
        break;

      case TIMESTAMP:
        if (value == null) {
          unsetTimestamp();
        } else {
          setTimestamp((Long)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return getTableName();

      case ROW:
        return getRow();

      case COLUMNS:
        return getColumns();

      case TIMESTAMP:
        return new Long(getTimestamp());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case TABLE_NAME:
        return isSetTableName();
      case ROW:
        return isSetRow();
      case COLUMNS:
        return isSetColumns();
      case TIMESTAMP:
        return isSetTimestamp();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getRowWithColumnsTs_args)
        return this.equals((getRowWithColumnsTs_args)that);
      return false;
    }

    public boolean equals(getRowWithColumnsTs_args that) {
      if (that == null)
        return false;

      boolean this_present_tableName = true && this.isSetTableName();
      boolean that_present_tableName = true && that.isSetTableName();
      if (this_present_tableName || that_present_tableName) {
        if (!(this_present_tableName && that_present_tableName))
          return false;
        if (!this.tableName.equals(that.tableName))
          return false;
      }

      boolean this_present_row = true && this.isSetRow();
      boolean that_present_row = true && that.isSetRow();
      if (this_present_row || that_present_row) {
        if (!(this_present_row && that_present_row))
          return false;
        if (!this.row.equals(that.row))
          return false;
      }

      boolean this_present_columns = true && this.isSetColumns();
      boolean that_present_columns = true && that.isSetColumns();
      if (this_present_columns || that_present_columns) {
        if (!(this_present_columns && that_present_columns))
          return false;
        if (!this.columns.equals(that.columns))
          return false;
      }

      boolean this_present_timestamp = true;
      boolean that_present_timestamp = true;
      if (this_present_timestamp || that_present_timestamp) {
        if (!(this_present_timestamp && that_present_timestamp))
          return false;
        if (this.timestamp != that.timestamp)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getRowWithColumnsTs_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getRowWithColumnsTs_args typedOther = (getRowWithColumnsTs_args)other;

      lastComparison = Boolean.valueOf(isSetTableName()).compareTo(typedOther.isSetTableName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTableName()) {
        lastComparison = TBaseHelper.compareTo(this.tableName, typedOther.tableName);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetRow()).compareTo(typedOther.isSetRow());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetRow()) {
        lastComparison = TBaseHelper.compareTo(this.row, typedOther.row);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetColumns()).compareTo(typedOther.isSetColumns());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetColumns()) {
        lastComparison = TBaseHelper.compareTo(this.columns, typedOther.columns);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetTimestamp()).compareTo(typedOther.isSetTimestamp());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTimestamp()) {
        lastComparison = TBaseHelper.compareTo(this.timestamp, typedOther.timestamp);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 1: // TABLE_NAME
            if (field.type == TType.STRING) {
              this.tableName = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // ROW
            if (field.type == TType.STRING) {
              this.row = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // COLUMNS
            if (field.type == TType.LIST) {
              {
                TList _list54 = iprot.readListBegin();
                this.columns = new ArrayList<ByteBuffer>(_list54.size);
                for (int _i55 = 0; _i55 < _list54.size; ++_i55)
                {
                  ByteBuffer _elem56;
                  _elem56 = iprot.readBinary();
                  this.columns.add(_elem56);
                }
                iprot.readListEnd();
              }
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 4: // TIMESTAMP
            if (field.type == TType.I64) {
              this.timestamp = iprot.readI64();
              setTimestampIsSet(true);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tableName != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeBinary(this.tableName);
        oprot.writeFieldEnd();
      }
      if (this.row != null) {
        oprot.writeFieldBegin(ROW_FIELD_DESC);
        oprot.writeBinary(this.row);
        oprot.writeFieldEnd();
      }
      if (this.columns != null) {
        oprot.writeFieldBegin(COLUMNS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.columns.size()));
          for (ByteBuffer _iter57 : this.columns)
          {
            oprot.writeBinary(_iter57);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(TIMESTAMP_FIELD_DESC);
      oprot.writeI64(this.timestamp);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getRowWithColumnsTs_args(");
      boolean first = true;

      sb.append("tableName:");
      if (this.tableName == null) {
        sb.append("null");
      } else {
        sb.append(this.tableName);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("row:");
      if (this.row == null) {
        sb.append("null");
      } else {
        sb.append(this.row);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("columns:");
      if (this.columns == null) {
        sb.append("null");
      } else {
        sb.append(this.columns);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("timestamp:");
      sb.append(this.timestamp);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getRowWithColumnsTs_result implements TBase<getRowWithColumnsTs_result, getRowWithColumnsTs_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getRowWithColumnsTs_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField IO_FIELD_DESC = new TField("io", TType.STRUCT, (short)1);

    public List<TRowResult> success;
    public IOError io;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      IO((short)1, "io");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // IO
            return IO;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT,
          new ListMetaData(TType.LIST,
              new StructMetaData(TType.STRUCT, TRowResult.class))));
      tmpMap.put(_Fields.IO, new FieldMetaData("io", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getRowWithColumnsTs_result.class, metaDataMap);
    }

    public getRowWithColumnsTs_result() {
    }

    public getRowWithColumnsTs_result(
      List<TRowResult> success,
      IOError io)
    {
      this();
      this.success = success;
      this.io = io;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getRowWithColumnsTs_result(getRowWithColumnsTs_result other) {
      if (other.isSetSuccess()) {
        List<TRowResult> __this__success = new ArrayList<TRowResult>();
        for (TRowResult other_element : other.success) {
          __this__success.add(new TRowResult(other_element));
        }
        this.success = __this__success;
      }
      if (other.isSetIo()) {
        this.io = new IOError(other.io);
      }
    }

    public getRowWithColumnsTs_result deepCopy() {
      return new getRowWithColumnsTs_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.io = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<TRowResult> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(TRowResult elem) {
      if (this.success == null) {
        this.success = new ArrayList<TRowResult>();
      }
      this.success.add(elem);
    }

    public List<TRowResult> getSuccess() {
      return this.success;
    }

    public getRowWithColumnsTs_result setSuccess(List<TRowResult> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public IOError getIo() {
      return this.io;
    }

    public getRowWithColumnsTs_result setIo(IOError io) {
      this.io = io;
      return this;
    }

    public void unsetIo() {
      this.io = null;
    }

    /** Returns true if field io is set (has been asigned a value) and false otherwise */
    public boolean isSetIo() {
      return this.io != null;
    }

    public void setIoIsSet(boolean value) {
      if (!value) {
        this.io = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<TRowResult>)value);
        }
        break;

      case IO:
        if (value == null) {
          unsetIo();
        } else {
          setIo((IOError)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case IO:
        return getIo();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case IO:
        return isSetIo();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getRowWithColumnsTs_result)
        return this.equals((getRowWithColumnsTs_result)that);
      return false;
    }

    public boolean equals(getRowWithColumnsTs_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_io = true && this.isSetIo();
      boolean that_present_io = true && that.isSetIo();
      if (this_present_io || that_present_io) {
        if (!(this_present_io && that_present_io))
          return false;
        if (!this.io.equals(that.io))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getRowWithColumnsTs_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getRowWithColumnsTs_result typedOther = (getRowWithColumnsTs_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetIo()).compareTo(typedOther.isSetIo());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetIo()) {
        lastComparison = TBaseHelper.compareTo(this.io, typedOther.io);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list58 = iprot.readListBegin();
                this.success = new ArrayList<TRowResult>(_list58.size);
                for (int _i59 = 0; _i59 < _list58.size; ++_i59)
                {
                  TRowResult _elem60;
                  _elem60 = new TRowResult();
                  _elem60.read(iprot);
                  this.success.add(_elem60);
                }
                iprot.readListEnd();
              }
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // IO
            if (field.type == TType.STRUCT) {
              this.io = new IOError();
              this.io.read(iprot);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (TRowResult _iter61 : this.success)
          {
            _iter61.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetIo()) {
        oprot.writeFieldBegin(IO_FIELD_DESC);
        this.io.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getRowWithColumnsTs_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("io:");
      if (this.io == null) {
        sb.append("null");
      } else {
        sb.append(this.io);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getRows_args implements TBase<getRows_args, getRows_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getRows_args");

    private static final TField TABLE_NAME_FIELD_DESC = new TField("tableName", TType.STRING, (short)1);
    private static final TField ROWS_FIELD_DESC = new TField("rows", TType.LIST, (short)2);

    /**
     * name of table
     */
    public ByteBuffer tableName;
    /**
     * row keys
     */
    public List<ByteBuffer> rows;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      /**
       * name of table
       */
      TABLE_NAME((short)1, "tableName"),
      /**
       * row keys
       */
      ROWS((short)2, "rows");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // TABLE_NAME
            return TABLE_NAME;
          case 2: // ROWS
            return ROWS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.TABLE_NAME, new FieldMetaData("tableName", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Text")));
      tmpMap.put(_Fields.ROWS, new FieldMetaData("rows", TFieldRequirementType.DEFAULT,
          new ListMetaData(TType.LIST,
              new FieldValueMetaData(TType.STRING              , "Text"))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getRows_args.class, metaDataMap);
    }

    public getRows_args() {
    }

    public getRows_args(
      ByteBuffer tableName,
      List<ByteBuffer> rows)
    {
      this();
      this.tableName = tableName;
      this.rows = rows;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getRows_args(getRows_args other) {
      if (other.isSetTableName()) {
        this.tableName = other.tableName;
      }
      if (other.isSetRows()) {
        List<ByteBuffer> __this__rows = new ArrayList<ByteBuffer>();
        for (ByteBuffer other_element : other.rows) {
          __this__rows.add(other_element);
        }
        this.rows = __this__rows;
      }
    }

    public getRows_args deepCopy() {
      return new getRows_args(this);
    }

    @Override
    public void clear() {
      this.tableName = null;
      this.rows = null;
    }

    /**
     * name of table
     */
    public byte[] getTableName() {
      setTableName(TBaseHelper.rightSize(tableName));
      return tableName.array();
    }

    public ByteBuffer BufferForTableName() {
      return tableName;
    }

    /**
     * name of table
     */
    public getRows_args setTableName(byte[] tableName) {
      setTableName(ByteBuffer.wrap(tableName));
      return this;
    }

    public getRows_args setTableName(ByteBuffer tableName) {
      this.tableName = tableName;
      return this;
    }

    public void unsetTableName() {
      this.tableName = null;
    }

    /** Returns true if field tableName is set (has been asigned a value) and false otherwise */
    public boolean isSetTableName() {
      return this.tableName != null;
    }

    public void setTableNameIsSet(boolean value) {
      if (!value) {
        this.tableName = null;
      }
    }

    public int getRowsSize() {
      return (this.rows == null) ? 0 : this.rows.size();
    }

    public java.util.Iterator<ByteBuffer> getRowsIterator() {
      return (this.rows == null) ? null : this.rows.iterator();
    }

    public void addToRows(ByteBuffer elem) {
      if (this.rows == null) {
        this.rows = new ArrayList<ByteBuffer>();
      }
      this.rows.add(elem);
    }

    /**
     * row keys
     */
    public List<ByteBuffer> getRows() {
      return this.rows;
    }

    /**
     * row keys
     */
    public getRows_args setRows(List<ByteBuffer> rows) {
      this.rows = rows;
      return this;
    }

    public void unsetRows() {
      this.rows = null;
    }

    /** Returns true if field rows is set (has been asigned a value) and false otherwise */
    public boolean isSetRows() {
      return this.rows != null;
    }

    public void setRowsIsSet(boolean value) {
      if (!value) {
        this.rows = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TABLE_NAME:
        if (value == null) {
          unsetTableName();
        } else {
          setTableName((ByteBuffer)value);
        }
        break;

      case ROWS:
        if (value == null) {
          unsetRows();
        } else {
          setRows((List<ByteBuffer>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return getTableName();

      case ROWS:
        return getRows();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case TABLE_NAME:
        return isSetTableName();
      case ROWS:
        return isSetRows();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getRows_args)
        return this.equals((getRows_args)that);
      return false;
    }

    public boolean equals(getRows_args that) {
      if (that == null)
        return false;

      boolean this_present_tableName = true && this.isSetTableName();
      boolean that_present_tableName = true && that.isSetTableName();
      if (this_present_tableName || that_present_tableName) {
        if (!(this_present_tableName && that_present_tableName))
          return false;
        if (!this.tableName.equals(that.tableName))
          return false;
      }

      boolean this_present_rows = true && this.isSetRows();
      boolean that_present_rows = true && that.isSetRows();
      if (this_present_rows || that_present_rows) {
        if (!(this_present_rows && that_present_rows))
          return false;
        if (!this.rows.equals(that.rows))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getRows_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getRows_args typedOther = (getRows_args)other;

      lastComparison = Boolean.valueOf(isSetTableName()).compareTo(typedOther.isSetTableName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTableName()) {
        lastComparison = TBaseHelper.compareTo(this.tableName, typedOther.tableName);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetRows()).compareTo(typedOther.isSetRows());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetRows()) {
        lastComparison = TBaseHelper.compareTo(this.rows, typedOther.rows);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 1: // TABLE_NAME
            if (field.type == TType.STRING) {
              this.tableName = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // ROWS
            if (field.type == TType.LIST) {
              {
                TList _list62 = iprot.readListBegin();
                this.rows = new ArrayList<ByteBuffer>(_list62.size);
                for (int _i63 = 0; _i63 < _list62.size; ++_i63)
                {
                  ByteBuffer _elem64;
                  _elem64 = iprot.readBinary();
                  this.rows.add(_elem64);
                }
                iprot.readListEnd();
              }
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tableName != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeBinary(this.tableName);
        oprot.writeFieldEnd();
      }
      if (this.rows != null) {
        oprot.writeFieldBegin(ROWS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.rows.size()));
          for (ByteBuffer _iter65 : this.rows)
          {
            oprot.writeBinary(_iter65);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getRows_args(");
      boolean first = true;

      sb.append("tableName:");
      if (this.tableName == null) {
        sb.append("null");
      } else {
        sb.append(this.tableName);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("rows:");
      if (this.rows == null) {
        sb.append("null");
      } else {
        sb.append(this.rows);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getRows_result implements TBase<getRows_result, getRows_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getRows_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField IO_FIELD_DESC = new TField("io", TType.STRUCT, (short)1);

    public List<TRowResult> success;
    public IOError io;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      IO((short)1, "io");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // IO
            return IO;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT,
          new ListMetaData(TType.LIST,
              new StructMetaData(TType.STRUCT, TRowResult.class))));
      tmpMap.put(_Fields.IO, new FieldMetaData("io", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getRows_result.class, metaDataMap);
    }

    public getRows_result() {
    }

    public getRows_result(
      List<TRowResult> success,
      IOError io)
    {
      this();
      this.success = success;
      this.io = io;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getRows_result(getRows_result other) {
      if (other.isSetSuccess()) {
        List<TRowResult> __this__success = new ArrayList<TRowResult>();
        for (TRowResult other_element : other.success) {
          __this__success.add(new TRowResult(other_element));
        }
        this.success = __this__success;
      }
      if (other.isSetIo()) {
        this.io = new IOError(other.io);
      }
    }

    public getRows_result deepCopy() {
      return new getRows_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.io = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<TRowResult> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(TRowResult elem) {
      if (this.success == null) {
        this.success = new ArrayList<TRowResult>();
      }
      this.success.add(elem);
    }

    public List<TRowResult> getSuccess() {
      return this.success;
    }

    public getRows_result setSuccess(List<TRowResult> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public IOError getIo() {
      return this.io;
    }

    public getRows_result setIo(IOError io) {
      this.io = io;
      return this;
    }

    public void unsetIo() {
      this.io = null;
    }

    /** Returns true if field io is set (has been asigned a value) and false otherwise */
    public boolean isSetIo() {
      return this.io != null;
    }

    public void setIoIsSet(boolean value) {
      if (!value) {
        this.io = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<TRowResult>)value);
        }
        break;

      case IO:
        if (value == null) {
          unsetIo();
        } else {
          setIo((IOError)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case IO:
        return getIo();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case IO:
        return isSetIo();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getRows_result)
        return this.equals((getRows_result)that);
      return false;
    }

    public boolean equals(getRows_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_io = true && this.isSetIo();
      boolean that_present_io = true && that.isSetIo();
      if (this_present_io || that_present_io) {
        if (!(this_present_io && that_present_io))
          return false;
        if (!this.io.equals(that.io))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getRows_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getRows_result typedOther = (getRows_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetIo()).compareTo(typedOther.isSetIo());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetIo()) {
        lastComparison = TBaseHelper.compareTo(this.io, typedOther.io);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list66 = iprot.readListBegin();
                this.success = new ArrayList<TRowResult>(_list66.size);
                for (int _i67 = 0; _i67 < _list66.size; ++_i67)
                {
                  TRowResult _elem68;
                  _elem68 = new TRowResult();
                  _elem68.read(iprot);
                  this.success.add(_elem68);
                }
                iprot.readListEnd();
              }
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // IO
            if (field.type == TType.STRUCT) {
              this.io = new IOError();
              this.io.read(iprot);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (TRowResult _iter69 : this.success)
          {
            _iter69.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetIo()) {
        oprot.writeFieldBegin(IO_FIELD_DESC);
        this.io.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getRows_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("io:");
      if (this.io == null) {
        sb.append("null");
      } else {
        sb.append(this.io);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getRowsWithColumns_args implements TBase<getRowsWithColumns_args, getRowsWithColumns_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getRowsWithColumns_args");

    private static final TField TABLE_NAME_FIELD_DESC = new TField("tableName", TType.STRING, (short)1);
    private static final TField ROWS_FIELD_DESC = new TField("rows", TType.LIST, (short)2);
    private static final TField COLUMNS_FIELD_DESC = new TField("columns", TType.LIST, (short)3);

    /**
     * name of table
     */
    public ByteBuffer tableName;
    /**
     * row keys
     */
    public List<ByteBuffer> rows;
    /**
     * List of columns to return, null for all columns
     */
    public List<ByteBuffer> columns;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      /**
       * name of table
       */
      TABLE_NAME((short)1, "tableName"),
      /**
       * row keys
       */
      ROWS((short)2, "rows"),
      /**
       * List of columns to return, null for all columns
       */
      COLUMNS((short)3, "columns");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // TABLE_NAME
            return TABLE_NAME;
          case 2: // ROWS
            return ROWS;
          case 3: // COLUMNS
            return COLUMNS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.TABLE_NAME, new FieldMetaData("tableName", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Text")));
      tmpMap.put(_Fields.ROWS, new FieldMetaData("rows", TFieldRequirementType.DEFAULT,
          new ListMetaData(TType.LIST,
              new FieldValueMetaData(TType.STRING              , "Text"))));
      tmpMap.put(_Fields.COLUMNS, new FieldMetaData("columns", TFieldRequirementType.DEFAULT,
          new ListMetaData(TType.LIST,
              new FieldValueMetaData(TType.STRING              , "Text"))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getRowsWithColumns_args.class, metaDataMap);
    }

    public getRowsWithColumns_args() {
    }

    public getRowsWithColumns_args(
      ByteBuffer tableName,
      List<ByteBuffer> rows,
      List<ByteBuffer> columns)
    {
      this();
      this.tableName = tableName;
      this.rows = rows;
      this.columns = columns;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getRowsWithColumns_args(getRowsWithColumns_args other) {
      if (other.isSetTableName()) {
        this.tableName = other.tableName;
      }
      if (other.isSetRows()) {
        List<ByteBuffer> __this__rows = new ArrayList<ByteBuffer>();
        for (ByteBuffer other_element : other.rows) {
          __this__rows.add(other_element);
        }
        this.rows = __this__rows;
      }
      if (other.isSetColumns()) {
        List<ByteBuffer> __this__columns = new ArrayList<ByteBuffer>();
        for (ByteBuffer other_element : other.columns) {
          __this__columns.add(other_element);
        }
        this.columns = __this__columns;
      }
    }

    public getRowsWithColumns_args deepCopy() {
      return new getRowsWithColumns_args(this);
    }

    @Override
    public void clear() {
      this.tableName = null;
      this.rows = null;
      this.columns = null;
    }

    /**
     * name of table
     */
    public byte[] getTableName() {
      setTableName(TBaseHelper.rightSize(tableName));
      return tableName.array();
    }

    public ByteBuffer BufferForTableName() {
      return tableName;
    }

    /**
     * name of table
     */
    public getRowsWithColumns_args setTableName(byte[] tableName) {
      setTableName(ByteBuffer.wrap(tableName));
      return this;
    }

    public getRowsWithColumns_args setTableName(ByteBuffer tableName) {
      this.tableName = tableName;
      return this;
    }

    public void unsetTableName() {
      this.tableName = null;
    }

    /** Returns true if field tableName is set (has been asigned a value) and false otherwise */
    public boolean isSetTableName() {
      return this.tableName != null;
    }

    public void setTableNameIsSet(boolean value) {
      if (!value) {
        this.tableName = null;
      }
    }

    public int getRowsSize() {
      return (this.rows == null) ? 0 : this.rows.size();
    }

    public java.util.Iterator<ByteBuffer> getRowsIterator() {
      return (this.rows == null) ? null : this.rows.iterator();
    }

    public void addToRows(ByteBuffer elem) {
      if (this.rows == null) {
        this.rows = new ArrayList<ByteBuffer>();
      }
      this.rows.add(elem);
    }

    /**
     * row keys
     */
    public List<ByteBuffer> getRows() {
      return this.rows;
    }

    /**
     * row keys
     */
    public getRowsWithColumns_args setRows(List<ByteBuffer> rows) {
      this.rows = rows;
      return this;
    }

    public void unsetRows() {
      this.rows = null;
    }

    /** Returns true if field rows is set (has been asigned a value) and false otherwise */
    public boolean isSetRows() {
      return this.rows != null;
    }

    public void setRowsIsSet(boolean value) {
      if (!value) {
        this.rows = null;
      }
    }

    public int getColumnsSize() {
      return (this.columns == null) ? 0 : this.columns.size();
    }

    public java.util.Iterator<ByteBuffer> getColumnsIterator() {
      return (this.columns == null) ? null : this.columns.iterator();
    }

    public void addToColumns(ByteBuffer elem) {
      if (this.columns == null) {
        this.columns = new ArrayList<ByteBuffer>();
      }
      this.columns.add(elem);
    }

    /**
     * List of columns to return, null for all columns
     */
    public List<ByteBuffer> getColumns() {
      return this.columns;
    }

    /**
     * List of columns to return, null for all columns
     */
    public getRowsWithColumns_args setColumns(List<ByteBuffer> columns) {
      this.columns = columns;
      return this;
    }

    public void unsetColumns() {
      this.columns = null;
    }

    /** Returns true if field columns is set (has been asigned a value) and false otherwise */
    public boolean isSetColumns() {
      return this.columns != null;
    }

    public void setColumnsIsSet(boolean value) {
      if (!value) {
        this.columns = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TABLE_NAME:
        if (value == null) {
          unsetTableName();
        } else {
          setTableName((ByteBuffer)value);
        }
        break;

      case ROWS:
        if (value == null) {
          unsetRows();
        } else {
          setRows((List<ByteBuffer>)value);
        }
        break;

      case COLUMNS:
        if (value == null) {
          unsetColumns();
        } else {
          setColumns((List<ByteBuffer>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return getTableName();

      case ROWS:
        return getRows();

      case COLUMNS:
        return getColumns();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case TABLE_NAME:
        return isSetTableName();
      case ROWS:
        return isSetRows();
      case COLUMNS:
        return isSetColumns();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getRowsWithColumns_args)
        return this.equals((getRowsWithColumns_args)that);
      return false;
    }

    public boolean equals(getRowsWithColumns_args that) {
      if (that == null)
        return false;

      boolean this_present_tableName = true && this.isSetTableName();
      boolean that_present_tableName = true && that.isSetTableName();
      if (this_present_tableName || that_present_tableName) {
        if (!(this_present_tableName && that_present_tableName))
          return false;
        if (!this.tableName.equals(that.tableName))
          return false;
      }

      boolean this_present_rows = true && this.isSetRows();
      boolean that_present_rows = true && that.isSetRows();
      if (this_present_rows || that_present_rows) {
        if (!(this_present_rows && that_present_rows))
          return false;
        if (!this.rows.equals(that.rows))
          return false;
      }

      boolean this_present_columns = true && this.isSetColumns();
      boolean that_present_columns = true && that.isSetColumns();
      if (this_present_columns || that_present_columns) {
        if (!(this_present_columns && that_present_columns))
          return false;
        if (!this.columns.equals(that.columns))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getRowsWithColumns_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getRowsWithColumns_args typedOther = (getRowsWithColumns_args)other;

      lastComparison = Boolean.valueOf(isSetTableName()).compareTo(typedOther.isSetTableName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTableName()) {
        lastComparison = TBaseHelper.compareTo(this.tableName, typedOther.tableName);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetRows()).compareTo(typedOther.isSetRows());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetRows()) {
        lastComparison = TBaseHelper.compareTo(this.rows, typedOther.rows);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetColumns()).compareTo(typedOther.isSetColumns());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetColumns()) {
        lastComparison = TBaseHelper.compareTo(this.columns, typedOther.columns);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 1: // TABLE_NAME
            if (field.type == TType.STRING) {
              this.tableName = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // ROWS
            if (field.type == TType.LIST) {
              {
                TList _list70 = iprot.readListBegin();
                this.rows = new ArrayList<ByteBuffer>(_list70.size);
                for (int _i71 = 0; _i71 < _list70.size; ++_i71)
                {
                  ByteBuffer _elem72;
                  _elem72 = iprot.readBinary();
                  this.rows.add(_elem72);
                }
                iprot.readListEnd();
              }
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // COLUMNS
            if (field.type == TType.LIST) {
              {
                TList _list73 = iprot.readListBegin();
                this.columns = new ArrayList<ByteBuffer>(_list73.size);
                for (int _i74 = 0; _i74 < _list73.size; ++_i74)
                {
                  ByteBuffer _elem75;
                  _elem75 = iprot.readBinary();
                  this.columns.add(_elem75);
                }
                iprot.readListEnd();
              }
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tableName != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeBinary(this.tableName);
        oprot.writeFieldEnd();
      }
      if (this.rows != null) {
        oprot.writeFieldBegin(ROWS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.rows.size()));
          for (ByteBuffer _iter76 : this.rows)
          {
            oprot.writeBinary(_iter76);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      if (this.columns != null) {
        oprot.writeFieldBegin(COLUMNS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.columns.size()));
          for (ByteBuffer _iter77 : this.columns)
          {
            oprot.writeBinary(_iter77);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getRowsWithColumns_args(");
      boolean first = true;

      sb.append("tableName:");
      if (this.tableName == null) {
        sb.append("null");
      } else {
        sb.append(this.tableName);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("rows:");
      if (this.rows == null) {
        sb.append("null");
      } else {
        sb.append(this.rows);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("columns:");
      if (this.columns == null) {
        sb.append("null");
      } else {
        sb.append(this.columns);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getRowsWithColumns_result implements TBase<getRowsWithColumns_result, getRowsWithColumns_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getRowsWithColumns_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField IO_FIELD_DESC = new TField("io", TType.STRUCT, (short)1);

    public List<TRowResult> success;
    public IOError io;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      IO((short)1, "io");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // IO
            return IO;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT,
          new ListMetaData(TType.LIST,
              new StructMetaData(TType.STRUCT, TRowResult.class))));
      tmpMap.put(_Fields.IO, new FieldMetaData("io", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getRowsWithColumns_result.class, metaDataMap);
    }

    public getRowsWithColumns_result() {
    }

    public getRowsWithColumns_result(
      List<TRowResult> success,
      IOError io)
    {
      this();
      this.success = success;
      this.io = io;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getRowsWithColumns_result(getRowsWithColumns_result other) {
      if (other.isSetSuccess()) {
        List<TRowResult> __this__success = new ArrayList<TRowResult>();
        for (TRowResult other_element : other.success) {
          __this__success.add(new TRowResult(other_element));
        }
        this.success = __this__success;
      }
      if (other.isSetIo()) {
        this.io = new IOError(other.io);
      }
    }

    public getRowsWithColumns_result deepCopy() {
      return new getRowsWithColumns_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.io = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<TRowResult> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(TRowResult elem) {
      if (this.success == null) {
        this.success = new ArrayList<TRowResult>();
      }
      this.success.add(elem);
    }

    public List<TRowResult> getSuccess() {
      return this.success;
    }

    public getRowsWithColumns_result setSuccess(List<TRowResult> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public IOError getIo() {
      return this.io;
    }

    public getRowsWithColumns_result setIo(IOError io) {
      this.io = io;
      return this;
    }

    public void unsetIo() {
      this.io = null;
    }

    /** Returns true if field io is set (has been asigned a value) and false otherwise */
    public boolean isSetIo() {
      return this.io != null;
    }

    public void setIoIsSet(boolean value) {
      if (!value) {
        this.io = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<TRowResult>)value);
        }
        break;

      case IO:
        if (value == null) {
          unsetIo();
        } else {
          setIo((IOError)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case IO:
        return getIo();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case IO:
        return isSetIo();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getRowsWithColumns_result)
        return this.equals((getRowsWithColumns_result)that);
      return false;
    }

    public boolean equals(getRowsWithColumns_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_io = true && this.isSetIo();
      boolean that_present_io = true && that.isSetIo();
      if (this_present_io || that_present_io) {
        if (!(this_present_io && that_present_io))
          return false;
        if (!this.io.equals(that.io))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getRowsWithColumns_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getRowsWithColumns_result typedOther = (getRowsWithColumns_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetIo()).compareTo(typedOther.isSetIo());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetIo()) {
        lastComparison = TBaseHelper.compareTo(this.io, typedOther.io);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list78 = iprot.readListBegin();
                this.success = new ArrayList<TRowResult>(_list78.size);
                for (int _i79 = 0; _i79 < _list78.size; ++_i79)
                {
                  TRowResult _elem80;
                  _elem80 = new TRowResult();
                  _elem80.read(iprot);
                  this.success.add(_elem80);
                }
                iprot.readListEnd();
              }
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // IO
            if (field.type == TType.STRUCT) {
              this.io = new IOError();
              this.io.read(iprot);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (TRowResult _iter81 : this.success)
          {
            _iter81.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetIo()) {
        oprot.writeFieldBegin(IO_FIELD_DESC);
        this.io.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getRowsWithColumns_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("io:");
      if (this.io == null) {
        sb.append("null");
      } else {
        sb.append(this.io);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getRowsTs_args implements TBase<getRowsTs_args, getRowsTs_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getRowsTs_args");

    private static final TField TABLE_NAME_FIELD_DESC = new TField("tableName", TType.STRING, (short)1);
    private static final TField ROWS_FIELD_DESC = new TField("rows", TType.LIST, (short)2);
    private static final TField TIMESTAMP_FIELD_DESC = new TField("timestamp", TType.I64, (short)3);

    /**
     * name of the table
     */
    public ByteBuffer tableName;
    /**
     * row keys
     */
    public List<ByteBuffer> rows;
    /**
     * timestamp
     */
    public long timestamp;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      /**
       * name of the table
       */
      TABLE_NAME((short)1, "tableName"),
      /**
       * row keys
       */
      ROWS((short)2, "rows"),
      /**
       * timestamp
       */
      TIMESTAMP((short)3, "timestamp");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // TABLE_NAME
            return TABLE_NAME;
          case 2: // ROWS
            return ROWS;
          case 3: // TIMESTAMP
            return TIMESTAMP;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __TIMESTAMP_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.TABLE_NAME, new FieldMetaData("tableName", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Text")));
      tmpMap.put(_Fields.ROWS, new FieldMetaData("rows", TFieldRequirementType.DEFAULT,
          new ListMetaData(TType.LIST,
              new FieldValueMetaData(TType.STRING              , "Text"))));
      tmpMap.put(_Fields.TIMESTAMP, new FieldMetaData("timestamp", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.I64)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getRowsTs_args.class, metaDataMap);
    }

    public getRowsTs_args() {
    }

    public getRowsTs_args(
      ByteBuffer tableName,
      List<ByteBuffer> rows,
      long timestamp)
    {
      this();
      this.tableName = tableName;
      this.rows = rows;
      this.timestamp = timestamp;
      setTimestampIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getRowsTs_args(getRowsTs_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      if (other.isSetTableName()) {
        this.tableName = other.tableName;
      }
      if (other.isSetRows()) {
        List<ByteBuffer> __this__rows = new ArrayList<ByteBuffer>();
        for (ByteBuffer other_element : other.rows) {
          __this__rows.add(other_element);
        }
        this.rows = __this__rows;
      }
      this.timestamp = other.timestamp;
    }

    public getRowsTs_args deepCopy() {
      return new getRowsTs_args(this);
    }

    @Override
    public void clear() {
      this.tableName = null;
      this.rows = null;
      setTimestampIsSet(false);
      this.timestamp = 0;
    }

    /**
     * name of the table
     */
    public byte[] getTableName() {
      setTableName(TBaseHelper.rightSize(tableName));
      return tableName.array();
    }

    public ByteBuffer BufferForTableName() {
      return tableName;
    }

    /**
     * name of the table
     */
    public getRowsTs_args setTableName(byte[] tableName) {
      setTableName(ByteBuffer.wrap(tableName));
      return this;
    }

    public getRowsTs_args setTableName(ByteBuffer tableName) {
      this.tableName = tableName;
      return this;
    }

    public void unsetTableName() {
      this.tableName = null;
    }

    /** Returns true if field tableName is set (has been asigned a value) and false otherwise */
    public boolean isSetTableName() {
      return this.tableName != null;
    }

    public void setTableNameIsSet(boolean value) {
      if (!value) {
        this.tableName = null;
      }
    }

    public int getRowsSize() {
      return (this.rows == null) ? 0 : this.rows.size();
    }

    public java.util.Iterator<ByteBuffer> getRowsIterator() {
      return (this.rows == null) ? null : this.rows.iterator();
    }

    public void addToRows(ByteBuffer elem) {
      if (this.rows == null) {
        this.rows = new ArrayList<ByteBuffer>();
      }
      this.rows.add(elem);
    }

    /**
     * row keys
     */
    public List<ByteBuffer> getRows() {
      return this.rows;
    }

    /**
     * row keys
     */
    public getRowsTs_args setRows(List<ByteBuffer> rows) {
      this.rows = rows;
      return this;
    }

    public void unsetRows() {
      this.rows = null;
    }

    /** Returns true if field rows is set (has been asigned a value) and false otherwise */
    public boolean isSetRows() {
      return this.rows != null;
    }

    public void setRowsIsSet(boolean value) {
      if (!value) {
        this.rows = null;
      }
    }

    /**
     * timestamp
     */
    public long getTimestamp() {
      return this.timestamp;
    }

    /**
     * timestamp
     */
    public getRowsTs_args setTimestamp(long timestamp) {
      this.timestamp = timestamp;
      setTimestampIsSet(true);
      return this;
    }

    public void unsetTimestamp() {
      __isset_bit_vector.clear(__TIMESTAMP_ISSET_ID);
    }

    /** Returns true if field timestamp is set (has been asigned a value) and false otherwise */
    public boolean isSetTimestamp() {
      return __isset_bit_vector.get(__TIMESTAMP_ISSET_ID);
    }

    public void setTimestampIsSet(boolean value) {
      __isset_bit_vector.set(__TIMESTAMP_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TABLE_NAME:
        if (value == null) {
          unsetTableName();
        } else {
          setTableName((ByteBuffer)value);
        }
        break;

      case ROWS:
        if (value == null) {
          unsetRows();
        } else {
          setRows((List<ByteBuffer>)value);
        }
        break;

      case TIMESTAMP:
        if (value == null) {
          unsetTimestamp();
        } else {
          setTimestamp((Long)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return getTableName();

      case ROWS:
        return getRows();

      case TIMESTAMP:
        return new Long(getTimestamp());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case TABLE_NAME:
        return isSetTableName();
      case ROWS:
        return isSetRows();
      case TIMESTAMP:
        return isSetTimestamp();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getRowsTs_args)
        return this.equals((getRowsTs_args)that);
      return false;
    }

    public boolean equals(getRowsTs_args that) {
      if (that == null)
        return false;

      boolean this_present_tableName = true && this.isSetTableName();
      boolean that_present_tableName = true && that.isSetTableName();
      if (this_present_tableName || that_present_tableName) {
        if (!(this_present_tableName && that_present_tableName))
          return false;
        if (!this.tableName.equals(that.tableName))
          return false;
      }

      boolean this_present_rows = true && this.isSetRows();
      boolean that_present_rows = true && that.isSetRows();
      if (this_present_rows || that_present_rows) {
        if (!(this_present_rows && that_present_rows))
          return false;
        if (!this.rows.equals(that.rows))
          return false;
      }

      boolean this_present_timestamp = true;
      boolean that_present_timestamp = true;
      if (this_present_timestamp || that_present_timestamp) {
        if (!(this_present_timestamp && that_present_timestamp))
          return false;
        if (this.timestamp != that.timestamp)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getRowsTs_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getRowsTs_args typedOther = (getRowsTs_args)other;

      lastComparison = Boolean.valueOf(isSetTableName()).compareTo(typedOther.isSetTableName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTableName()) {
        lastComparison = TBaseHelper.compareTo(this.tableName, typedOther.tableName);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetRows()).compareTo(typedOther.isSetRows());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetRows()) {
        lastComparison = TBaseHelper.compareTo(this.rows, typedOther.rows);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetTimestamp()).compareTo(typedOther.isSetTimestamp());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTimestamp()) {
        lastComparison = TBaseHelper.compareTo(this.timestamp, typedOther.timestamp);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 1: // TABLE_NAME
            if (field.type == TType.STRING) {
              this.tableName = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // ROWS
            if (field.type == TType.LIST) {
              {
                TList _list82 = iprot.readListBegin();
                this.rows = new ArrayList<ByteBuffer>(_list82.size);
                for (int _i83 = 0; _i83 < _list82.size; ++_i83)
                {
                  ByteBuffer _elem84;
                  _elem84 = iprot.readBinary();
                  this.rows.add(_elem84);
                }
                iprot.readListEnd();
              }
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // TIMESTAMP
            if (field.type == TType.I64) {
              this.timestamp = iprot.readI64();
              setTimestampIsSet(true);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tableName != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeBinary(this.tableName);
        oprot.writeFieldEnd();
      }
      if (this.rows != null) {
        oprot.writeFieldBegin(ROWS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.rows.size()));
          for (ByteBuffer _iter85 : this.rows)
          {
            oprot.writeBinary(_iter85);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(TIMESTAMP_FIELD_DESC);
      oprot.writeI64(this.timestamp);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getRowsTs_args(");
      boolean first = true;

      sb.append("tableName:");
      if (this.tableName == null) {
        sb.append("null");
      } else {
        sb.append(this.tableName);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("rows:");
      if (this.rows == null) {
        sb.append("null");
      } else {
        sb.append(this.rows);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("timestamp:");
      sb.append(this.timestamp);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getRowsTs_result implements TBase<getRowsTs_result, getRowsTs_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getRowsTs_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField IO_FIELD_DESC = new TField("io", TType.STRUCT, (short)1);

    public List<TRowResult> success;
    public IOError io;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      IO((short)1, "io");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // IO
            return IO;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT,
          new ListMetaData(TType.LIST,
              new StructMetaData(TType.STRUCT, TRowResult.class))));
      tmpMap.put(_Fields.IO, new FieldMetaData("io", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getRowsTs_result.class, metaDataMap);
    }

    public getRowsTs_result() {
    }

    public getRowsTs_result(
      List<TRowResult> success,
      IOError io)
    {
      this();
      this.success = success;
      this.io = io;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getRowsTs_result(getRowsTs_result other) {
      if (other.isSetSuccess()) {
        List<TRowResult> __this__success = new ArrayList<TRowResult>();
        for (TRowResult other_element : other.success) {
          __this__success.add(new TRowResult(other_element));
        }
        this.success = __this__success;
      }
      if (other.isSetIo()) {
        this.io = new IOError(other.io);
      }
    }

    public getRowsTs_result deepCopy() {
      return new getRowsTs_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.io = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<TRowResult> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(TRowResult elem) {
      if (this.success == null) {
        this.success = new ArrayList<TRowResult>();
      }
      this.success.add(elem);
    }

    public List<TRowResult> getSuccess() {
      return this.success;
    }

    public getRowsTs_result setSuccess(List<TRowResult> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public IOError getIo() {
      return this.io;
    }

    public getRowsTs_result setIo(IOError io) {
      this.io = io;
      return this;
    }

    public void unsetIo() {
      this.io = null;
    }

    /** Returns true if field io is set (has been asigned a value) and false otherwise */
    public boolean isSetIo() {
      return this.io != null;
    }

    public void setIoIsSet(boolean value) {
      if (!value) {
        this.io = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<TRowResult>)value);
        }
        break;

      case IO:
        if (value == null) {
          unsetIo();
        } else {
          setIo((IOError)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case IO:
        return getIo();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case IO:
        return isSetIo();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getRowsTs_result)
        return this.equals((getRowsTs_result)that);
      return false;
    }

    public boolean equals(getRowsTs_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_io = true && this.isSetIo();
      boolean that_present_io = true && that.isSetIo();
      if (this_present_io || that_present_io) {
        if (!(this_present_io && that_present_io))
          return false;
        if (!this.io.equals(that.io))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getRowsTs_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getRowsTs_result typedOther = (getRowsTs_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetIo()).compareTo(typedOther.isSetIo());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetIo()) {
        lastComparison = TBaseHelper.compareTo(this.io, typedOther.io);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list86 = iprot.readListBegin();
                this.success = new ArrayList<TRowResult>(_list86.size);
                for (int _i87 = 0; _i87 < _list86.size; ++_i87)
                {
                  TRowResult _elem88;
                  _elem88 = new TRowResult();
                  _elem88.read(iprot);
                  this.success.add(_elem88);
                }
                iprot.readListEnd();
              }
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // IO
            if (field.type == TType.STRUCT) {
              this.io = new IOError();
              this.io.read(iprot);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (TRowResult _iter89 : this.success)
          {
            _iter89.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetIo()) {
        oprot.writeFieldBegin(IO_FIELD_DESC);
        this.io.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getRowsTs_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("io:");
      if (this.io == null) {
        sb.append("null");
      } else {
        sb.append(this.io);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getRowsWithColumnsTs_args implements TBase<getRowsWithColumnsTs_args, getRowsWithColumnsTs_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getRowsWithColumnsTs_args");

    private static final TField TABLE_NAME_FIELD_DESC = new TField("tableName", TType.STRING, (short)1);
    private static final TField ROWS_FIELD_DESC = new TField("rows", TType.LIST, (short)2);
    private static final TField COLUMNS_FIELD_DESC = new TField("columns", TType.LIST, (short)3);
    private static final TField TIMESTAMP_FIELD_DESC = new TField("timestamp", TType.I64, (short)4);

    /**
     * name of table
     */
    public ByteBuffer tableName;
    /**
     * row keys
     */
    public List<ByteBuffer> rows;
    /**
     * List of columns to return, null for all columns
     */
    public List<ByteBuffer> columns;
    public long timestamp;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      /**
       * name of table
       */
      TABLE_NAME((short)1, "tableName"),
      /**
       * row keys
       */
      ROWS((short)2, "rows"),
      /**
       * List of columns to return, null for all columns
       */
      COLUMNS((short)3, "columns"),
      TIMESTAMP((short)4, "timestamp");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // TABLE_NAME
            return TABLE_NAME;
          case 2: // ROWS
            return ROWS;
          case 3: // COLUMNS
            return COLUMNS;
          case 4: // TIMESTAMP
            return TIMESTAMP;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __TIMESTAMP_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.TABLE_NAME, new FieldMetaData("tableName", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Text")));
      tmpMap.put(_Fields.ROWS, new FieldMetaData("rows", TFieldRequirementType.DEFAULT,
          new ListMetaData(TType.LIST,
              new FieldValueMetaData(TType.STRING              , "Text"))));
      tmpMap.put(_Fields.COLUMNS, new FieldMetaData("columns", TFieldRequirementType.DEFAULT,
          new ListMetaData(TType.LIST,
              new FieldValueMetaData(TType.STRING              , "Text"))));
      tmpMap.put(_Fields.TIMESTAMP, new FieldMetaData("timestamp", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.I64)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getRowsWithColumnsTs_args.class, metaDataMap);
    }

    public getRowsWithColumnsTs_args() {
    }

    public getRowsWithColumnsTs_args(
      ByteBuffer tableName,
      List<ByteBuffer> rows,
      List<ByteBuffer> columns,
      long timestamp)
    {
      this();
      this.tableName = tableName;
      this.rows = rows;
      this.columns = columns;
      this.timestamp = timestamp;
      setTimestampIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getRowsWithColumnsTs_args(getRowsWithColumnsTs_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      if (other.isSetTableName()) {
        this.tableName = other.tableName;
      }
      if (other.isSetRows()) {
        List<ByteBuffer> __this__rows = new ArrayList<ByteBuffer>();
        for (ByteBuffer other_element : other.rows) {
          __this__rows.add(other_element);
        }
        this.rows = __this__rows;
      }
      if (other.isSetColumns()) {
        List<ByteBuffer> __this__columns = new ArrayList<ByteBuffer>();
        for (ByteBuffer other_element : other.columns) {
          __this__columns.add(other_element);
        }
        this.columns = __this__columns;
      }
      this.timestamp = other.timestamp;
    }

    public getRowsWithColumnsTs_args deepCopy() {
      return new getRowsWithColumnsTs_args(this);
    }

    @Override
    public void clear() {
      this.tableName = null;
      this.rows = null;
      this.columns = null;
      setTimestampIsSet(false);
      this.timestamp = 0;
    }

    /**
     * name of table
     */
    public byte[] getTableName() {
      setTableName(TBaseHelper.rightSize(tableName));
      return tableName.array();
    }

    public ByteBuffer BufferForTableName() {
      return tableName;
    }

    /**
     * name of table
     */
    public getRowsWithColumnsTs_args setTableName(byte[] tableName) {
      setTableName(ByteBuffer.wrap(tableName));
      return this;
    }

    public getRowsWithColumnsTs_args setTableName(ByteBuffer tableName) {
      this.tableName = tableName;
      return this;
    }

    public void unsetTableName() {
      this.tableName = null;
    }

    /** Returns true if field tableName is set (has been asigned a value) and false otherwise */
    public boolean isSetTableName() {
      return this.tableName != null;
    }

    public void setTableNameIsSet(boolean value) {
      if (!value) {
        this.tableName = null;
      }
    }

    public int getRowsSize() {
      return (this.rows == null) ? 0 : this.rows.size();
    }

    public java.util.Iterator<ByteBuffer> getRowsIterator() {
      return (this.rows == null) ? null : this.rows.iterator();
    }

    public void addToRows(ByteBuffer elem) {
      if (this.rows == null) {
        this.rows = new ArrayList<ByteBuffer>();
      }
      this.rows.add(elem);
    }

    /**
     * row keys
     */
    public List<ByteBuffer> getRows() {
      return this.rows;
    }

    /**
     * row keys
     */
    public getRowsWithColumnsTs_args setRows(List<ByteBuffer> rows) {
      this.rows = rows;
      return this;
    }

    public void unsetRows() {
      this.rows = null;
    }

    /** Returns true if field rows is set (has been asigned a value) and false otherwise */
    public boolean isSetRows() {
      return this.rows != null;
    }

    public void setRowsIsSet(boolean value) {
      if (!value) {
        this.rows = null;
      }
    }

    public int getColumnsSize() {
      return (this.columns == null) ? 0 : this.columns.size();
    }

    public java.util.Iterator<ByteBuffer> getColumnsIterator() {
      return (this.columns == null) ? null : this.columns.iterator();
    }

    public void addToColumns(ByteBuffer elem) {
      if (this.columns == null) {
        this.columns = new ArrayList<ByteBuffer>();
      }
      this.columns.add(elem);
    }

    /**
     * List of columns to return, null for all columns
     */
    public List<ByteBuffer> getColumns() {
      return this.columns;
    }

    /**
     * List of columns to return, null for all columns
     */
    public getRowsWithColumnsTs_args setColumns(List<ByteBuffer> columns) {
      this.columns = columns;
      return this;
    }

    public void unsetColumns() {
      this.columns = null;
    }

    /** Returns true if field columns is set (has been asigned a value) and false otherwise */
    public boolean isSetColumns() {
      return this.columns != null;
    }

    public void setColumnsIsSet(boolean value) {
      if (!value) {
        this.columns = null;
      }
    }

    public long getTimestamp() {
      return this.timestamp;
    }

    public getRowsWithColumnsTs_args setTimestamp(long timestamp) {
      this.timestamp = timestamp;
      setTimestampIsSet(true);
      return this;
    }

    public void unsetTimestamp() {
      __isset_bit_vector.clear(__TIMESTAMP_ISSET_ID);
    }

    /** Returns true if field timestamp is set (has been asigned a value) and false otherwise */
    public boolean isSetTimestamp() {
      return __isset_bit_vector.get(__TIMESTAMP_ISSET_ID);
    }

    public void setTimestampIsSet(boolean value) {
      __isset_bit_vector.set(__TIMESTAMP_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TABLE_NAME:
        if (value == null) {
          unsetTableName();
        } else {
          setTableName((ByteBuffer)value);
        }
        break;

      case ROWS:
        if (value == null) {
          unsetRows();
        } else {
          setRows((List<ByteBuffer>)value);
        }
        break;

      case COLUMNS:
        if (value == null) {
          unsetColumns();
        } else {
          setColumns((List<ByteBuffer>)value);
        }
        break;

      case TIMESTAMP:
        if (value == null) {
          unsetTimestamp();
        } else {
          setTimestamp((Long)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return getTableName();

      case ROWS:
        return getRows();

      case COLUMNS:
        return getColumns();

      case TIMESTAMP:
        return new Long(getTimestamp());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case TABLE_NAME:
        return isSetTableName();
      case ROWS:
        return isSetRows();
      case COLUMNS:
        return isSetColumns();
      case TIMESTAMP:
        return isSetTimestamp();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getRowsWithColumnsTs_args)
        return this.equals((getRowsWithColumnsTs_args)that);
      return false;
    }

    public boolean equals(getRowsWithColumnsTs_args that) {
      if (that == null)
        return false;

      boolean this_present_tableName = true && this.isSetTableName();
      boolean that_present_tableName = true && that.isSetTableName();
      if (this_present_tableName || that_present_tableName) {
        if (!(this_present_tableName && that_present_tableName))
          return false;
        if (!this.tableName.equals(that.tableName))
          return false;
      }

      boolean this_present_rows = true && this.isSetRows();
      boolean that_present_rows = true && that.isSetRows();
      if (this_present_rows || that_present_rows) {
        if (!(this_present_rows && that_present_rows))
          return false;
        if (!this.rows.equals(that.rows))
          return false;
      }

      boolean this_present_columns = true && this.isSetColumns();
      boolean that_present_columns = true && that.isSetColumns();
      if (this_present_columns || that_present_columns) {
        if (!(this_present_columns && that_present_columns))
          return false;
        if (!this.columns.equals(that.columns))
          return false;
      }

      boolean this_present_timestamp = true;
      boolean that_present_timestamp = true;
      if (this_present_timestamp || that_present_timestamp) {
        if (!(this_present_timestamp && that_present_timestamp))
          return false;
        if (this.timestamp != that.timestamp)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getRowsWithColumnsTs_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getRowsWithColumnsTs_args typedOther = (getRowsWithColumnsTs_args)other;

      lastComparison = Boolean.valueOf(isSetTableName()).compareTo(typedOther.isSetTableName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTableName()) {
        lastComparison = TBaseHelper.compareTo(this.tableName, typedOther.tableName);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetRows()).compareTo(typedOther.isSetRows());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetRows()) {
        lastComparison = TBaseHelper.compareTo(this.rows, typedOther.rows);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetColumns()).compareTo(typedOther.isSetColumns());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetColumns()) {
        lastComparison = TBaseHelper.compareTo(this.columns, typedOther.columns);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetTimestamp()).compareTo(typedOther.isSetTimestamp());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTimestamp()) {
        lastComparison = TBaseHelper.compareTo(this.timestamp, typedOther.timestamp);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 1: // TABLE_NAME
            if (field.type == TType.STRING) {
              this.tableName = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // ROWS
            if (field.type == TType.LIST) {
              {
                TList _list90 = iprot.readListBegin();
                this.rows = new ArrayList<ByteBuffer>(_list90.size);
                for (int _i91 = 0; _i91 < _list90.size; ++_i91)
                {
                  ByteBuffer _elem92;
                  _elem92 = iprot.readBinary();
                  this.rows.add(_elem92);
                }
                iprot.readListEnd();
              }
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // COLUMNS
            if (field.type == TType.LIST) {
              {
                TList _list93 = iprot.readListBegin();
                this.columns = new ArrayList<ByteBuffer>(_list93.size);
                for (int _i94 = 0; _i94 < _list93.size; ++_i94)
                {
                  ByteBuffer _elem95;
                  _elem95 = iprot.readBinary();
                  this.columns.add(_elem95);
                }
                iprot.readListEnd();
              }
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 4: // TIMESTAMP
            if (field.type == TType.I64) {
              this.timestamp = iprot.readI64();
              setTimestampIsSet(true);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tableName != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeBinary(this.tableName);
        oprot.writeFieldEnd();
      }
      if (this.rows != null) {
        oprot.writeFieldBegin(ROWS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.rows.size()));
          for (ByteBuffer _iter96 : this.rows)
          {
            oprot.writeBinary(_iter96);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      if (this.columns != null) {
        oprot.writeFieldBegin(COLUMNS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.columns.size()));
          for (ByteBuffer _iter97 : this.columns)
          {
            oprot.writeBinary(_iter97);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(TIMESTAMP_FIELD_DESC);
      oprot.writeI64(this.timestamp);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getRowsWithColumnsTs_args(");
      boolean first = true;

      sb.append("tableName:");
      if (this.tableName == null) {
        sb.append("null");
      } else {
        sb.append(this.tableName);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("rows:");
      if (this.rows == null) {
        sb.append("null");
      } else {
        sb.append(this.rows);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("columns:");
      if (this.columns == null) {
        sb.append("null");
      } else {
        sb.append(this.columns);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("timestamp:");
      sb.append(this.timestamp);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getRowsWithColumnsTs_result implements TBase<getRowsWithColumnsTs_result, getRowsWithColumnsTs_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getRowsWithColumnsTs_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField IO_FIELD_DESC = new TField("io", TType.STRUCT, (short)1);

    public List<TRowResult> success;
    public IOError io;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      IO((short)1, "io");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // IO
            return IO;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT,
          new ListMetaData(TType.LIST,
              new StructMetaData(TType.STRUCT, TRowResult.class))));
      tmpMap.put(_Fields.IO, new FieldMetaData("io", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getRowsWithColumnsTs_result.class, metaDataMap);
    }

    public getRowsWithColumnsTs_result() {
    }

    public getRowsWithColumnsTs_result(
      List<TRowResult> success,
      IOError io)
    {
      this();
      this.success = success;
      this.io = io;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getRowsWithColumnsTs_result(getRowsWithColumnsTs_result other) {
      if (other.isSetSuccess()) {
        List<TRowResult> __this__success = new ArrayList<TRowResult>();
        for (TRowResult other_element : other.success) {
          __this__success.add(new TRowResult(other_element));
        }
        this.success = __this__success;
      }
      if (other.isSetIo()) {
        this.io = new IOError(other.io);
      }
    }

    public getRowsWithColumnsTs_result deepCopy() {
      return new getRowsWithColumnsTs_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.io = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<TRowResult> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(TRowResult elem) {
      if (this.success == null) {
        this.success = new ArrayList<TRowResult>();
      }
      this.success.add(elem);
    }

    public List<TRowResult> getSuccess() {
      return this.success;
    }

    public getRowsWithColumnsTs_result setSuccess(List<TRowResult> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public IOError getIo() {
      return this.io;
    }

    public getRowsWithColumnsTs_result setIo(IOError io) {
      this.io = io;
      return this;
    }

    public void unsetIo() {
      this.io = null;
    }

    /** Returns true if field io is set (has been asigned a value) and false otherwise */
    public boolean isSetIo() {
      return this.io != null;
    }

    public void setIoIsSet(boolean value) {
      if (!value) {
        this.io = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<TRowResult>)value);
        }
        break;

      case IO:
        if (value == null) {
          unsetIo();
        } else {
          setIo((IOError)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case IO:
        return getIo();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case IO:
        return isSetIo();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getRowsWithColumnsTs_result)
        return this.equals((getRowsWithColumnsTs_result)that);
      return false;
    }

    public boolean equals(getRowsWithColumnsTs_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_io = true && this.isSetIo();
      boolean that_present_io = true && that.isSetIo();
      if (this_present_io || that_present_io) {
        if (!(this_present_io && that_present_io))
          return false;
        if (!this.io.equals(that.io))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getRowsWithColumnsTs_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getRowsWithColumnsTs_result typedOther = (getRowsWithColumnsTs_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetIo()).compareTo(typedOther.isSetIo());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetIo()) {
        lastComparison = TBaseHelper.compareTo(this.io, typedOther.io);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list98 = iprot.readListBegin();
                this.success = new ArrayList<TRowResult>(_list98.size);
                for (int _i99 = 0; _i99 < _list98.size; ++_i99)
                {
                  TRowResult _elem100;
                  _elem100 = new TRowResult();
                  _elem100.read(iprot);
                  this.success.add(_elem100);
                }
                iprot.readListEnd();
              }
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // IO
            if (field.type == TType.STRUCT) {
              this.io = new IOError();
              this.io.read(iprot);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (TRowResult _iter101 : this.success)
          {
            _iter101.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetIo()) {
        oprot.writeFieldBegin(IO_FIELD_DESC);
        this.io.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getRowsWithColumnsTs_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("io:");
      if (this.io == null) {
        sb.append("null");
      } else {
        sb.append(this.io);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class mutateRow_args implements TBase<mutateRow_args, mutateRow_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("mutateRow_args");

    private static final TField TABLE_NAME_FIELD_DESC = new TField("tableName", TType.STRING, (short)1);
    private static final TField ROW_FIELD_DESC = new TField("row", TType.STRING, (short)2);
    private static final TField MUTATIONS_FIELD_DESC = new TField("mutations", TType.LIST, (short)3);

    /**
     * name of table
     */
    public ByteBuffer tableName;
    /**
     * row key
     */
    public ByteBuffer row;
    /**
     * list of mutation commands
     */
    public List<Mutation> mutations;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      /**
       * name of table
       */
      TABLE_NAME((short)1, "tableName"),
      /**
       * row key
       */
      ROW((short)2, "row"),
      /**
       * list of mutation commands
       */
      MUTATIONS((short)3, "mutations");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // TABLE_NAME
            return TABLE_NAME;
          case 2: // ROW
            return ROW;
          case 3: // MUTATIONS
            return MUTATIONS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.TABLE_NAME, new FieldMetaData("tableName", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Text")));
      tmpMap.put(_Fields.ROW, new FieldMetaData("row", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Text")));
      tmpMap.put(_Fields.MUTATIONS, new FieldMetaData("mutations", TFieldRequirementType.DEFAULT,
          new ListMetaData(TType.LIST,
              new StructMetaData(TType.STRUCT, Mutation.class))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(mutateRow_args.class, metaDataMap);
    }

    public mutateRow_args() {
    }

    public mutateRow_args(
      ByteBuffer tableName,
      ByteBuffer row,
      List<Mutation> mutations)
    {
      this();
      this.tableName = tableName;
      this.row = row;
      this.mutations = mutations;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public mutateRow_args(mutateRow_args other) {
      if (other.isSetTableName()) {
        this.tableName = other.tableName;
      }
      if (other.isSetRow()) {
        this.row = other.row;
      }
      if (other.isSetMutations()) {
        List<Mutation> __this__mutations = new ArrayList<Mutation>();
        for (Mutation other_element : other.mutations) {
          __this__mutations.add(new Mutation(other_element));
        }
        this.mutations = __this__mutations;
      }
    }

    public mutateRow_args deepCopy() {
      return new mutateRow_args(this);
    }

    @Override
    public void clear() {
      this.tableName = null;
      this.row = null;
      this.mutations = null;
    }

    /**
     * name of table
     */
    public byte[] getTableName() {
      setTableName(TBaseHelper.rightSize(tableName));
      return tableName.array();
    }

    public ByteBuffer BufferForTableName() {
      return tableName;
    }

    /**
     * name of table
     */
    public mutateRow_args setTableName(byte[] tableName) {
      setTableName(ByteBuffer.wrap(tableName));
      return this;
    }

    public mutateRow_args setTableName(ByteBuffer tableName) {
      this.tableName = tableName;
      return this;
    }

    public void unsetTableName() {
      this.tableName = null;
    }

    /** Returns true if field tableName is set (has been asigned a value) and false otherwise */
    public boolean isSetTableName() {
      return this.tableName != null;
    }

    public void setTableNameIsSet(boolean value) {
      if (!value) {
        this.tableName = null;
      }
    }

    /**
     * row key
     */
    public byte[] getRow() {
      setRow(TBaseHelper.rightSize(row));
      return row.array();
    }

    public ByteBuffer BufferForRow() {
      return row;
    }

    /**
     * row key
     */
    public mutateRow_args setRow(byte[] row) {
      setRow(ByteBuffer.wrap(row));
      return this;
    }

    public mutateRow_args setRow(ByteBuffer row) {
      this.row = row;
      return this;
    }

    public void unsetRow() {
      this.row = null;
    }

    /** Returns true if field row is set (has been asigned a value) and false otherwise */
    public boolean isSetRow() {
      return this.row != null;
    }

    public void setRowIsSet(boolean value) {
      if (!value) {
        this.row = null;
      }
    }

    public int getMutationsSize() {
      return (this.mutations == null) ? 0 : this.mutations.size();
    }

    public java.util.Iterator<Mutation> getMutationsIterator() {
      return (this.mutations == null) ? null : this.mutations.iterator();
    }

    public void addToMutations(Mutation elem) {
      if (this.mutations == null) {
        this.mutations = new ArrayList<Mutation>();
      }
      this.mutations.add(elem);
    }

    /**
     * list of mutation commands
     */
    public List<Mutation> getMutations() {
      return this.mutations;
    }

    /**
     * list of mutation commands
     */
    public mutateRow_args setMutations(List<Mutation> mutations) {
      this.mutations = mutations;
      return this;
    }

    public void unsetMutations() {
      this.mutations = null;
    }

    /** Returns true if field mutations is set (has been asigned a value) and false otherwise */
    public boolean isSetMutations() {
      return this.mutations != null;
    }

    public void setMutationsIsSet(boolean value) {
      if (!value) {
        this.mutations = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TABLE_NAME:
        if (value == null) {
          unsetTableName();
        } else {
          setTableName((ByteBuffer)value);
        }
        break;

      case ROW:
        if (value == null) {
          unsetRow();
        } else {
          setRow((ByteBuffer)value);
        }
        break;

      case MUTATIONS:
        if (value == null) {
          unsetMutations();
        } else {
          setMutations((List<Mutation>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return getTableName();

      case ROW:
        return getRow();

      case MUTATIONS:
        return getMutations();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case TABLE_NAME:
        return isSetTableName();
      case ROW:
        return isSetRow();
      case MUTATIONS:
        return isSetMutations();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof mutateRow_args)
        return this.equals((mutateRow_args)that);
      return false;
    }

    public boolean equals(mutateRow_args that) {
      if (that == null)
        return false;

      boolean this_present_tableName = true && this.isSetTableName();
      boolean that_present_tableName = true && that.isSetTableName();
      if (this_present_tableName || that_present_tableName) {
        if (!(this_present_tableName && that_present_tableName))
          return false;
        if (!this.tableName.equals(that.tableName))
          return false;
      }

      boolean this_present_row = true && this.isSetRow();
      boolean that_present_row = true && that.isSetRow();
      if (this_present_row || that_present_row) {
        if (!(this_present_row && that_present_row))
          return false;
        if (!this.row.equals(that.row))
          return false;
      }

      boolean this_present_mutations = true && this.isSetMutations();
      boolean that_present_mutations = true && that.isSetMutations();
      if (this_present_mutations || that_present_mutations) {
        if (!(this_present_mutations && that_present_mutations))
          return false;
        if (!this.mutations.equals(that.mutations))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(mutateRow_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      mutateRow_args typedOther = (mutateRow_args)other;

      lastComparison = Boolean.valueOf(isSetTableName()).compareTo(typedOther.isSetTableName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTableName()) {
        lastComparison = TBaseHelper.compareTo(this.tableName, typedOther.tableName);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetRow()).compareTo(typedOther.isSetRow());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetRow()) {
        lastComparison = TBaseHelper.compareTo(this.row, typedOther.row);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetMutations()).compareTo(typedOther.isSetMutations());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetMutations()) {
        lastComparison = TBaseHelper.compareTo(this.mutations, typedOther.mutations);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 1: // TABLE_NAME
            if (field.type == TType.STRING) {
              this.tableName = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // ROW
            if (field.type == TType.STRING) {
              this.row = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // MUTATIONS
            if (field.type == TType.LIST) {
              {
                TList _list102 = iprot.readListBegin();
                this.mutations = new ArrayList<Mutation>(_list102.size);
                for (int _i103 = 0; _i103 < _list102.size; ++_i103)
                {
                  Mutation _elem104;
                  _elem104 = new Mutation();
                  _elem104.read(iprot);
                  this.mutations.add(_elem104);
                }
                iprot.readListEnd();
              }
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tableName != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeBinary(this.tableName);
        oprot.writeFieldEnd();
      }
      if (this.row != null) {
        oprot.writeFieldBegin(ROW_FIELD_DESC);
        oprot.writeBinary(this.row);
        oprot.writeFieldEnd();
      }
      if (this.mutations != null) {
        oprot.writeFieldBegin(MUTATIONS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.mutations.size()));
          for (Mutation _iter105 : this.mutations)
          {
            _iter105.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("mutateRow_args(");
      boolean first = true;

      sb.append("tableName:");
      if (this.tableName == null) {
        sb.append("null");
      } else {
        sb.append(this.tableName);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("row:");
      if (this.row == null) {
        sb.append("null");
      } else {
        sb.append(this.row);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("mutations:");
      if (this.mutations == null) {
        sb.append("null");
      } else {
        sb.append(this.mutations);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class mutateRow_result implements TBase<mutateRow_result, mutateRow_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("mutateRow_result");

    private static final TField IO_FIELD_DESC = new TField("io", TType.STRUCT, (short)1);
    private static final TField IA_FIELD_DESC = new TField("ia", TType.STRUCT, (short)2);

    public IOError io;
    public IllegalArgument ia;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      IO((short)1, "io"),
      IA((short)2, "ia");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // IO
            return IO;
          case 2: // IA
            return IA;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.IO, new FieldMetaData("io", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRUCT)));
      tmpMap.put(_Fields.IA, new FieldMetaData("ia", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(mutateRow_result.class, metaDataMap);
    }

    public mutateRow_result() {
    }

    public mutateRow_result(
      IOError io,
      IllegalArgument ia)
    {
      this();
      this.io = io;
      this.ia = ia;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public mutateRow_result(mutateRow_result other) {
      if (other.isSetIo()) {
        this.io = new IOError(other.io);
      }
      if (other.isSetIa()) {
        this.ia = new IllegalArgument(other.ia);
      }
    }

    public mutateRow_result deepCopy() {
      return new mutateRow_result(this);
    }

    @Override
    public void clear() {
      this.io = null;
      this.ia = null;
    }

    public IOError getIo() {
      return this.io;
    }

    public mutateRow_result setIo(IOError io) {
      this.io = io;
      return this;
    }

    public void unsetIo() {
      this.io = null;
    }

    /** Returns true if field io is set (has been asigned a value) and false otherwise */
    public boolean isSetIo() {
      return this.io != null;
    }

    public void setIoIsSet(boolean value) {
      if (!value) {
        this.io = null;
      }
    }

    public IllegalArgument getIa() {
      return this.ia;
    }

    public mutateRow_result setIa(IllegalArgument ia) {
      this.ia = ia;
      return this;
    }

    public void unsetIa() {
      this.ia = null;
    }

    /** Returns true if field ia is set (has been asigned a value) and false otherwise */
    public boolean isSetIa() {
      return this.ia != null;
    }

    public void setIaIsSet(boolean value) {
      if (!value) {
        this.ia = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case IO:
        if (value == null) {
          unsetIo();
        } else {
          setIo((IOError)value);
        }
        break;

      case IA:
        if (value == null) {
          unsetIa();
        } else {
          setIa((IllegalArgument)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case IO:
        return getIo();

      case IA:
        return getIa();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case IO:
        return isSetIo();
      case IA:
        return isSetIa();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof mutateRow_result)
        return this.equals((mutateRow_result)that);
      return false;
    }

    public boolean equals(mutateRow_result that) {
      if (that == null)
        return false;

      boolean this_present_io = true && this.isSetIo();
      boolean that_present_io = true && that.isSetIo();
      if (this_present_io || that_present_io) {
        if (!(this_present_io && that_present_io))
          return false;
        if (!this.io.equals(that.io))
          return false;
      }

      boolean this_present_ia = true && this.isSetIa();
      boolean that_present_ia = true && that.isSetIa();
      if (this_present_ia || that_present_ia) {
        if (!(this_present_ia && that_present_ia))
          return false;
        if (!this.ia.equals(that.ia))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(mutateRow_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      mutateRow_result typedOther = (mutateRow_result)other;

      lastComparison = Boolean.valueOf(isSetIo()).compareTo(typedOther.isSetIo());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetIo()) {
        lastComparison = TBaseHelper.compareTo(this.io, typedOther.io);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetIa()).compareTo(typedOther.isSetIa());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetIa()) {
        lastComparison = TBaseHelper.compareTo(this.ia, typedOther.ia);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 1: // IO
            if (field.type == TType.STRUCT) {
              this.io = new IOError();
              this.io.read(iprot);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // IA
            if (field.type == TType.STRUCT) {
              this.ia = new IllegalArgument();
              this.ia.read(iprot);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetIo()) {
        oprot.writeFieldBegin(IO_FIELD_DESC);
        this.io.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetIa()) {
        oprot.writeFieldBegin(IA_FIELD_DESC);
        this.ia.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("mutateRow_result(");
      boolean first = true;

      sb.append("io:");
      if (this.io == null) {
        sb.append("null");
      } else {
        sb.append(this.io);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ia:");
      if (this.ia == null) {
        sb.append("null");
      } else {
        sb.append(this.ia);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class mutateRowTs_args implements TBase<mutateRowTs_args, mutateRowTs_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("mutateRowTs_args");

    private static final TField TABLE_NAME_FIELD_DESC = new TField("tableName", TType.STRING, (short)1);
    private static final TField ROW_FIELD_DESC = new TField("row", TType.STRING, (short)2);
    private static final TField MUTATIONS_FIELD_DESC = new TField("mutations", TType.LIST, (short)3);
    private static final TField TIMESTAMP_FIELD_DESC = new TField("timestamp", TType.I64, (short)4);

    /**
     * name of table
     */
    public ByteBuffer tableName;
    /**
     * row key
     */
    public ByteBuffer row;
    /**
     * list of mutation commands
     */
    public List<Mutation> mutations;
    /**
     * timestamp
     */
    public long timestamp;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      /**
       * name of table
       */
      TABLE_NAME((short)1, "tableName"),
      /**
       * row key
       */
      ROW((short)2, "row"),
      /**
       * list of mutation commands
       */
      MUTATIONS((short)3, "mutations"),
      /**
       * timestamp
       */
      TIMESTAMP((short)4, "timestamp");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // TABLE_NAME
            return TABLE_NAME;
          case 2: // ROW
            return ROW;
          case 3: // MUTATIONS
            return MUTATIONS;
          case 4: // TIMESTAMP
            return TIMESTAMP;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __TIMESTAMP_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.TABLE_NAME, new FieldMetaData("tableName", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Text")));
      tmpMap.put(_Fields.ROW, new FieldMetaData("row", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Text")));
      tmpMap.put(_Fields.MUTATIONS, new FieldMetaData("mutations", TFieldRequirementType.DEFAULT,
          new ListMetaData(TType.LIST,
              new StructMetaData(TType.STRUCT, Mutation.class))));
      tmpMap.put(_Fields.TIMESTAMP, new FieldMetaData("timestamp", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.I64)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(mutateRowTs_args.class, metaDataMap);
    }

    public mutateRowTs_args() {
    }

    public mutateRowTs_args(
      ByteBuffer tableName,
      ByteBuffer row,
      List<Mutation> mutations,
      long timestamp)
    {
      this();
      this.tableName = tableName;
      this.row = row;
      this.mutations = mutations;
      this.timestamp = timestamp;
      setTimestampIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public mutateRowTs_args(mutateRowTs_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      if (other.isSetTableName()) {
        this.tableName = other.tableName;
      }
      if (other.isSetRow()) {
        this.row = other.row;
      }
      if (other.isSetMutations()) {
        List<Mutation> __this__mutations = new ArrayList<Mutation>();
        for (Mutation other_element : other.mutations) {
          __this__mutations.add(new Mutation(other_element));
        }
        this.mutations = __this__mutations;
      }
      this.timestamp = other.timestamp;
    }

    public mutateRowTs_args deepCopy() {
      return new mutateRowTs_args(this);
    }

    @Override
    public void clear() {
      this.tableName = null;
      this.row = null;
      this.mutations = null;
      setTimestampIsSet(false);
      this.timestamp = 0;
    }

    /**
     * name of table
     */
    public byte[] getTableName() {
      setTableName(TBaseHelper.rightSize(tableName));
      return tableName.array();
    }

    public ByteBuffer BufferForTableName() {
      return tableName;
    }

    /**
     * name of table
     */
    public mutateRowTs_args setTableName(byte[] tableName) {
      setTableName(ByteBuffer.wrap(tableName));
      return this;
    }

    public mutateRowTs_args setTableName(ByteBuffer tableName) {
      this.tableName = tableName;
      return this;
    }

    public void unsetTableName() {
      this.tableName = null;
    }

    /** Returns true if field tableName is set (has been asigned a value) and false otherwise */
    public boolean isSetTableName() {
      return this.tableName != null;
    }

    public void setTableNameIsSet(boolean value) {
      if (!value) {
        this.tableName = null;
      }
    }

    /**
     * row key
     */
    public byte[] getRow() {
      setRow(TBaseHelper.rightSize(row));
      return row.array();
    }

    public ByteBuffer BufferForRow() {
      return row;
    }

    /**
     * row key
     */
    public mutateRowTs_args setRow(byte[] row) {
      setRow(ByteBuffer.wrap(row));
      return this;
    }

    public mutateRowTs_args setRow(ByteBuffer row) {
      this.row = row;
      return this;
    }

    public void unsetRow() {
      this.row = null;
    }

    /** Returns true if field row is set (has been asigned a value) and false otherwise */
    public boolean isSetRow() {
      return this.row != null;
    }

    public void setRowIsSet(boolean value) {
      if (!value) {
        this.row = null;
      }
    }

    public int getMutationsSize() {
      return (this.mutations == null) ? 0 : this.mutations.size();
    }

    public java.util.Iterator<Mutation> getMutationsIterator() {
      return (this.mutations == null) ? null : this.mutations.iterator();
    }

    public void addToMutations(Mutation elem) {
      if (this.mutations == null) {
        this.mutations = new ArrayList<Mutation>();
      }
      this.mutations.add(elem);
    }

    /**
     * list of mutation commands
     */
    public List<Mutation> getMutations() {
      return this.mutations;
    }

    /**
     * list of mutation commands
     */
    public mutateRowTs_args setMutations(List<Mutation> mutations) {
      this.mutations = mutations;
      return this;
    }

    public void unsetMutations() {
      this.mutations = null;
    }

    /** Returns true if field mutations is set (has been asigned a value) and false otherwise */
    public boolean isSetMutations() {
      return this.mutations != null;
    }

    public void setMutationsIsSet(boolean value) {
      if (!value) {
        this.mutations = null;
      }
    }

    /**
     * timestamp
     */
    public long getTimestamp() {
      return this.timestamp;
    }

    /**
     * timestamp
     */
    public mutateRowTs_args setTimestamp(long timestamp) {
      this.timestamp = timestamp;
      setTimestampIsSet(true);
      return this;
    }

    public void unsetTimestamp() {
      __isset_bit_vector.clear(__TIMESTAMP_ISSET_ID);
    }

    /** Returns true if field timestamp is set (has been asigned a value) and false otherwise */
    public boolean isSetTimestamp() {
      return __isset_bit_vector.get(__TIMESTAMP_ISSET_ID);
    }

    public void setTimestampIsSet(boolean value) {
      __isset_bit_vector.set(__TIMESTAMP_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TABLE_NAME:
        if (value == null) {
          unsetTableName();
        } else {
          setTableName((ByteBuffer)value);
        }
        break;

      case ROW:
        if (value == null) {
          unsetRow();
        } else {
          setRow((ByteBuffer)value);
        }
        break;

      case MUTATIONS:
        if (value == null) {
          unsetMutations();
        } else {
          setMutations((List<Mutation>)value);
        }
        break;

      case TIMESTAMP:
        if (value == null) {
          unsetTimestamp();
        } else {
          setTimestamp((Long)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return getTableName();

      case ROW:
        return getRow();

      case MUTATIONS:
        return getMutations();

      case TIMESTAMP:
        return new Long(getTimestamp());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case TABLE_NAME:
        return isSetTableName();
      case ROW:
        return isSetRow();
      case MUTATIONS:
        return isSetMutations();
      case TIMESTAMP:
        return isSetTimestamp();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof mutateRowTs_args)
        return this.equals((mutateRowTs_args)that);
      return false;
    }

    public boolean equals(mutateRowTs_args that) {
      if (that == null)
        return false;

      boolean this_present_tableName = true && this.isSetTableName();
      boolean that_present_tableName = true && that.isSetTableName();
      if (this_present_tableName || that_present_tableName) {
        if (!(this_present_tableName && that_present_tableName))
          return false;
        if (!this.tableName.equals(that.tableName))
          return false;
      }

      boolean this_present_row = true && this.isSetRow();
      boolean that_present_row = true && that.isSetRow();
      if (this_present_row || that_present_row) {
        if (!(this_present_row && that_present_row))
          return false;
        if (!this.row.equals(that.row))
          return false;
      }

      boolean this_present_mutations = true && this.isSetMutations();
      boolean that_present_mutations = true && that.isSetMutations();
      if (this_present_mutations || that_present_mutations) {
        if (!(this_present_mutations && that_present_mutations))
          return false;
        if (!this.mutations.equals(that.mutations))
          return false;
      }

      boolean this_present_timestamp = true;
      boolean that_present_timestamp = true;
      if (this_present_timestamp || that_present_timestamp) {
        if (!(this_present_timestamp && that_present_timestamp))
          return false;
        if (this.timestamp != that.timestamp)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(mutateRowTs_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      mutateRowTs_args typedOther = (mutateRowTs_args)other;

      lastComparison = Boolean.valueOf(isSetTableName()).compareTo(typedOther.isSetTableName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTableName()) {
        lastComparison = TBaseHelper.compareTo(this.tableName, typedOther.tableName);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetRow()).compareTo(typedOther.isSetRow());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetRow()) {
        lastComparison = TBaseHelper.compareTo(this.row, typedOther.row);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetMutations()).compareTo(typedOther.isSetMutations());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetMutations()) {
        lastComparison = TBaseHelper.compareTo(this.mutations, typedOther.mutations);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetTimestamp()).compareTo(typedOther.isSetTimestamp());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTimestamp()) {
        lastComparison = TBaseHelper.compareTo(this.timestamp, typedOther.timestamp);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 1: // TABLE_NAME
            if (field.type == TType.STRING) {
              this.tableName = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // ROW
            if (field.type == TType.STRING) {
              this.row = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // MUTATIONS
            if (field.type == TType.LIST) {
              {
                TList _list106 = iprot.readListBegin();
                this.mutations = new ArrayList<Mutation>(_list106.size);
                for (int _i107 = 0; _i107 < _list106.size; ++_i107)
                {
                  Mutation _elem108;
                  _elem108 = new Mutation();
                  _elem108.read(iprot);
                  this.mutations.add(_elem108);
                }
                iprot.readListEnd();
              }
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 4: // TIMESTAMP
            if (field.type == TType.I64) {
              this.timestamp = iprot.readI64();
              setTimestampIsSet(true);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tableName != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeBinary(this.tableName);
        oprot.writeFieldEnd();
      }
      if (this.row != null) {
        oprot.writeFieldBegin(ROW_FIELD_DESC);
        oprot.writeBinary(this.row);
        oprot.writeFieldEnd();
      }
      if (this.mutations != null) {
        oprot.writeFieldBegin(MUTATIONS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.mutations.size()));
          for (Mutation _iter109 : this.mutations)
          {
            _iter109.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(TIMESTAMP_FIELD_DESC);
      oprot.writeI64(this.timestamp);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("mutateRowTs_args(");
      boolean first = true;

      sb.append("tableName:");
      if (this.tableName == null) {
        sb.append("null");
      } else {
        sb.append(this.tableName);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("row:");
      if (this.row == null) {
        sb.append("null");
      } else {
        sb.append(this.row);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("mutations:");
      if (this.mutations == null) {
        sb.append("null");
      } else {
        sb.append(this.mutations);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("timestamp:");
      sb.append(this.timestamp);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class mutateRowTs_result implements TBase<mutateRowTs_result, mutateRowTs_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("mutateRowTs_result");

    private static final TField IO_FIELD_DESC = new TField("io", TType.STRUCT, (short)1);
    private static final TField IA_FIELD_DESC = new TField("ia", TType.STRUCT, (short)2);

    public IOError io;
    public IllegalArgument ia;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      IO((short)1, "io"),
      IA((short)2, "ia");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // IO
            return IO;
          case 2: // IA
            return IA;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.IO, new FieldMetaData("io", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRUCT)));
      tmpMap.put(_Fields.IA, new FieldMetaData("ia", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(mutateRowTs_result.class, metaDataMap);
    }

    public mutateRowTs_result() {
    }

    public mutateRowTs_result(
      IOError io,
      IllegalArgument ia)
    {
      this();
      this.io = io;
      this.ia = ia;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public mutateRowTs_result(mutateRowTs_result other) {
      if (other.isSetIo()) {
        this.io = new IOError(other.io);
      }
      if (other.isSetIa()) {
        this.ia = new IllegalArgument(other.ia);
      }
    }

    public mutateRowTs_result deepCopy() {
      return new mutateRowTs_result(this);
    }

    @Override
    public void clear() {
      this.io = null;
      this.ia = null;
    }

    public IOError getIo() {
      return this.io;
    }

    public mutateRowTs_result setIo(IOError io) {
      this.io = io;
      return this;
    }

    public void unsetIo() {
      this.io = null;
    }

    /** Returns true if field io is set (has been asigned a value) and false otherwise */
    public boolean isSetIo() {
      return this.io != null;
    }

    public void setIoIsSet(boolean value) {
      if (!value) {
        this.io = null;
      }
    }

    public IllegalArgument getIa() {
      return this.ia;
    }

    public mutateRowTs_result setIa(IllegalArgument ia) {
      this.ia = ia;
      return this;
    }

    public void unsetIa() {
      this.ia = null;
    }

    /** Returns true if field ia is set (has been asigned a value) and false otherwise */
    public boolean isSetIa() {
      return this.ia != null;
    }

    public void setIaIsSet(boolean value) {
      if (!value) {
        this.ia = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case IO:
        if (value == null) {
          unsetIo();
        } else {
          setIo((IOError)value);
        }
        break;

      case IA:
        if (value == null) {
          unsetIa();
        } else {
          setIa((IllegalArgument)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case IO:
        return getIo();

      case IA:
        return getIa();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case IO:
        return isSetIo();
      case IA:
        return isSetIa();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof mutateRowTs_result)
        return this.equals((mutateRowTs_result)that);
      return false;
    }

    public boolean equals(mutateRowTs_result that) {
      if (that == null)
        return false;

      boolean this_present_io = true && this.isSetIo();
      boolean that_present_io = true && that.isSetIo();
      if (this_present_io || that_present_io) {
        if (!(this_present_io && that_present_io))
          return false;
        if (!this.io.equals(that.io))
          return false;
      }

      boolean this_present_ia = true && this.isSetIa();
      boolean that_present_ia = true && that.isSetIa();
      if (this_present_ia || that_present_ia) {
        if (!(this_present_ia && that_present_ia))
          return false;
        if (!this.ia.equals(that.ia))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(mutateRowTs_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      mutateRowTs_result typedOther = (mutateRowTs_result)other;

      lastComparison = Boolean.valueOf(isSetIo()).compareTo(typedOther.isSetIo());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetIo()) {
        lastComparison = TBaseHelper.compareTo(this.io, typedOther.io);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetIa()).compareTo(typedOther.isSetIa());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetIa()) {
        lastComparison = TBaseHelper.compareTo(this.ia, typedOther.ia);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 1: // IO
            if (field.type == TType.STRUCT) {
              this.io = new IOError();
              this.io.read(iprot);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // IA
            if (field.type == TType.STRUCT) {
              this.ia = new IllegalArgument();
              this.ia.read(iprot);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetIo()) {
        oprot.writeFieldBegin(IO_FIELD_DESC);
        this.io.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetIa()) {
        oprot.writeFieldBegin(IA_FIELD_DESC);
        this.ia.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("mutateRowTs_result(");
      boolean first = true;

      sb.append("io:");
      if (this.io == null) {
        sb.append("null");
      } else {
        sb.append(this.io);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ia:");
      if (this.ia == null) {
        sb.append("null");
      } else {
        sb.append(this.ia);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class mutateRows_args implements TBase<mutateRows_args, mutateRows_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("mutateRows_args");

    private static final TField TABLE_NAME_FIELD_DESC = new TField("tableName", TType.STRING, (short)1);
    private static final TField ROW_BATCHES_FIELD_DESC = new TField("rowBatches", TType.LIST, (short)2);

    /**
     * name of table
     */
    public ByteBuffer tableName;
    /**
     * list of row batches
     */
    public List<BatchMutation> rowBatches;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      /**
       * name of table
       */
      TABLE_NAME((short)1, "tableName"),
      /**
       * list of row batches
       */
      ROW_BATCHES((short)2, "rowBatches");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // TABLE_NAME
            return TABLE_NAME;
          case 2: // ROW_BATCHES
            return ROW_BATCHES;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.TABLE_NAME, new FieldMetaData("tableName", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Text")));
      tmpMap.put(_Fields.ROW_BATCHES, new FieldMetaData("rowBatches", TFieldRequirementType.DEFAULT,
          new ListMetaData(TType.LIST,
              new StructMetaData(TType.STRUCT, BatchMutation.class))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(mutateRows_args.class, metaDataMap);
    }

    public mutateRows_args() {
    }

    public mutateRows_args(
      ByteBuffer tableName,
      List<BatchMutation> rowBatches)
    {
      this();
      this.tableName = tableName;
      this.rowBatches = rowBatches;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public mutateRows_args(mutateRows_args other) {
      if (other.isSetTableName()) {
        this.tableName = other.tableName;
      }
      if (other.isSetRowBatches()) {
        List<BatchMutation> __this__rowBatches = new ArrayList<BatchMutation>();
        for (BatchMutation other_element : other.rowBatches) {
          __this__rowBatches.add(new BatchMutation(other_element));
        }
        this.rowBatches = __this__rowBatches;
      }
    }

    public mutateRows_args deepCopy() {
      return new mutateRows_args(this);
    }

    @Override
    public void clear() {
      this.tableName = null;
      this.rowBatches = null;
    }

    /**
     * name of table
     */
    public byte[] getTableName() {
      setTableName(TBaseHelper.rightSize(tableName));
      return tableName.array();
    }

    public ByteBuffer BufferForTableName() {
      return tableName;
    }

    /**
     * name of table
     */
    public mutateRows_args setTableName(byte[] tableName) {
      setTableName(ByteBuffer.wrap(tableName));
      return this;
    }

    public mutateRows_args setTableName(ByteBuffer tableName) {
      this.tableName = tableName;
      return this;
    }

    public void unsetTableName() {
      this.tableName = null;
    }

    /** Returns true if field tableName is set (has been asigned a value) and false otherwise */
    public boolean isSetTableName() {
      return this.tableName != null;
    }

    public void setTableNameIsSet(boolean value) {
      if (!value) {
        this.tableName = null;
      }
    }

    public int getRowBatchesSize() {
      return (this.rowBatches == null) ? 0 : this.rowBatches.size();
    }

    public java.util.Iterator<BatchMutation> getRowBatchesIterator() {
      return (this.rowBatches == null) ? null : this.rowBatches.iterator();
    }

    public void addToRowBatches(BatchMutation elem) {
      if (this.rowBatches == null) {
        this.rowBatches = new ArrayList<BatchMutation>();
      }
      this.rowBatches.add(elem);
    }

    /**
     * list of row batches
     */
    public List<BatchMutation> getRowBatches() {
      return this.rowBatches;
    }

    /**
     * list of row batches
     */
    public mutateRows_args setRowBatches(List<BatchMutation> rowBatches) {
      this.rowBatches = rowBatches;
      return this;
    }

    public void unsetRowBatches() {
      this.rowBatches = null;
    }

    /** Returns true if field rowBatches is set (has been asigned a value) and false otherwise */
    public boolean isSetRowBatches() {
      return this.rowBatches != null;
    }

    public void setRowBatchesIsSet(boolean value) {
      if (!value) {
        this.rowBatches = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TABLE_NAME:
        if (value == null) {
          unsetTableName();
        } else {
          setTableName((ByteBuffer)value);
        }
        break;

      case ROW_BATCHES:
        if (value == null) {
          unsetRowBatches();
        } else {
          setRowBatches((List<BatchMutation>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return getTableName();

      case ROW_BATCHES:
        return getRowBatches();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case TABLE_NAME:
        return isSetTableName();
      case ROW_BATCHES:
        return isSetRowBatches();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof mutateRows_args)
        return this.equals((mutateRows_args)that);
      return false;
    }

    public boolean equals(mutateRows_args that) {
      if (that == null)
        return false;

      boolean this_present_tableName = true && this.isSetTableName();
      boolean that_present_tableName = true && that.isSetTableName();
      if (this_present_tableName || that_present_tableName) {
        if (!(this_present_tableName && that_present_tableName))
          return false;
        if (!this.tableName.equals(that.tableName))
          return false;
      }

      boolean this_present_rowBatches = true && this.isSetRowBatches();
      boolean that_present_rowBatches = true && that.isSetRowBatches();
      if (this_present_rowBatches || that_present_rowBatches) {
        if (!(this_present_rowBatches && that_present_rowBatches))
          return false;
        if (!this.rowBatches.equals(that.rowBatches))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(mutateRows_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      mutateRows_args typedOther = (mutateRows_args)other;

      lastComparison = Boolean.valueOf(isSetTableName()).compareTo(typedOther.isSetTableName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTableName()) {
        lastComparison = TBaseHelper.compareTo(this.tableName, typedOther.tableName);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetRowBatches()).compareTo(typedOther.isSetRowBatches());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetRowBatches()) {
        lastComparison = TBaseHelper.compareTo(this.rowBatches, typedOther.rowBatches);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 1: // TABLE_NAME
            if (field.type == TType.STRING) {
              this.tableName = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // ROW_BATCHES
            if (field.type == TType.LIST) {
              {
                TList _list110 = iprot.readListBegin();
                this.rowBatches = new ArrayList<BatchMutation>(_list110.size);
                for (int _i111 = 0; _i111 < _list110.size; ++_i111)
                {
                  BatchMutation _elem112;
                  _elem112 = new BatchMutation();
                  _elem112.read(iprot);
                  this.rowBatches.add(_elem112);
                }
                iprot.readListEnd();
              }
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tableName != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeBinary(this.tableName);
        oprot.writeFieldEnd();
      }
      if (this.rowBatches != null) {
        oprot.writeFieldBegin(ROW_BATCHES_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.rowBatches.size()));
          for (BatchMutation _iter113 : this.rowBatches)
          {
            _iter113.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("mutateRows_args(");
      boolean first = true;

      sb.append("tableName:");
      if (this.tableName == null) {
        sb.append("null");
      } else {
        sb.append(this.tableName);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("rowBatches:");
      if (this.rowBatches == null) {
        sb.append("null");
      } else {
        sb.append(this.rowBatches);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class mutateRows_result implements TBase<mutateRows_result, mutateRows_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("mutateRows_result");

    private static final TField IO_FIELD_DESC = new TField("io", TType.STRUCT, (short)1);
    private static final TField IA_FIELD_DESC = new TField("ia", TType.STRUCT, (short)2);

    public IOError io;
    public IllegalArgument ia;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      IO((short)1, "io"),
      IA((short)2, "ia");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // IO
            return IO;
          case 2: // IA
            return IA;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.IO, new FieldMetaData("io", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRUCT)));
      tmpMap.put(_Fields.IA, new FieldMetaData("ia", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(mutateRows_result.class, metaDataMap);
    }

    public mutateRows_result() {
    }

    public mutateRows_result(
      IOError io,
      IllegalArgument ia)
    {
      this();
      this.io = io;
      this.ia = ia;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public mutateRows_result(mutateRows_result other) {
      if (other.isSetIo()) {
        this.io = new IOError(other.io);
      }
      if (other.isSetIa()) {
        this.ia = new IllegalArgument(other.ia);
      }
    }

    public mutateRows_result deepCopy() {
      return new mutateRows_result(this);
    }

    @Override
    public void clear() {
      this.io = null;
      this.ia = null;
    }

    public IOError getIo() {
      return this.io;
    }

    public mutateRows_result setIo(IOError io) {
      this.io = io;
      return this;
    }

    public void unsetIo() {
      this.io = null;
    }

    /** Returns true if field io is set (has been asigned a value) and false otherwise */
    public boolean isSetIo() {
      return this.io != null;
    }

    public void setIoIsSet(boolean value) {
      if (!value) {
        this.io = null;
      }
    }

    public IllegalArgument getIa() {
      return this.ia;
    }

    public mutateRows_result setIa(IllegalArgument ia) {
      this.ia = ia;
      return this;
    }

    public void unsetIa() {
      this.ia = null;
    }

    /** Returns true if field ia is set (has been asigned a value) and false otherwise */
    public boolean isSetIa() {
      return this.ia != null;
    }

    public void setIaIsSet(boolean value) {
      if (!value) {
        this.ia = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case IO:
        if (value == null) {
          unsetIo();
        } else {
          setIo((IOError)value);
        }
        break;

      case IA:
        if (value == null) {
          unsetIa();
        } else {
          setIa((IllegalArgument)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case IO:
        return getIo();

      case IA:
        return getIa();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case IO:
        return isSetIo();
      case IA:
        return isSetIa();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof mutateRows_result)
        return this.equals((mutateRows_result)that);
      return false;
    }

    public boolean equals(mutateRows_result that) {
      if (that == null)
        return false;

      boolean this_present_io = true && this.isSetIo();
      boolean that_present_io = true && that.isSetIo();
      if (this_present_io || that_present_io) {
        if (!(this_present_io && that_present_io))
          return false;
        if (!this.io.equals(that.io))
          return false;
      }

      boolean this_present_ia = true && this.isSetIa();
      boolean that_present_ia = true && that.isSetIa();
      if (this_present_ia || that_present_ia) {
        if (!(this_present_ia && that_present_ia))
          return false;
        if (!this.ia.equals(that.ia))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(mutateRows_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      mutateRows_result typedOther = (mutateRows_result)other;

      lastComparison = Boolean.valueOf(isSetIo()).compareTo(typedOther.isSetIo());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetIo()) {
        lastComparison = TBaseHelper.compareTo(this.io, typedOther.io);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetIa()).compareTo(typedOther.isSetIa());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetIa()) {
        lastComparison = TBaseHelper.compareTo(this.ia, typedOther.ia);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 1: // IO
            if (field.type == TType.STRUCT) {
              this.io = new IOError();
              this.io.read(iprot);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // IA
            if (field.type == TType.STRUCT) {
              this.ia = new IllegalArgument();
              this.ia.read(iprot);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetIo()) {
        oprot.writeFieldBegin(IO_FIELD_DESC);
        this.io.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetIa()) {
        oprot.writeFieldBegin(IA_FIELD_DESC);
        this.ia.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("mutateRows_result(");
      boolean first = true;

      sb.append("io:");
      if (this.io == null) {
        sb.append("null");
      } else {
        sb.append(this.io);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ia:");
      if (this.ia == null) {
        sb.append("null");
      } else {
        sb.append(this.ia);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class mutateRowsTs_args implements TBase<mutateRowsTs_args, mutateRowsTs_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("mutateRowsTs_args");

    private static final TField TABLE_NAME_FIELD_DESC = new TField("tableName", TType.STRING, (short)1);
    private static final TField ROW_BATCHES_FIELD_DESC = new TField("rowBatches", TType.LIST, (short)2);
    private static final TField TIMESTAMP_FIELD_DESC = new TField("timestamp", TType.I64, (short)3);

    /**
     * name of table
     */
    public ByteBuffer tableName;
    /**
     * list of row batches
     */
    public List<BatchMutation> rowBatches;
    /**
     * timestamp
     */
    public long timestamp;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      /**
       * name of table
       */
      TABLE_NAME((short)1, "tableName"),
      /**
       * list of row batches
       */
      ROW_BATCHES((short)2, "rowBatches"),
      /**
       * timestamp
       */
      TIMESTAMP((short)3, "timestamp");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // TABLE_NAME
            return TABLE_NAME;
          case 2: // ROW_BATCHES
            return ROW_BATCHES;
          case 3: // TIMESTAMP
            return TIMESTAMP;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __TIMESTAMP_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.TABLE_NAME, new FieldMetaData("tableName", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Text")));
      tmpMap.put(_Fields.ROW_BATCHES, new FieldMetaData("rowBatches", TFieldRequirementType.DEFAULT,
          new ListMetaData(TType.LIST,
              new StructMetaData(TType.STRUCT, BatchMutation.class))));
      tmpMap.put(_Fields.TIMESTAMP, new FieldMetaData("timestamp", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.I64)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(mutateRowsTs_args.class, metaDataMap);
    }

    public mutateRowsTs_args() {
    }

    public mutateRowsTs_args(
      ByteBuffer tableName,
      List<BatchMutation> rowBatches,
      long timestamp)
    {
      this();
      this.tableName = tableName;
      this.rowBatches = rowBatches;
      this.timestamp = timestamp;
      setTimestampIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public mutateRowsTs_args(mutateRowsTs_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      if (other.isSetTableName()) {
        this.tableName = other.tableName;
      }
      if (other.isSetRowBatches()) {
        List<BatchMutation> __this__rowBatches = new ArrayList<BatchMutation>();
        for (BatchMutation other_element : other.rowBatches) {
          __this__rowBatches.add(new BatchMutation(other_element));
        }
        this.rowBatches = __this__rowBatches;
      }
      this.timestamp = other.timestamp;
    }

    public mutateRowsTs_args deepCopy() {
      return new mutateRowsTs_args(this);
    }

    @Override
    public void clear() {
      this.tableName = null;
      this.rowBatches = null;
      setTimestampIsSet(false);
      this.timestamp = 0;
    }

    /**
     * name of table
     */
    public byte[] getTableName() {
      setTableName(TBaseHelper.rightSize(tableName));
      return tableName.array();
    }

    public ByteBuffer BufferForTableName() {
      return tableName;
    }

    /**
     * name of table
     */
    public mutateRowsTs_args setTableName(byte[] tableName) {
      setTableName(ByteBuffer.wrap(tableName));
      return this;
    }

    public mutateRowsTs_args setTableName(ByteBuffer tableName) {
      this.tableName = tableName;
      return this;
    }

    public void unsetTableName() {
      this.tableName = null;
    }

    /** Returns true if field tableName is set (has been asigned a value) and false otherwise */
    public boolean isSetTableName() {
      return this.tableName != null;
    }

    public void setTableNameIsSet(boolean value) {
      if (!value) {
        this.tableName = null;
      }
    }

    public int getRowBatchesSize() {
      return (this.rowBatches == null) ? 0 : this.rowBatches.size();
    }

    public java.util.Iterator<BatchMutation> getRowBatchesIterator() {
      return (this.rowBatches == null) ? null : this.rowBatches.iterator();
    }

    public void addToRowBatches(BatchMutation elem) {
      if (this.rowBatches == null) {
        this.rowBatches = new ArrayList<BatchMutation>();
      }
      this.rowBatches.add(elem);
    }

    /**
     * list of row batches
     */
    public List<BatchMutation> getRowBatches() {
      return this.rowBatches;
    }

    /**
     * list of row batches
     */
    public mutateRowsTs_args setRowBatches(List<BatchMutation> rowBatches) {
      this.rowBatches = rowBatches;
      return this;
    }

    public void unsetRowBatches() {
      this.rowBatches = null;
    }

    /** Returns true if field rowBatches is set (has been asigned a value) and false otherwise */
    public boolean isSetRowBatches() {
      return this.rowBatches != null;
    }

    public void setRowBatchesIsSet(boolean value) {
      if (!value) {
        this.rowBatches = null;
      }
    }

    /**
     * timestamp
     */
    public long getTimestamp() {
      return this.timestamp;
    }

    /**
     * timestamp
     */
    public mutateRowsTs_args setTimestamp(long timestamp) {
      this.timestamp = timestamp;
      setTimestampIsSet(true);
      return this;
    }

    public void unsetTimestamp() {
      __isset_bit_vector.clear(__TIMESTAMP_ISSET_ID);
    }

    /** Returns true if field timestamp is set (has been asigned a value) and false otherwise */
    public boolean isSetTimestamp() {
      return __isset_bit_vector.get(__TIMESTAMP_ISSET_ID);
    }

    public void setTimestampIsSet(boolean value) {
      __isset_bit_vector.set(__TIMESTAMP_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TABLE_NAME:
        if (value == null) {
          unsetTableName();
        } else {
          setTableName((ByteBuffer)value);
        }
        break;

      case ROW_BATCHES:
        if (value == null) {
          unsetRowBatches();
        } else {
          setRowBatches((List<BatchMutation>)value);
        }
        break;

      case TIMESTAMP:
        if (value == null) {
          unsetTimestamp();
        } else {
          setTimestamp((Long)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return getTableName();

      case ROW_BATCHES:
        return getRowBatches();

      case TIMESTAMP:
        return new Long(getTimestamp());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case TABLE_NAME:
        return isSetTableName();
      case ROW_BATCHES:
        return isSetRowBatches();
      case TIMESTAMP:
        return isSetTimestamp();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof mutateRowsTs_args)
        return this.equals((mutateRowsTs_args)that);
      return false;
    }

    public boolean equals(mutateRowsTs_args that) {
      if (that == null)
        return false;

      boolean this_present_tableName = true && this.isSetTableName();
      boolean that_present_tableName = true && that.isSetTableName();
      if (this_present_tableName || that_present_tableName) {
        if (!(this_present_tableName && that_present_tableName))
          return false;
        if (!this.tableName.equals(that.tableName))
          return false;
      }

      boolean this_present_rowBatches = true && this.isSetRowBatches();
      boolean that_present_rowBatches = true && that.isSetRowBatches();
      if (this_present_rowBatches || that_present_rowBatches) {
        if (!(this_present_rowBatches && that_present_rowBatches))
          return false;
        if (!this.rowBatches.equals(that.rowBatches))
          return false;
      }

      boolean this_present_timestamp = true;
      boolean that_present_timestamp = true;
      if (this_present_timestamp || that_present_timestamp) {
        if (!(this_present_timestamp && that_present_timestamp))
          return false;
        if (this.timestamp != that.timestamp)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(mutateRowsTs_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      mutateRowsTs_args typedOther = (mutateRowsTs_args)other;

      lastComparison = Boolean.valueOf(isSetTableName()).compareTo(typedOther.isSetTableName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTableName()) {
        lastComparison = TBaseHelper.compareTo(this.tableName, typedOther.tableName);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetRowBatches()).compareTo(typedOther.isSetRowBatches());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetRowBatches()) {
        lastComparison = TBaseHelper.compareTo(this.rowBatches, typedOther.rowBatches);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetTimestamp()).compareTo(typedOther.isSetTimestamp());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTimestamp()) {
        lastComparison = TBaseHelper.compareTo(this.timestamp, typedOther.timestamp);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 1: // TABLE_NAME
            if (field.type == TType.STRING) {
              this.tableName = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // ROW_BATCHES
            if (field.type == TType.LIST) {
              {
                TList _list114 = iprot.readListBegin();
                this.rowBatches = new ArrayList<BatchMutation>(_list114.size);
                for (int _i115 = 0; _i115 < _list114.size; ++_i115)
                {
                  BatchMutation _elem116;
                  _elem116 = new BatchMutation();
                  _elem116.read(iprot);
                  this.rowBatches.add(_elem116);
                }
                iprot.readListEnd();
              }
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // TIMESTAMP
            if (field.type == TType.I64) {
              this.timestamp = iprot.readI64();
              setTimestampIsSet(true);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tableName != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeBinary(this.tableName);
        oprot.writeFieldEnd();
      }
      if (this.rowBatches != null) {
        oprot.writeFieldBegin(ROW_BATCHES_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.rowBatches.size()));
          for (BatchMutation _iter117 : this.rowBatches)
          {
            _iter117.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(TIMESTAMP_FIELD_DESC);
      oprot.writeI64(this.timestamp);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("mutateRowsTs_args(");
      boolean first = true;

      sb.append("tableName:");
      if (this.tableName == null) {
        sb.append("null");
      } else {
        sb.append(this.tableName);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("rowBatches:");
      if (this.rowBatches == null) {
        sb.append("null");
      } else {
        sb.append(this.rowBatches);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("timestamp:");
      sb.append(this.timestamp);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class mutateRowsTs_result implements TBase<mutateRowsTs_result, mutateRowsTs_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("mutateRowsTs_result");

    private static final TField IO_FIELD_DESC = new TField("io", TType.STRUCT, (short)1);
    private static final TField IA_FIELD_DESC = new TField("ia", TType.STRUCT, (short)2);

    public IOError io;
    public IllegalArgument ia;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      IO((short)1, "io"),
      IA((short)2, "ia");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // IO
            return IO;
          case 2: // IA
            return IA;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.IO, new FieldMetaData("io", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRUCT)));
      tmpMap.put(_Fields.IA, new FieldMetaData("ia", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(mutateRowsTs_result.class, metaDataMap);
    }

    public mutateRowsTs_result() {
    }

    public mutateRowsTs_result(
      IOError io,
      IllegalArgument ia)
    {
      this();
      this.io = io;
      this.ia = ia;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public mutateRowsTs_result(mutateRowsTs_result other) {
      if (other.isSetIo()) {
        this.io = new IOError(other.io);
      }
      if (other.isSetIa()) {
        this.ia = new IllegalArgument(other.ia);
      }
    }

    public mutateRowsTs_result deepCopy() {
      return new mutateRowsTs_result(this);
    }

    @Override
    public void clear() {
      this.io = null;
      this.ia = null;
    }

    public IOError getIo() {
      return this.io;
    }

    public mutateRowsTs_result setIo(IOError io) {
      this.io = io;
      return this;
    }

    public void unsetIo() {
      this.io = null;
    }

    /** Returns true if field io is set (has been asigned a value) and false otherwise */
    public boolean isSetIo() {
      return this.io != null;
    }

    public void setIoIsSet(boolean value) {
      if (!value) {
        this.io = null;
      }
    }

    public IllegalArgument getIa() {
      return this.ia;
    }

    public mutateRowsTs_result setIa(IllegalArgument ia) {
      this.ia = ia;
      return this;
    }

    public void unsetIa() {
      this.ia = null;
    }

    /** Returns true if field ia is set (has been asigned a value) and false otherwise */
    public boolean isSetIa() {
      return this.ia != null;
    }

    public void setIaIsSet(boolean value) {
      if (!value) {
        this.ia = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case IO:
        if (value == null) {
          unsetIo();
        } else {
          setIo((IOError)value);
        }
        break;

      case IA:
        if (value == null) {
          unsetIa();
        } else {
          setIa((IllegalArgument)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case IO:
        return getIo();

      case IA:
        return getIa();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case IO:
        return isSetIo();
      case IA:
        return isSetIa();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof mutateRowsTs_result)
        return this.equals((mutateRowsTs_result)that);
      return false;
    }

    public boolean equals(mutateRowsTs_result that) {
      if (that == null)
        return false;

      boolean this_present_io = true && this.isSetIo();
      boolean that_present_io = true && that.isSetIo();
      if (this_present_io || that_present_io) {
        if (!(this_present_io && that_present_io))
          return false;
        if (!this.io.equals(that.io))
          return false;
      }

      boolean this_present_ia = true && this.isSetIa();
      boolean that_present_ia = true && that.isSetIa();
      if (this_present_ia || that_present_ia) {
        if (!(this_present_ia && that_present_ia))
          return false;
        if (!this.ia.equals(that.ia))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(mutateRowsTs_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      mutateRowsTs_result typedOther = (mutateRowsTs_result)other;

      lastComparison = Boolean.valueOf(isSetIo()).compareTo(typedOther.isSetIo());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetIo()) {
        lastComparison = TBaseHelper.compareTo(this.io, typedOther.io);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetIa()).compareTo(typedOther.isSetIa());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetIa()) {
        lastComparison = TBaseHelper.compareTo(this.ia, typedOther.ia);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 1: // IO
            if (field.type == TType.STRUCT) {
              this.io = new IOError();
              this.io.read(iprot);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // IA
            if (field.type == TType.STRUCT) {
              this.ia = new IllegalArgument();
              this.ia.read(iprot);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetIo()) {
        oprot.writeFieldBegin(IO_FIELD_DESC);
        this.io.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetIa()) {
        oprot.writeFieldBegin(IA_FIELD_DESC);
        this.ia.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("mutateRowsTs_result(");
      boolean first = true;

      sb.append("io:");
      if (this.io == null) {
        sb.append("null");
      } else {
        sb.append(this.io);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ia:");
      if (this.ia == null) {
        sb.append("null");
      } else {
        sb.append(this.ia);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class atomicIncrement_args implements TBase<atomicIncrement_args, atomicIncrement_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("atomicIncrement_args");

    private static final TField TABLE_NAME_FIELD_DESC = new TField("tableName", TType.STRING, (short)1);
    private static final TField ROW_FIELD_DESC = new TField("row", TType.STRING, (short)2);
    private static final TField COLUMN_FIELD_DESC = new TField("column", TType.STRING, (short)3);
    private static final TField VALUE_FIELD_DESC = new TField("value", TType.I64, (short)4);

    /**
     * name of table
     */
    public ByteBuffer tableName;
    /**
     * row to increment
     */
    public ByteBuffer row;
    /**
     * name of column
     */
    public ByteBuffer column;
    /**
     * amount to increment by
     */
    public long value;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      /**
       * name of table
       */
      TABLE_NAME((short)1, "tableName"),
      /**
       * row to increment
       */
      ROW((short)2, "row"),
      /**
       * name of column
       */
      COLUMN((short)3, "column"),
      /**
       * amount to increment by
       */
      VALUE((short)4, "value");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // TABLE_NAME
            return TABLE_NAME;
          case 2: // ROW
            return ROW;
          case 3: // COLUMN
            return COLUMN;
          case 4: // VALUE
            return VALUE;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __VALUE_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.TABLE_NAME, new FieldMetaData("tableName", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Text")));
      tmpMap.put(_Fields.ROW, new FieldMetaData("row", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Text")));
      tmpMap.put(_Fields.COLUMN, new FieldMetaData("column", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Text")));
      tmpMap.put(_Fields.VALUE, new FieldMetaData("value", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.I64)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(atomicIncrement_args.class, metaDataMap);
    }

    public atomicIncrement_args() {
    }

    public atomicIncrement_args(
      ByteBuffer tableName,
      ByteBuffer row,
      ByteBuffer column,
      long value)
    {
      this();
      this.tableName = tableName;
      this.row = row;
      this.column = column;
      this.value = value;
      setValueIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public atomicIncrement_args(atomicIncrement_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      if (other.isSetTableName()) {
        this.tableName = other.tableName;
      }
      if (other.isSetRow()) {
        this.row = other.row;
      }
      if (other.isSetColumn()) {
        this.column = other.column;
      }
      this.value = other.value;
    }

    public atomicIncrement_args deepCopy() {
      return new atomicIncrement_args(this);
    }

    @Override
    public void clear() {
      this.tableName = null;
      this.row = null;
      this.column = null;
      setValueIsSet(false);
      this.value = 0;
    }

    /**
     * name of table
     */
    public byte[] getTableName() {
      setTableName(TBaseHelper.rightSize(tableName));
      return tableName.array();
    }

    public ByteBuffer BufferForTableName() {
      return tableName;
    }

    /**
     * name of table
     */
    public atomicIncrement_args setTableName(byte[] tableName) {
      setTableName(ByteBuffer.wrap(tableName));
      return this;
    }

    public atomicIncrement_args setTableName(ByteBuffer tableName) {
      this.tableName = tableName;
      return this;
    }

    public void unsetTableName() {
      this.tableName = null;
    }

    /** Returns true if field tableName is set (has been asigned a value) and false otherwise */
    public boolean isSetTableName() {
      return this.tableName != null;
    }

    public void setTableNameIsSet(boolean value) {
      if (!value) {
        this.tableName = null;
      }
    }

    /**
     * row to increment
     */
    public byte[] getRow() {
      setRow(TBaseHelper.rightSize(row));
      return row.array();
    }

    public ByteBuffer BufferForRow() {
      return row;
    }

    /**
     * row to increment
     */
    public atomicIncrement_args setRow(byte[] row) {
      setRow(ByteBuffer.wrap(row));
      return this;
    }

    public atomicIncrement_args setRow(ByteBuffer row) {
      this.row = row;
      return this;
    }

    public void unsetRow() {
      this.row = null;
    }

    /** Returns true if field row is set (has been asigned a value) and false otherwise */
    public boolean isSetRow() {
      return this.row != null;
    }

    public void setRowIsSet(boolean value) {
      if (!value) {
        this.row = null;
      }
    }

    /**
     * name of column
     */
    public byte[] getColumn() {
      setColumn(TBaseHelper.rightSize(column));
      return column.array();
    }

    public ByteBuffer BufferForColumn() {
      return column;
    }

    /**
     * name of column
     */
    public atomicIncrement_args setColumn(byte[] column) {
      setColumn(ByteBuffer.wrap(column));
      return this;
    }

    public atomicIncrement_args setColumn(ByteBuffer column) {
      this.column = column;
      return this;
    }

    public void unsetColumn() {
      this.column = null;
    }

    /** Returns true if field column is set (has been asigned a value) and false otherwise */
    public boolean isSetColumn() {
      return this.column != null;
    }

    public void setColumnIsSet(boolean value) {
      if (!value) {
        this.column = null;
      }
    }

    /**
     * amount to increment by
     */
    public long getValue() {
      return this.value;
    }

    /**
     * amount to increment by
     */
    public atomicIncrement_args setValue(long value) {
      this.value = value;
      setValueIsSet(true);
      return this;
    }

    public void unsetValue() {
      __isset_bit_vector.clear(__VALUE_ISSET_ID);
    }

    /** Returns true if field value is set (has been asigned a value) and false otherwise */
    public boolean isSetValue() {
      return __isset_bit_vector.get(__VALUE_ISSET_ID);
    }

    public void setValueIsSet(boolean value) {
      __isset_bit_vector.set(__VALUE_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TABLE_NAME:
        if (value == null) {
          unsetTableName();
        } else {
          setTableName((ByteBuffer)value);
        }
        break;

      case ROW:
        if (value == null) {
          unsetRow();
        } else {
          setRow((ByteBuffer)value);
        }
        break;

      case COLUMN:
        if (value == null) {
          unsetColumn();
        } else {
          setColumn((ByteBuffer)value);
        }
        break;

      case VALUE:
        if (value == null) {
          unsetValue();
        } else {
          setValue((Long)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return getTableName();

      case ROW:
        return getRow();

      case COLUMN:
        return getColumn();

      case VALUE:
        return new Long(getValue());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case TABLE_NAME:
        return isSetTableName();
      case ROW:
        return isSetRow();
      case COLUMN:
        return isSetColumn();
      case VALUE:
        return isSetValue();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof atomicIncrement_args)
        return this.equals((atomicIncrement_args)that);
      return false;
    }

    public boolean equals(atomicIncrement_args that) {
      if (that == null)
        return false;

      boolean this_present_tableName = true && this.isSetTableName();
      boolean that_present_tableName = true && that.isSetTableName();
      if (this_present_tableName || that_present_tableName) {
        if (!(this_present_tableName && that_present_tableName))
          return false;
        if (!this.tableName.equals(that.tableName))
          return false;
      }

      boolean this_present_row = true && this.isSetRow();
      boolean that_present_row = true && that.isSetRow();
      if (this_present_row || that_present_row) {
        if (!(this_present_row && that_present_row))
          return false;
        if (!this.row.equals(that.row))
          return false;
      }

      boolean this_present_column = true && this.isSetColumn();
      boolean that_present_column = true && that.isSetColumn();
      if (this_present_column || that_present_column) {
        if (!(this_present_column && that_present_column))
          return false;
        if (!this.column.equals(that.column))
          return false;
      }

      boolean this_present_value = true;
      boolean that_present_value = true;
      if (this_present_value || that_present_value) {
        if (!(this_present_value && that_present_value))
          return false;
        if (this.value != that.value)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(atomicIncrement_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      atomicIncrement_args typedOther = (atomicIncrement_args)other;

      lastComparison = Boolean.valueOf(isSetTableName()).compareTo(typedOther.isSetTableName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTableName()) {
        lastComparison = TBaseHelper.compareTo(this.tableName, typedOther.tableName);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetRow()).compareTo(typedOther.isSetRow());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetRow()) {
        lastComparison = TBaseHelper.compareTo(this.row, typedOther.row);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetColumn()).compareTo(typedOther.isSetColumn());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetColumn()) {
        lastComparison = TBaseHelper.compareTo(this.column, typedOther.column);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetValue()).compareTo(typedOther.isSetValue());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetValue()) {
        lastComparison = TBaseHelper.compareTo(this.value, typedOther.value);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 1: // TABLE_NAME
            if (field.type == TType.STRING) {
              this.tableName = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // ROW
            if (field.type == TType.STRING) {
              this.row = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // COLUMN
            if (field.type == TType.STRING) {
              this.column = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 4: // VALUE
            if (field.type == TType.I64) {
              this.value = iprot.readI64();
              setValueIsSet(true);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tableName != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeBinary(this.tableName);
        oprot.writeFieldEnd();
      }
      if (this.row != null) {
        oprot.writeFieldBegin(ROW_FIELD_DESC);
        oprot.writeBinary(this.row);
        oprot.writeFieldEnd();
      }
      if (this.column != null) {
        oprot.writeFieldBegin(COLUMN_FIELD_DESC);
        oprot.writeBinary(this.column);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(VALUE_FIELD_DESC);
      oprot.writeI64(this.value);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("atomicIncrement_args(");
      boolean first = true;

      sb.append("tableName:");
      if (this.tableName == null) {
        sb.append("null");
      } else {
        sb.append(this.tableName);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("row:");
      if (this.row == null) {
        sb.append("null");
      } else {
        sb.append(this.row);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("column:");
      if (this.column == null) {
        sb.append("null");
      } else {
        sb.append(this.column);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("value:");
      sb.append(this.value);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class atomicIncrement_result implements TBase<atomicIncrement_result, atomicIncrement_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("atomicIncrement_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.I64, (short)0);
    private static final TField IO_FIELD_DESC = new TField("io", TType.STRUCT, (short)1);
    private static final TField IA_FIELD_DESC = new TField("ia", TType.STRUCT, (short)2);

    public long success;
    public IOError io;
    public IllegalArgument ia;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      IO((short)1, "io"),
      IA((short)2, "ia");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // IO
            return IO;
          case 2: // IA
            return IA;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.I64)));
      tmpMap.put(_Fields.IO, new FieldMetaData("io", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRUCT)));
      tmpMap.put(_Fields.IA, new FieldMetaData("ia", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(atomicIncrement_result.class, metaDataMap);
    }

    public atomicIncrement_result() {
    }

    public atomicIncrement_result(
      long success,
      IOError io,
      IllegalArgument ia)
    {
      this();
      this.success = success;
      setSuccessIsSet(true);
      this.io = io;
      this.ia = ia;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public atomicIncrement_result(atomicIncrement_result other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.success = other.success;
      if (other.isSetIo()) {
        this.io = new IOError(other.io);
      }
      if (other.isSetIa()) {
        this.ia = new IllegalArgument(other.ia);
      }
    }

    public atomicIncrement_result deepCopy() {
      return new atomicIncrement_result(this);
    }

    @Override
    public void clear() {
      setSuccessIsSet(false);
      this.success = 0;
      this.io = null;
      this.ia = null;
    }

    public long getSuccess() {
      return this.success;
    }

    public atomicIncrement_result setSuccess(long success) {
      this.success = success;
      setSuccessIsSet(true);
      return this;
    }

    public void unsetSuccess() {
      __isset_bit_vector.clear(__SUCCESS_ISSET_ID);
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return __isset_bit_vector.get(__SUCCESS_ISSET_ID);
    }

    public void setSuccessIsSet(boolean value) {
      __isset_bit_vector.set(__SUCCESS_ISSET_ID, value);
    }

    public IOError getIo() {
      return this.io;
    }

    public atomicIncrement_result setIo(IOError io) {
      this.io = io;
      return this;
    }

    public void unsetIo() {
      this.io = null;
    }

    /** Returns true if field io is set (has been asigned a value) and false otherwise */
    public boolean isSetIo() {
      return this.io != null;
    }

    public void setIoIsSet(boolean value) {
      if (!value) {
        this.io = null;
      }
    }

    public IllegalArgument getIa() {
      return this.ia;
    }

    public atomicIncrement_result setIa(IllegalArgument ia) {
      this.ia = ia;
      return this;
    }

    public void unsetIa() {
      this.ia = null;
    }

    /** Returns true if field ia is set (has been asigned a value) and false otherwise */
    public boolean isSetIa() {
      return this.ia != null;
    }

    public void setIaIsSet(boolean value) {
      if (!value) {
        this.ia = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Long)value);
        }
        break;

      case IO:
        if (value == null) {
          unsetIo();
        } else {
          setIo((IOError)value);
        }
        break;

      case IA:
        if (value == null) {
          unsetIa();
        } else {
          setIa((IllegalArgument)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return new Long(getSuccess());

      case IO:
        return getIo();

      case IA:
        return getIa();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case IO:
        return isSetIo();
      case IA:
        return isSetIa();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof atomicIncrement_result)
        return this.equals((atomicIncrement_result)that);
      return false;
    }

    public boolean equals(atomicIncrement_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_io = true && this.isSetIo();
      boolean that_present_io = true && that.isSetIo();
      if (this_present_io || that_present_io) {
        if (!(this_present_io && that_present_io))
          return false;
        if (!this.io.equals(that.io))
          return false;
      }

      boolean this_present_ia = true && this.isSetIa();
      boolean that_present_ia = true && that.isSetIa();
      if (this_present_ia || that_present_ia) {
        if (!(this_present_ia && that_present_ia))
          return false;
        if (!this.ia.equals(that.ia))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(atomicIncrement_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      atomicIncrement_result typedOther = (atomicIncrement_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetIo()).compareTo(typedOther.isSetIo());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetIo()) {
        lastComparison = TBaseHelper.compareTo(this.io, typedOther.io);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetIa()).compareTo(typedOther.isSetIa());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetIa()) {
        lastComparison = TBaseHelper.compareTo(this.ia, typedOther.ia);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.I64) {
              this.success = iprot.readI64();
              setSuccessIsSet(true);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // IO
            if (field.type == TType.STRUCT) {
              this.io = new IOError();
              this.io.read(iprot);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // IA
            if (field.type == TType.STRUCT) {
              this.ia = new IllegalArgument();
              this.ia.read(iprot);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeI64(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetIo()) {
        oprot.writeFieldBegin(IO_FIELD_DESC);
        this.io.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetIa()) {
        oprot.writeFieldBegin(IA_FIELD_DESC);
        this.ia.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("atomicIncrement_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("io:");
      if (this.io == null) {
        sb.append("null");
      } else {
        sb.append(this.io);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ia:");
      if (this.ia == null) {
        sb.append("null");
      } else {
        sb.append(this.ia);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class deleteAll_args implements TBase<deleteAll_args, deleteAll_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("deleteAll_args");

    private static final TField TABLE_NAME_FIELD_DESC = new TField("tableName", TType.STRING, (short)1);
    private static final TField ROW_FIELD_DESC = new TField("row", TType.STRING, (short)2);
    private static final TField COLUMN_FIELD_DESC = new TField("column", TType.STRING, (short)3);

    /**
     * name of table
     */
    public ByteBuffer tableName;
    /**
     * Row to update
     */
    public ByteBuffer row;
    /**
     * name of column whose value is to be deleted
     */
    public ByteBuffer column;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      /**
       * name of table
       */
      TABLE_NAME((short)1, "tableName"),
      /**
       * Row to update
       */
      ROW((short)2, "row"),
      /**
       * name of column whose value is to be deleted
       */
      COLUMN((short)3, "column");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // TABLE_NAME
            return TABLE_NAME;
          case 2: // ROW
            return ROW;
          case 3: // COLUMN
            return COLUMN;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.TABLE_NAME, new FieldMetaData("tableName", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Text")));
      tmpMap.put(_Fields.ROW, new FieldMetaData("row", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Text")));
      tmpMap.put(_Fields.COLUMN, new FieldMetaData("column", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Text")));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(deleteAll_args.class, metaDataMap);
    }

    public deleteAll_args() {
    }

    public deleteAll_args(
      ByteBuffer tableName,
      ByteBuffer row,
      ByteBuffer column)
    {
      this();
      this.tableName = tableName;
      this.row = row;
      this.column = column;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public deleteAll_args(deleteAll_args other) {
      if (other.isSetTableName()) {
        this.tableName = other.tableName;
      }
      if (other.isSetRow()) {
        this.row = other.row;
      }
      if (other.isSetColumn()) {
        this.column = other.column;
      }
    }

    public deleteAll_args deepCopy() {
      return new deleteAll_args(this);
    }

    @Override
    public void clear() {
      this.tableName = null;
      this.row = null;
      this.column = null;
    }

    /**
     * name of table
     */
    public byte[] getTableName() {
      setTableName(TBaseHelper.rightSize(tableName));
      return tableName.array();
    }

    public ByteBuffer BufferForTableName() {
      return tableName;
    }

    /**
     * name of table
     */
    public deleteAll_args setTableName(byte[] tableName) {
      setTableName(ByteBuffer.wrap(tableName));
      return this;
    }

    public deleteAll_args setTableName(ByteBuffer tableName) {
      this.tableName = tableName;
      return this;
    }

    public void unsetTableName() {
      this.tableName = null;
    }

    /** Returns true if field tableName is set (has been asigned a value) and false otherwise */
    public boolean isSetTableName() {
      return this.tableName != null;
    }

    public void setTableNameIsSet(boolean value) {
      if (!value) {
        this.tableName = null;
      }
    }

    /**
     * Row to update
     */
    public byte[] getRow() {
      setRow(TBaseHelper.rightSize(row));
      return row.array();
    }

    public ByteBuffer BufferForRow() {
      return row;
    }

    /**
     * Row to update
     */
    public deleteAll_args setRow(byte[] row) {
      setRow(ByteBuffer.wrap(row));
      return this;
    }

    public deleteAll_args setRow(ByteBuffer row) {
      this.row = row;
      return this;
    }

    public void unsetRow() {
      this.row = null;
    }

    /** Returns true if field row is set (has been asigned a value) and false otherwise */
    public boolean isSetRow() {
      return this.row != null;
    }

    public void setRowIsSet(boolean value) {
      if (!value) {
        this.row = null;
      }
    }

    /**
     * name of column whose value is to be deleted
     */
    public byte[] getColumn() {
      setColumn(TBaseHelper.rightSize(column));
      return column.array();
    }

    public ByteBuffer BufferForColumn() {
      return column;
    }

    /**
     * name of column whose value is to be deleted
     */
    public deleteAll_args setColumn(byte[] column) {
      setColumn(ByteBuffer.wrap(column));
      return this;
    }

    public deleteAll_args setColumn(ByteBuffer column) {
      this.column = column;
      return this;
    }

    public void unsetColumn() {
      this.column = null;
    }

    /** Returns true if field column is set (has been asigned a value) and false otherwise */
    public boolean isSetColumn() {
      return this.column != null;
    }

    public void setColumnIsSet(boolean value) {
      if (!value) {
        this.column = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TABLE_NAME:
        if (value == null) {
          unsetTableName();
        } else {
          setTableName((ByteBuffer)value);
        }
        break;

      case ROW:
        if (value == null) {
          unsetRow();
        } else {
          setRow((ByteBuffer)value);
        }
        break;

      case COLUMN:
        if (value == null) {
          unsetColumn();
        } else {
          setColumn((ByteBuffer)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return getTableName();

      case ROW:
        return getRow();

      case COLUMN:
        return getColumn();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case TABLE_NAME:
        return isSetTableName();
      case ROW:
        return isSetRow();
      case COLUMN:
        return isSetColumn();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof deleteAll_args)
        return this.equals((deleteAll_args)that);
      return false;
    }

    public boolean equals(deleteAll_args that) {
      if (that == null)
        return false;

      boolean this_present_tableName = true && this.isSetTableName();
      boolean that_present_tableName = true && that.isSetTableName();
      if (this_present_tableName || that_present_tableName) {
        if (!(this_present_tableName && that_present_tableName))
          return false;
        if (!this.tableName.equals(that.tableName))
          return false;
      }

      boolean this_present_row = true && this.isSetRow();
      boolean that_present_row = true && that.isSetRow();
      if (this_present_row || that_present_row) {
        if (!(this_present_row && that_present_row))
          return false;
        if (!this.row.equals(that.row))
          return false;
      }

      boolean this_present_column = true && this.isSetColumn();
      boolean that_present_column = true && that.isSetColumn();
      if (this_present_column || that_present_column) {
        if (!(this_present_column && that_present_column))
          return false;
        if (!this.column.equals(that.column))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(deleteAll_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      deleteAll_args typedOther = (deleteAll_args)other;

      lastComparison = Boolean.valueOf(isSetTableName()).compareTo(typedOther.isSetTableName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTableName()) {
        lastComparison = TBaseHelper.compareTo(this.tableName, typedOther.tableName);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetRow()).compareTo(typedOther.isSetRow());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetRow()) {
        lastComparison = TBaseHelper.compareTo(this.row, typedOther.row);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetColumn()).compareTo(typedOther.isSetColumn());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetColumn()) {
        lastComparison = TBaseHelper.compareTo(this.column, typedOther.column);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 1: // TABLE_NAME
            if (field.type == TType.STRING) {
              this.tableName = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // ROW
            if (field.type == TType.STRING) {
              this.row = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // COLUMN
            if (field.type == TType.STRING) {
              this.column = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tableName != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeBinary(this.tableName);
        oprot.writeFieldEnd();
      }
      if (this.row != null) {
        oprot.writeFieldBegin(ROW_FIELD_DESC);
        oprot.writeBinary(this.row);
        oprot.writeFieldEnd();
      }
      if (this.column != null) {
        oprot.writeFieldBegin(COLUMN_FIELD_DESC);
        oprot.writeBinary(this.column);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("deleteAll_args(");
      boolean first = true;

      sb.append("tableName:");
      if (this.tableName == null) {
        sb.append("null");
      } else {
        sb.append(this.tableName);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("row:");
      if (this.row == null) {
        sb.append("null");
      } else {
        sb.append(this.row);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("column:");
      if (this.column == null) {
        sb.append("null");
      } else {
        sb.append(this.column);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class deleteAll_result implements TBase<deleteAll_result, deleteAll_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("deleteAll_result");

    private static final TField IO_FIELD_DESC = new TField("io", TType.STRUCT, (short)1);

    public IOError io;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      IO((short)1, "io");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // IO
            return IO;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.IO, new FieldMetaData("io", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(deleteAll_result.class, metaDataMap);
    }

    public deleteAll_result() {
    }

    public deleteAll_result(
      IOError io)
    {
      this();
      this.io = io;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public deleteAll_result(deleteAll_result other) {
      if (other.isSetIo()) {
        this.io = new IOError(other.io);
      }
    }

    public deleteAll_result deepCopy() {
      return new deleteAll_result(this);
    }

    @Override
    public void clear() {
      this.io = null;
    }

    public IOError getIo() {
      return this.io;
    }

    public deleteAll_result setIo(IOError io) {
      this.io = io;
      return this;
    }

    public void unsetIo() {
      this.io = null;
    }

    /** Returns true if field io is set (has been asigned a value) and false otherwise */
    public boolean isSetIo() {
      return this.io != null;
    }

    public void setIoIsSet(boolean value) {
      if (!value) {
        this.io = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case IO:
        if (value == null) {
          unsetIo();
        } else {
          setIo((IOError)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case IO:
        return getIo();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case IO:
        return isSetIo();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof deleteAll_result)
        return this.equals((deleteAll_result)that);
      return false;
    }

    public boolean equals(deleteAll_result that) {
      if (that == null)
        return false;

      boolean this_present_io = true && this.isSetIo();
      boolean that_present_io = true && that.isSetIo();
      if (this_present_io || that_present_io) {
        if (!(this_present_io && that_present_io))
          return false;
        if (!this.io.equals(that.io))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(deleteAll_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      deleteAll_result typedOther = (deleteAll_result)other;

      lastComparison = Boolean.valueOf(isSetIo()).compareTo(typedOther.isSetIo());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetIo()) {
        lastComparison = TBaseHelper.compareTo(this.io, typedOther.io);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 1: // IO
            if (field.type == TType.STRUCT) {
              this.io = new IOError();
              this.io.read(iprot);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetIo()) {
        oprot.writeFieldBegin(IO_FIELD_DESC);
        this.io.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("deleteAll_result(");
      boolean first = true;

      sb.append("io:");
      if (this.io == null) {
        sb.append("null");
      } else {
        sb.append(this.io);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class deleteAllTs_args implements TBase<deleteAllTs_args, deleteAllTs_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("deleteAllTs_args");

    private static final TField TABLE_NAME_FIELD_DESC = new TField("tableName", TType.STRING, (short)1);
    private static final TField ROW_FIELD_DESC = new TField("row", TType.STRING, (short)2);
    private static final TField COLUMN_FIELD_DESC = new TField("column", TType.STRING, (short)3);
    private static final TField TIMESTAMP_FIELD_DESC = new TField("timestamp", TType.I64, (short)4);

    /**
     * name of table
     */
    public ByteBuffer tableName;
    /**
     * Row to update
     */
    public ByteBuffer row;
    /**
     * name of column whose value is to be deleted
     */
    public ByteBuffer column;
    /**
     * timestamp
     */
    public long timestamp;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      /**
       * name of table
       */
      TABLE_NAME((short)1, "tableName"),
      /**
       * Row to update
       */
      ROW((short)2, "row"),
      /**
       * name of column whose value is to be deleted
       */
      COLUMN((short)3, "column"),
      /**
       * timestamp
       */
      TIMESTAMP((short)4, "timestamp");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // TABLE_NAME
            return TABLE_NAME;
          case 2: // ROW
            return ROW;
          case 3: // COLUMN
            return COLUMN;
          case 4: // TIMESTAMP
            return TIMESTAMP;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __TIMESTAMP_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.TABLE_NAME, new FieldMetaData("tableName", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Text")));
      tmpMap.put(_Fields.ROW, new FieldMetaData("row", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Text")));
      tmpMap.put(_Fields.COLUMN, new FieldMetaData("column", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Text")));
      tmpMap.put(_Fields.TIMESTAMP, new FieldMetaData("timestamp", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.I64)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(deleteAllTs_args.class, metaDataMap);
    }

    public deleteAllTs_args() {
    }

    public deleteAllTs_args(
      ByteBuffer tableName,
      ByteBuffer row,
      ByteBuffer column,
      long timestamp)
    {
      this();
      this.tableName = tableName;
      this.row = row;
      this.column = column;
      this.timestamp = timestamp;
      setTimestampIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public deleteAllTs_args(deleteAllTs_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      if (other.isSetTableName()) {
        this.tableName = other.tableName;
      }
      if (other.isSetRow()) {
        this.row = other.row;
      }
      if (other.isSetColumn()) {
        this.column = other.column;
      }
      this.timestamp = other.timestamp;
    }

    public deleteAllTs_args deepCopy() {
      return new deleteAllTs_args(this);
    }

    @Override
    public void clear() {
      this.tableName = null;
      this.row = null;
      this.column = null;
      setTimestampIsSet(false);
      this.timestamp = 0;
    }

    /**
     * name of table
     */
    public byte[] getTableName() {
      setTableName(TBaseHelper.rightSize(tableName));
      return tableName.array();
    }

    public ByteBuffer BufferForTableName() {
      return tableName;
    }

    /**
     * name of table
     */
    public deleteAllTs_args setTableName(byte[] tableName) {
      setTableName(ByteBuffer.wrap(tableName));
      return this;
    }

    public deleteAllTs_args setTableName(ByteBuffer tableName) {
      this.tableName = tableName;
      return this;
    }

    public void unsetTableName() {
      this.tableName = null;
    }

    /** Returns true if field tableName is set (has been asigned a value) and false otherwise */
    public boolean isSetTableName() {
      return this.tableName != null;
    }

    public void setTableNameIsSet(boolean value) {
      if (!value) {
        this.tableName = null;
      }
    }

    /**
     * Row to update
     */
    public byte[] getRow() {
      setRow(TBaseHelper.rightSize(row));
      return row.array();
    }

    public ByteBuffer BufferForRow() {
      return row;
    }

    /**
     * Row to update
     */
    public deleteAllTs_args setRow(byte[] row) {
      setRow(ByteBuffer.wrap(row));
      return this;
    }

    public deleteAllTs_args setRow(ByteBuffer row) {
      this.row = row;
      return this;
    }

    public void unsetRow() {
      this.row = null;
    }

    /** Returns true if field row is set (has been asigned a value) and false otherwise */
    public boolean isSetRow() {
      return this.row != null;
    }

    public void setRowIsSet(boolean value) {
      if (!value) {
        this.row = null;
      }
    }

    /**
     * name of column whose value is to be deleted
     */
    public byte[] getColumn() {
      setColumn(TBaseHelper.rightSize(column));
      return column.array();
    }

    public ByteBuffer BufferForColumn() {
      return column;
    }

    /**
     * name of column whose value is to be deleted
     */
    public deleteAllTs_args setColumn(byte[] column) {
      setColumn(ByteBuffer.wrap(column));
      return this;
    }

    public deleteAllTs_args setColumn(ByteBuffer column) {
      this.column = column;
      return this;
    }

    public void unsetColumn() {
      this.column = null;
    }

    /** Returns true if field column is set (has been asigned a value) and false otherwise */
    public boolean isSetColumn() {
      return this.column != null;
    }

    public void setColumnIsSet(boolean value) {
      if (!value) {
        this.column = null;
      }
    }

    /**
     * timestamp
     */
    public long getTimestamp() {
      return this.timestamp;
    }

    /**
     * timestamp
     */
    public deleteAllTs_args setTimestamp(long timestamp) {
      this.timestamp = timestamp;
      setTimestampIsSet(true);
      return this;
    }

    public void unsetTimestamp() {
      __isset_bit_vector.clear(__TIMESTAMP_ISSET_ID);
    }

    /** Returns true if field timestamp is set (has been asigned a value) and false otherwise */
    public boolean isSetTimestamp() {
      return __isset_bit_vector.get(__TIMESTAMP_ISSET_ID);
    }

    public void setTimestampIsSet(boolean value) {
      __isset_bit_vector.set(__TIMESTAMP_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TABLE_NAME:
        if (value == null) {
          unsetTableName();
        } else {
          setTableName((ByteBuffer)value);
        }
        break;

      case ROW:
        if (value == null) {
          unsetRow();
        } else {
          setRow((ByteBuffer)value);
        }
        break;

      case COLUMN:
        if (value == null) {
          unsetColumn();
        } else {
          setColumn((ByteBuffer)value);
        }
        break;

      case TIMESTAMP:
        if (value == null) {
          unsetTimestamp();
        } else {
          setTimestamp((Long)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return getTableName();

      case ROW:
        return getRow();

      case COLUMN:
        return getColumn();

      case TIMESTAMP:
        return new Long(getTimestamp());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case TABLE_NAME:
        return isSetTableName();
      case ROW:
        return isSetRow();
      case COLUMN:
        return isSetColumn();
      case TIMESTAMP:
        return isSetTimestamp();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof deleteAllTs_args)
        return this.equals((deleteAllTs_args)that);
      return false;
    }

    public boolean equals(deleteAllTs_args that) {
      if (that == null)
        return false;

      boolean this_present_tableName = true && this.isSetTableName();
      boolean that_present_tableName = true && that.isSetTableName();
      if (this_present_tableName || that_present_tableName) {
        if (!(this_present_tableName && that_present_tableName))
          return false;
        if (!this.tableName.equals(that.tableName))
          return false;
      }

      boolean this_present_row = true && this.isSetRow();
      boolean that_present_row = true && that.isSetRow();
      if (this_present_row || that_present_row) {
        if (!(this_present_row && that_present_row))
          return false;
        if (!this.row.equals(that.row))
          return false;
      }

      boolean this_present_column = true && this.isSetColumn();
      boolean that_present_column = true && that.isSetColumn();
      if (this_present_column || that_present_column) {
        if (!(this_present_column && that_present_column))
          return false;
        if (!this.column.equals(that.column))
          return false;
      }

      boolean this_present_timestamp = true;
      boolean that_present_timestamp = true;
      if (this_present_timestamp || that_present_timestamp) {
        if (!(this_present_timestamp && that_present_timestamp))
          return false;
        if (this.timestamp != that.timestamp)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(deleteAllTs_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      deleteAllTs_args typedOther = (deleteAllTs_args)other;

      lastComparison = Boolean.valueOf(isSetTableName()).compareTo(typedOther.isSetTableName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTableName()) {
        lastComparison = TBaseHelper.compareTo(this.tableName, typedOther.tableName);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetRow()).compareTo(typedOther.isSetRow());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetRow()) {
        lastComparison = TBaseHelper.compareTo(this.row, typedOther.row);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetColumn()).compareTo(typedOther.isSetColumn());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetColumn()) {
        lastComparison = TBaseHelper.compareTo(this.column, typedOther.column);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetTimestamp()).compareTo(typedOther.isSetTimestamp());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTimestamp()) {
        lastComparison = TBaseHelper.compareTo(this.timestamp, typedOther.timestamp);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 1: // TABLE_NAME
            if (field.type == TType.STRING) {
              this.tableName = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // ROW
            if (field.type == TType.STRING) {
              this.row = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // COLUMN
            if (field.type == TType.STRING) {
              this.column = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 4: // TIMESTAMP
            if (field.type == TType.I64) {
              this.timestamp = iprot.readI64();
              setTimestampIsSet(true);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tableName != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeBinary(this.tableName);
        oprot.writeFieldEnd();
      }
      if (this.row != null) {
        oprot.writeFieldBegin(ROW_FIELD_DESC);
        oprot.writeBinary(this.row);
        oprot.writeFieldEnd();
      }
      if (this.column != null) {
        oprot.writeFieldBegin(COLUMN_FIELD_DESC);
        oprot.writeBinary(this.column);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(TIMESTAMP_FIELD_DESC);
      oprot.writeI64(this.timestamp);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("deleteAllTs_args(");
      boolean first = true;

      sb.append("tableName:");
      if (this.tableName == null) {
        sb.append("null");
      } else {
        sb.append(this.tableName);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("row:");
      if (this.row == null) {
        sb.append("null");
      } else {
        sb.append(this.row);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("column:");
      if (this.column == null) {
        sb.append("null");
      } else {
        sb.append(this.column);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("timestamp:");
      sb.append(this.timestamp);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class deleteAllTs_result implements TBase<deleteAllTs_result, deleteAllTs_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("deleteAllTs_result");

    private static final TField IO_FIELD_DESC = new TField("io", TType.STRUCT, (short)1);

    public IOError io;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      IO((short)1, "io");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // IO
            return IO;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.IO, new FieldMetaData("io", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(deleteAllTs_result.class, metaDataMap);
    }

    public deleteAllTs_result() {
    }

    public deleteAllTs_result(
      IOError io)
    {
      this();
      this.io = io;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public deleteAllTs_result(deleteAllTs_result other) {
      if (other.isSetIo()) {
        this.io = new IOError(other.io);
      }
    }

    public deleteAllTs_result deepCopy() {
      return new deleteAllTs_result(this);
    }

    @Override
    public void clear() {
      this.io = null;
    }

    public IOError getIo() {
      return this.io;
    }

    public deleteAllTs_result setIo(IOError io) {
      this.io = io;
      return this;
    }

    public void unsetIo() {
      this.io = null;
    }

    /** Returns true if field io is set (has been asigned a value) and false otherwise */
    public boolean isSetIo() {
      return this.io != null;
    }

    public void setIoIsSet(boolean value) {
      if (!value) {
        this.io = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case IO:
        if (value == null) {
          unsetIo();
        } else {
          setIo((IOError)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case IO:
        return getIo();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case IO:
        return isSetIo();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof deleteAllTs_result)
        return this.equals((deleteAllTs_result)that);
      return false;
    }

    public boolean equals(deleteAllTs_result that) {
      if (that == null)
        return false;

      boolean this_present_io = true && this.isSetIo();
      boolean that_present_io = true && that.isSetIo();
      if (this_present_io || that_present_io) {
        if (!(this_present_io && that_present_io))
          return false;
        if (!this.io.equals(that.io))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(deleteAllTs_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      deleteAllTs_result typedOther = (deleteAllTs_result)other;

      lastComparison = Boolean.valueOf(isSetIo()).compareTo(typedOther.isSetIo());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetIo()) {
        lastComparison = TBaseHelper.compareTo(this.io, typedOther.io);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 1: // IO
            if (field.type == TType.STRUCT) {
              this.io = new IOError();
              this.io.read(iprot);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetIo()) {
        oprot.writeFieldBegin(IO_FIELD_DESC);
        this.io.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("deleteAllTs_result(");
      boolean first = true;

      sb.append("io:");
      if (this.io == null) {
        sb.append("null");
      } else {
        sb.append(this.io);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class deleteAllRow_args implements TBase<deleteAllRow_args, deleteAllRow_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("deleteAllRow_args");

    private static final TField TABLE_NAME_FIELD_DESC = new TField("tableName", TType.STRING, (short)1);
    private static final TField ROW_FIELD_DESC = new TField("row", TType.STRING, (short)2);

    /**
     * name of table
     */
    public ByteBuffer tableName;
    /**
     * key of the row to be completely deleted.
     */
    public ByteBuffer row;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      /**
       * name of table
       */
      TABLE_NAME((short)1, "tableName"),
      /**
       * key of the row to be completely deleted.
       */
      ROW((short)2, "row");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // TABLE_NAME
            return TABLE_NAME;
          case 2: // ROW
            return ROW;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.TABLE_NAME, new FieldMetaData("tableName", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Text")));
      tmpMap.put(_Fields.ROW, new FieldMetaData("row", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Text")));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(deleteAllRow_args.class, metaDataMap);
    }

    public deleteAllRow_args() {
    }

    public deleteAllRow_args(
      ByteBuffer tableName,
      ByteBuffer row)
    {
      this();
      this.tableName = tableName;
      this.row = row;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public deleteAllRow_args(deleteAllRow_args other) {
      if (other.isSetTableName()) {
        this.tableName = other.tableName;
      }
      if (other.isSetRow()) {
        this.row = other.row;
      }
    }

    public deleteAllRow_args deepCopy() {
      return new deleteAllRow_args(this);
    }

    @Override
    public void clear() {
      this.tableName = null;
      this.row = null;
    }

    /**
     * name of table
     */
    public byte[] getTableName() {
      setTableName(TBaseHelper.rightSize(tableName));
      return tableName.array();
    }

    public ByteBuffer BufferForTableName() {
      return tableName;
    }

    /**
     * name of table
     */
    public deleteAllRow_args setTableName(byte[] tableName) {
      setTableName(ByteBuffer.wrap(tableName));
      return this;
    }

    public deleteAllRow_args setTableName(ByteBuffer tableName) {
      this.tableName = tableName;
      return this;
    }

    public void unsetTableName() {
      this.tableName = null;
    }

    /** Returns true if field tableName is set (has been asigned a value) and false otherwise */
    public boolean isSetTableName() {
      return this.tableName != null;
    }

    public void setTableNameIsSet(boolean value) {
      if (!value) {
        this.tableName = null;
      }
    }

    /**
     * key of the row to be completely deleted.
     */
    public byte[] getRow() {
      setRow(TBaseHelper.rightSize(row));
      return row.array();
    }

    public ByteBuffer BufferForRow() {
      return row;
    }

    /**
     * key of the row to be completely deleted.
     */
    public deleteAllRow_args setRow(byte[] row) {
      setRow(ByteBuffer.wrap(row));
      return this;
    }

    public deleteAllRow_args setRow(ByteBuffer row) {
      this.row = row;
      return this;
    }

    public void unsetRow() {
      this.row = null;
    }

    /** Returns true if field row is set (has been asigned a value) and false otherwise */
    public boolean isSetRow() {
      return this.row != null;
    }

    public void setRowIsSet(boolean value) {
      if (!value) {
        this.row = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TABLE_NAME:
        if (value == null) {
          unsetTableName();
        } else {
          setTableName((ByteBuffer)value);
        }
        break;

      case ROW:
        if (value == null) {
          unsetRow();
        } else {
          setRow((ByteBuffer)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return getTableName();

      case ROW:
        return getRow();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case TABLE_NAME:
        return isSetTableName();
      case ROW:
        return isSetRow();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof deleteAllRow_args)
        return this.equals((deleteAllRow_args)that);
      return false;
    }

    public boolean equals(deleteAllRow_args that) {
      if (that == null)
        return false;

      boolean this_present_tableName = true && this.isSetTableName();
      boolean that_present_tableName = true && that.isSetTableName();
      if (this_present_tableName || that_present_tableName) {
        if (!(this_present_tableName && that_present_tableName))
          return false;
        if (!this.tableName.equals(that.tableName))
          return false;
      }

      boolean this_present_row = true && this.isSetRow();
      boolean that_present_row = true && that.isSetRow();
      if (this_present_row || that_present_row) {
        if (!(this_present_row && that_present_row))
          return false;
        if (!this.row.equals(that.row))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(deleteAllRow_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      deleteAllRow_args typedOther = (deleteAllRow_args)other;

      lastComparison = Boolean.valueOf(isSetTableName()).compareTo(typedOther.isSetTableName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTableName()) {
        lastComparison = TBaseHelper.compareTo(this.tableName, typedOther.tableName);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetRow()).compareTo(typedOther.isSetRow());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetRow()) {
        lastComparison = TBaseHelper.compareTo(this.row, typedOther.row);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 1: // TABLE_NAME
            if (field.type == TType.STRING) {
              this.tableName = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // ROW
            if (field.type == TType.STRING) {
              this.row = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tableName != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeBinary(this.tableName);
        oprot.writeFieldEnd();
      }
      if (this.row != null) {
        oprot.writeFieldBegin(ROW_FIELD_DESC);
        oprot.writeBinary(this.row);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("deleteAllRow_args(");
      boolean first = true;

      sb.append("tableName:");
      if (this.tableName == null) {
        sb.append("null");
      } else {
        sb.append(this.tableName);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("row:");
      if (this.row == null) {
        sb.append("null");
      } else {
        sb.append(this.row);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class deleteAllRow_result implements TBase<deleteAllRow_result, deleteAllRow_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("deleteAllRow_result");

    private static final TField IO_FIELD_DESC = new TField("io", TType.STRUCT, (short)1);

    public IOError io;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      IO((short)1, "io");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // IO
            return IO;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.IO, new FieldMetaData("io", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(deleteAllRow_result.class, metaDataMap);
    }

    public deleteAllRow_result() {
    }

    public deleteAllRow_result(
      IOError io)
    {
      this();
      this.io = io;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public deleteAllRow_result(deleteAllRow_result other) {
      if (other.isSetIo()) {
        this.io = new IOError(other.io);
      }
    }

    public deleteAllRow_result deepCopy() {
      return new deleteAllRow_result(this);
    }

    @Override
    public void clear() {
      this.io = null;
    }

    public IOError getIo() {
      return this.io;
    }

    public deleteAllRow_result setIo(IOError io) {
      this.io = io;
      return this;
    }

    public void unsetIo() {
      this.io = null;
    }

    /** Returns true if field io is set (has been asigned a value) and false otherwise */
    public boolean isSetIo() {
      return this.io != null;
    }

    public void setIoIsSet(boolean value) {
      if (!value) {
        this.io = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case IO:
        if (value == null) {
          unsetIo();
        } else {
          setIo((IOError)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case IO:
        return getIo();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case IO:
        return isSetIo();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof deleteAllRow_result)
        return this.equals((deleteAllRow_result)that);
      return false;
    }

    public boolean equals(deleteAllRow_result that) {
      if (that == null)
        return false;

      boolean this_present_io = true && this.isSetIo();
      boolean that_present_io = true && that.isSetIo();
      if (this_present_io || that_present_io) {
        if (!(this_present_io && that_present_io))
          return false;
        if (!this.io.equals(that.io))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(deleteAllRow_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      deleteAllRow_result typedOther = (deleteAllRow_result)other;

      lastComparison = Boolean.valueOf(isSetIo()).compareTo(typedOther.isSetIo());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetIo()) {
        lastComparison = TBaseHelper.compareTo(this.io, typedOther.io);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 1: // IO
            if (field.type == TType.STRUCT) {
              this.io = new IOError();
              this.io.read(iprot);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetIo()) {
        oprot.writeFieldBegin(IO_FIELD_DESC);
        this.io.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("deleteAllRow_result(");
      boolean first = true;

      sb.append("io:");
      if (this.io == null) {
        sb.append("null");
      } else {
        sb.append(this.io);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class deleteAllRowTs_args implements TBase<deleteAllRowTs_args, deleteAllRowTs_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("deleteAllRowTs_args");

    private static final TField TABLE_NAME_FIELD_DESC = new TField("tableName", TType.STRING, (short)1);
    private static final TField ROW_FIELD_DESC = new TField("row", TType.STRING, (short)2);
    private static final TField TIMESTAMP_FIELD_DESC = new TField("timestamp", TType.I64, (short)3);

    /**
     * name of table
     */
    public ByteBuffer tableName;
    /**
     * key of the row to be completely deleted.
     */
    public ByteBuffer row;
    /**
     * timestamp
     */
    public long timestamp;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      /**
       * name of table
       */
      TABLE_NAME((short)1, "tableName"),
      /**
       * key of the row to be completely deleted.
       */
      ROW((short)2, "row"),
      /**
       * timestamp
       */
      TIMESTAMP((short)3, "timestamp");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // TABLE_NAME
            return TABLE_NAME;
          case 2: // ROW
            return ROW;
          case 3: // TIMESTAMP
            return TIMESTAMP;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __TIMESTAMP_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.TABLE_NAME, new FieldMetaData("tableName", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Text")));
      tmpMap.put(_Fields.ROW, new FieldMetaData("row", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Text")));
      tmpMap.put(_Fields.TIMESTAMP, new FieldMetaData("timestamp", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.I64)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(deleteAllRowTs_args.class, metaDataMap);
    }

    public deleteAllRowTs_args() {
    }

    public deleteAllRowTs_args(
      ByteBuffer tableName,
      ByteBuffer row,
      long timestamp)
    {
      this();
      this.tableName = tableName;
      this.row = row;
      this.timestamp = timestamp;
      setTimestampIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public deleteAllRowTs_args(deleteAllRowTs_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      if (other.isSetTableName()) {
        this.tableName = other.tableName;
      }
      if (other.isSetRow()) {
        this.row = other.row;
      }
      this.timestamp = other.timestamp;
    }

    public deleteAllRowTs_args deepCopy() {
      return new deleteAllRowTs_args(this);
    }

    @Override
    public void clear() {
      this.tableName = null;
      this.row = null;
      setTimestampIsSet(false);
      this.timestamp = 0;
    }

    /**
     * name of table
     */
    public byte[] getTableName() {
      setTableName(TBaseHelper.rightSize(tableName));
      return tableName.array();
    }

    public ByteBuffer BufferForTableName() {
      return tableName;
    }

    /**
     * name of table
     */
    public deleteAllRowTs_args setTableName(byte[] tableName) {
      setTableName(ByteBuffer.wrap(tableName));
      return this;
    }

    public deleteAllRowTs_args setTableName(ByteBuffer tableName) {
      this.tableName = tableName;
      return this;
    }

    public void unsetTableName() {
      this.tableName = null;
    }

    /** Returns true if field tableName is set (has been asigned a value) and false otherwise */
    public boolean isSetTableName() {
      return this.tableName != null;
    }

    public void setTableNameIsSet(boolean value) {
      if (!value) {
        this.tableName = null;
      }
    }

    /**
     * key of the row to be completely deleted.
     */
    public byte[] getRow() {
      setRow(TBaseHelper.rightSize(row));
      return row.array();
    }

    public ByteBuffer BufferForRow() {
      return row;
    }

    /**
     * key of the row to be completely deleted.
     */
    public deleteAllRowTs_args setRow(byte[] row) {
      setRow(ByteBuffer.wrap(row));
      return this;
    }

    public deleteAllRowTs_args setRow(ByteBuffer row) {
      this.row = row;
      return this;
    }

    public void unsetRow() {
      this.row = null;
    }

    /** Returns true if field row is set (has been asigned a value) and false otherwise */
    public boolean isSetRow() {
      return this.row != null;
    }

    public void setRowIsSet(boolean value) {
      if (!value) {
        this.row = null;
      }
    }

    /**
     * timestamp
     */
    public long getTimestamp() {
      return this.timestamp;
    }

    /**
     * timestamp
     */
    public deleteAllRowTs_args setTimestamp(long timestamp) {
      this.timestamp = timestamp;
      setTimestampIsSet(true);
      return this;
    }

    public void unsetTimestamp() {
      __isset_bit_vector.clear(__TIMESTAMP_ISSET_ID);
    }

    /** Returns true if field timestamp is set (has been asigned a value) and false otherwise */
    public boolean isSetTimestamp() {
      return __isset_bit_vector.get(__TIMESTAMP_ISSET_ID);
    }

    public void setTimestampIsSet(boolean value) {
      __isset_bit_vector.set(__TIMESTAMP_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TABLE_NAME:
        if (value == null) {
          unsetTableName();
        } else {
          setTableName((ByteBuffer)value);
        }
        break;

      case ROW:
        if (value == null) {
          unsetRow();
        } else {
          setRow((ByteBuffer)value);
        }
        break;

      case TIMESTAMP:
        if (value == null) {
          unsetTimestamp();
        } else {
          setTimestamp((Long)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return getTableName();

      case ROW:
        return getRow();

      case TIMESTAMP:
        return new Long(getTimestamp());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case TABLE_NAME:
        return isSetTableName();
      case ROW:
        return isSetRow();
      case TIMESTAMP:
        return isSetTimestamp();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof deleteAllRowTs_args)
        return this.equals((deleteAllRowTs_args)that);
      return false;
    }

    public boolean equals(deleteAllRowTs_args that) {
      if (that == null)
        return false;

      boolean this_present_tableName = true && this.isSetTableName();
      boolean that_present_tableName = true && that.isSetTableName();
      if (this_present_tableName || that_present_tableName) {
        if (!(this_present_tableName && that_present_tableName))
          return false;
        if (!this.tableName.equals(that.tableName))
          return false;
      }

      boolean this_present_row = true && this.isSetRow();
      boolean that_present_row = true && that.isSetRow();
      if (this_present_row || that_present_row) {
        if (!(this_present_row && that_present_row))
          return false;
        if (!this.row.equals(that.row))
          return false;
      }

      boolean this_present_timestamp = true;
      boolean that_present_timestamp = true;
      if (this_present_timestamp || that_present_timestamp) {
        if (!(this_present_timestamp && that_present_timestamp))
          return false;
        if (this.timestamp != that.timestamp)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(deleteAllRowTs_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      deleteAllRowTs_args typedOther = (deleteAllRowTs_args)other;

      lastComparison = Boolean.valueOf(isSetTableName()).compareTo(typedOther.isSetTableName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTableName()) {
        lastComparison = TBaseHelper.compareTo(this.tableName, typedOther.tableName);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetRow()).compareTo(typedOther.isSetRow());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetRow()) {
        lastComparison = TBaseHelper.compareTo(this.row, typedOther.row);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetTimestamp()).compareTo(typedOther.isSetTimestamp());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTimestamp()) {
        lastComparison = TBaseHelper.compareTo(this.timestamp, typedOther.timestamp);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 1: // TABLE_NAME
            if (field.type == TType.STRING) {
              this.tableName = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // ROW
            if (field.type == TType.STRING) {
              this.row = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // TIMESTAMP
            if (field.type == TType.I64) {
              this.timestamp = iprot.readI64();
              setTimestampIsSet(true);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tableName != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeBinary(this.tableName);
        oprot.writeFieldEnd();
      }
      if (this.row != null) {
        oprot.writeFieldBegin(ROW_FIELD_DESC);
        oprot.writeBinary(this.row);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(TIMESTAMP_FIELD_DESC);
      oprot.writeI64(this.timestamp);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("deleteAllRowTs_args(");
      boolean first = true;

      sb.append("tableName:");
      if (this.tableName == null) {
        sb.append("null");
      } else {
        sb.append(this.tableName);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("row:");
      if (this.row == null) {
        sb.append("null");
      } else {
        sb.append(this.row);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("timestamp:");
      sb.append(this.timestamp);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class deleteAllRowTs_result implements TBase<deleteAllRowTs_result, deleteAllRowTs_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("deleteAllRowTs_result");

    private static final TField IO_FIELD_DESC = new TField("io", TType.STRUCT, (short)1);

    public IOError io;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      IO((short)1, "io");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // IO
            return IO;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.IO, new FieldMetaData("io", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(deleteAllRowTs_result.class, metaDataMap);
    }

    public deleteAllRowTs_result() {
    }

    public deleteAllRowTs_result(
      IOError io)
    {
      this();
      this.io = io;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public deleteAllRowTs_result(deleteAllRowTs_result other) {
      if (other.isSetIo()) {
        this.io = new IOError(other.io);
      }
    }

    public deleteAllRowTs_result deepCopy() {
      return new deleteAllRowTs_result(this);
    }

    @Override
    public void clear() {
      this.io = null;
    }

    public IOError getIo() {
      return this.io;
    }

    public deleteAllRowTs_result setIo(IOError io) {
      this.io = io;
      return this;
    }

    public void unsetIo() {
      this.io = null;
    }

    /** Returns true if field io is set (has been asigned a value) and false otherwise */
    public boolean isSetIo() {
      return this.io != null;
    }

    public void setIoIsSet(boolean value) {
      if (!value) {
        this.io = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case IO:
        if (value == null) {
          unsetIo();
        } else {
          setIo((IOError)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case IO:
        return getIo();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case IO:
        return isSetIo();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof deleteAllRowTs_result)
        return this.equals((deleteAllRowTs_result)that);
      return false;
    }

    public boolean equals(deleteAllRowTs_result that) {
      if (that == null)
        return false;

      boolean this_present_io = true && this.isSetIo();
      boolean that_present_io = true && that.isSetIo();
      if (this_present_io || that_present_io) {
        if (!(this_present_io && that_present_io))
          return false;
        if (!this.io.equals(that.io))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(deleteAllRowTs_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      deleteAllRowTs_result typedOther = (deleteAllRowTs_result)other;

      lastComparison = Boolean.valueOf(isSetIo()).compareTo(typedOther.isSetIo());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetIo()) {
        lastComparison = TBaseHelper.compareTo(this.io, typedOther.io);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 1: // IO
            if (field.type == TType.STRUCT) {
              this.io = new IOError();
              this.io.read(iprot);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetIo()) {
        oprot.writeFieldBegin(IO_FIELD_DESC);
        this.io.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("deleteAllRowTs_result(");
      boolean first = true;

      sb.append("io:");
      if (this.io == null) {
        sb.append("null");
      } else {
        sb.append(this.io);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class scannerOpen_args implements TBase<scannerOpen_args, scannerOpen_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("scannerOpen_args");

    private static final TField TABLE_NAME_FIELD_DESC = new TField("tableName", TType.STRING, (short)1);
    private static final TField START_ROW_FIELD_DESC = new TField("startRow", TType.STRING, (short)2);
    private static final TField COLUMNS_FIELD_DESC = new TField("columns", TType.LIST, (short)3);

    /**
     * name of table
     */
    public ByteBuffer tableName;
    /**
     * Starting row in table to scan.
     * Send "" (empty string) to start at the first row.
     */
    public ByteBuffer startRow;
    /**
     * columns to scan. If column name is a column family, all
     * columns of the specified column family are returned. It's also possible
     * to pass a regex in the column qualifier.
     */
    public List<ByteBuffer> columns;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      /**
       * name of table
       */
      TABLE_NAME((short)1, "tableName"),
      /**
       * Starting row in table to scan.
       * Send "" (empty string) to start at the first row.
       */
      START_ROW((short)2, "startRow"),
      /**
       * columns to scan. If column name is a column family, all
       * columns of the specified column family are returned. It's also possible
       * to pass a regex in the column qualifier.
       */
      COLUMNS((short)3, "columns");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // TABLE_NAME
            return TABLE_NAME;
          case 2: // START_ROW
            return START_ROW;
          case 3: // COLUMNS
            return COLUMNS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.TABLE_NAME, new FieldMetaData("tableName", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Text")));
      tmpMap.put(_Fields.START_ROW, new FieldMetaData("startRow", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Text")));
      tmpMap.put(_Fields.COLUMNS, new FieldMetaData("columns", TFieldRequirementType.DEFAULT,
          new ListMetaData(TType.LIST,
              new FieldValueMetaData(TType.STRING              , "Text"))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(scannerOpen_args.class, metaDataMap);
    }

    public scannerOpen_args() {
    }

    public scannerOpen_args(
      ByteBuffer tableName,
      ByteBuffer startRow,
      List<ByteBuffer> columns)
    {
      this();
      this.tableName = tableName;
      this.startRow = startRow;
      this.columns = columns;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public scannerOpen_args(scannerOpen_args other) {
      if (other.isSetTableName()) {
        this.tableName = other.tableName;
      }
      if (other.isSetStartRow()) {
        this.startRow = other.startRow;
      }
      if (other.isSetColumns()) {
        List<ByteBuffer> __this__columns = new ArrayList<ByteBuffer>();
        for (ByteBuffer other_element : other.columns) {
          __this__columns.add(other_element);
        }
        this.columns = __this__columns;
      }
    }

    public scannerOpen_args deepCopy() {
      return new scannerOpen_args(this);
    }

    @Override
    public void clear() {
      this.tableName = null;
      this.startRow = null;
      this.columns = null;
    }

    /**
     * name of table
     */
    public byte[] getTableName() {
      setTableName(TBaseHelper.rightSize(tableName));
      return tableName.array();
    }

    public ByteBuffer BufferForTableName() {
      return tableName;
    }

    /**
     * name of table
     */
    public scannerOpen_args setTableName(byte[] tableName) {
      setTableName(ByteBuffer.wrap(tableName));
      return this;
    }

    public scannerOpen_args setTableName(ByteBuffer tableName) {
      this.tableName = tableName;
      return this;
    }

    public void unsetTableName() {
      this.tableName = null;
    }

    /** Returns true if field tableName is set (has been asigned a value) and false otherwise */
    public boolean isSetTableName() {
      return this.tableName != null;
    }

    public void setTableNameIsSet(boolean value) {
      if (!value) {
        this.tableName = null;
      }
    }

    /**
     * Starting row in table to scan.
     * Send "" (empty string) to start at the first row.
     */
    public byte[] getStartRow() {
      setStartRow(TBaseHelper.rightSize(startRow));
      return startRow.array();
    }

    public ByteBuffer BufferForStartRow() {
      return startRow;
    }

    /**
     * Starting row in table to scan.
     * Send "" (empty string) to start at the first row.
     */
    public scannerOpen_args setStartRow(byte[] startRow) {
      setStartRow(ByteBuffer.wrap(startRow));
      return this;
    }

    public scannerOpen_args setStartRow(ByteBuffer startRow) {
      this.startRow = startRow;
      return this;
    }

    public void unsetStartRow() {
      this.startRow = null;
    }

    /** Returns true if field startRow is set (has been asigned a value) and false otherwise */
    public boolean isSetStartRow() {
      return this.startRow != null;
    }

    public void setStartRowIsSet(boolean value) {
      if (!value) {
        this.startRow = null;
      }
    }

    public int getColumnsSize() {
      return (this.columns == null) ? 0 : this.columns.size();
    }

    public java.util.Iterator<ByteBuffer> getColumnsIterator() {
      return (this.columns == null) ? null : this.columns.iterator();
    }

    public void addToColumns(ByteBuffer elem) {
      if (this.columns == null) {
        this.columns = new ArrayList<ByteBuffer>();
      }
      this.columns.add(elem);
    }

    /**
     * columns to scan. If column name is a column family, all
     * columns of the specified column family are returned. It's also possible
     * to pass a regex in the column qualifier.
     */
    public List<ByteBuffer> getColumns() {
      return this.columns;
    }

    /**
     * columns to scan. If column name is a column family, all
     * columns of the specified column family are returned. It's also possible
     * to pass a regex in the column qualifier.
     */
    public scannerOpen_args setColumns(List<ByteBuffer> columns) {
      this.columns = columns;
      return this;
    }

    public void unsetColumns() {
      this.columns = null;
    }

    /** Returns true if field columns is set (has been asigned a value) and false otherwise */
    public boolean isSetColumns() {
      return this.columns != null;
    }

    public void setColumnsIsSet(boolean value) {
      if (!value) {
        this.columns = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TABLE_NAME:
        if (value == null) {
          unsetTableName();
        } else {
          setTableName((ByteBuffer)value);
        }
        break;

      case START_ROW:
        if (value == null) {
          unsetStartRow();
        } else {
          setStartRow((ByteBuffer)value);
        }
        break;

      case COLUMNS:
        if (value == null) {
          unsetColumns();
        } else {
          setColumns((List<ByteBuffer>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return getTableName();

      case START_ROW:
        return getStartRow();

      case COLUMNS:
        return getColumns();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case TABLE_NAME:
        return isSetTableName();
      case START_ROW:
        return isSetStartRow();
      case COLUMNS:
        return isSetColumns();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof scannerOpen_args)
        return this.equals((scannerOpen_args)that);
      return false;
    }

    public boolean equals(scannerOpen_args that) {
      if (that == null)
        return false;

      boolean this_present_tableName = true && this.isSetTableName();
      boolean that_present_tableName = true && that.isSetTableName();
      if (this_present_tableName || that_present_tableName) {
        if (!(this_present_tableName && that_present_tableName))
          return false;
        if (!this.tableName.equals(that.tableName))
          return false;
      }

      boolean this_present_startRow = true && this.isSetStartRow();
      boolean that_present_startRow = true && that.isSetStartRow();
      if (this_present_startRow || that_present_startRow) {
        if (!(this_present_startRow && that_present_startRow))
          return false;
        if (!this.startRow.equals(that.startRow))
          return false;
      }

      boolean this_present_columns = true && this.isSetColumns();
      boolean that_present_columns = true && that.isSetColumns();
      if (this_present_columns || that_present_columns) {
        if (!(this_present_columns && that_present_columns))
          return false;
        if (!this.columns.equals(that.columns))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(scannerOpen_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      scannerOpen_args typedOther = (scannerOpen_args)other;

      lastComparison = Boolean.valueOf(isSetTableName()).compareTo(typedOther.isSetTableName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTableName()) {
        lastComparison = TBaseHelper.compareTo(this.tableName, typedOther.tableName);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetStartRow()).compareTo(typedOther.isSetStartRow());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetStartRow()) {
        lastComparison = TBaseHelper.compareTo(this.startRow, typedOther.startRow);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetColumns()).compareTo(typedOther.isSetColumns());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetColumns()) {
        lastComparison = TBaseHelper.compareTo(this.columns, typedOther.columns);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 1: // TABLE_NAME
            if (field.type == TType.STRING) {
              this.tableName = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // START_ROW
            if (field.type == TType.STRING) {
              this.startRow = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // COLUMNS
            if (field.type == TType.LIST) {
              {
                TList _list118 = iprot.readListBegin();
                this.columns = new ArrayList<ByteBuffer>(_list118.size);
                for (int _i119 = 0; _i119 < _list118.size; ++_i119)
                {
                  ByteBuffer _elem120;
                  _elem120 = iprot.readBinary();
                  this.columns.add(_elem120);
                }
                iprot.readListEnd();
              }
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tableName != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeBinary(this.tableName);
        oprot.writeFieldEnd();
      }
      if (this.startRow != null) {
        oprot.writeFieldBegin(START_ROW_FIELD_DESC);
        oprot.writeBinary(this.startRow);
        oprot.writeFieldEnd();
      }
      if (this.columns != null) {
        oprot.writeFieldBegin(COLUMNS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.columns.size()));
          for (ByteBuffer _iter121 : this.columns)
          {
            oprot.writeBinary(_iter121);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("scannerOpen_args(");
      boolean first = true;

      sb.append("tableName:");
      if (this.tableName == null) {
        sb.append("null");
      } else {
        sb.append(this.tableName);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("startRow:");
      if (this.startRow == null) {
        sb.append("null");
      } else {
        sb.append(this.startRow);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("columns:");
      if (this.columns == null) {
        sb.append("null");
      } else {
        sb.append(this.columns);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class scannerOpen_result implements TBase<scannerOpen_result, scannerOpen_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("scannerOpen_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.I32, (short)0);
    private static final TField IO_FIELD_DESC = new TField("io", TType.STRUCT, (short)1);

    public int success;
    public IOError io;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      IO((short)1, "io");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // IO
            return IO;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.I32          , "ScannerID")));
      tmpMap.put(_Fields.IO, new FieldMetaData("io", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(scannerOpen_result.class, metaDataMap);
    }

    public scannerOpen_result() {
    }

    public scannerOpen_result(
      int success,
      IOError io)
    {
      this();
      this.success = success;
      setSuccessIsSet(true);
      this.io = io;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public scannerOpen_result(scannerOpen_result other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.success = other.success;
      if (other.isSetIo()) {
        this.io = new IOError(other.io);
      }
    }

    public scannerOpen_result deepCopy() {
      return new scannerOpen_result(this);
    }

    @Override
    public void clear() {
      setSuccessIsSet(false);
      this.success = 0;
      this.io = null;
    }

    public int getSuccess() {
      return this.success;
    }

    public scannerOpen_result setSuccess(int success) {
      this.success = success;
      setSuccessIsSet(true);
      return this;
    }

    public void unsetSuccess() {
      __isset_bit_vector.clear(__SUCCESS_ISSET_ID);
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return __isset_bit_vector.get(__SUCCESS_ISSET_ID);
    }

    public void setSuccessIsSet(boolean value) {
      __isset_bit_vector.set(__SUCCESS_ISSET_ID, value);
    }

    public IOError getIo() {
      return this.io;
    }

    public scannerOpen_result setIo(IOError io) {
      this.io = io;
      return this;
    }

    public void unsetIo() {
      this.io = null;
    }

    /** Returns true if field io is set (has been asigned a value) and false otherwise */
    public boolean isSetIo() {
      return this.io != null;
    }

    public void setIoIsSet(boolean value) {
      if (!value) {
        this.io = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Integer)value);
        }
        break;

      case IO:
        if (value == null) {
          unsetIo();
        } else {
          setIo((IOError)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return new Integer(getSuccess());

      case IO:
        return getIo();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case IO:
        return isSetIo();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof scannerOpen_result)
        return this.equals((scannerOpen_result)that);
      return false;
    }

    public boolean equals(scannerOpen_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_io = true && this.isSetIo();
      boolean that_present_io = true && that.isSetIo();
      if (this_present_io || that_present_io) {
        if (!(this_present_io && that_present_io))
          return false;
        if (!this.io.equals(that.io))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(scannerOpen_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      scannerOpen_result typedOther = (scannerOpen_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetIo()).compareTo(typedOther.isSetIo());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetIo()) {
        lastComparison = TBaseHelper.compareTo(this.io, typedOther.io);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.I32) {
              this.success = iprot.readI32();
              setSuccessIsSet(true);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // IO
            if (field.type == TType.STRUCT) {
              this.io = new IOError();
              this.io.read(iprot);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeI32(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetIo()) {
        oprot.writeFieldBegin(IO_FIELD_DESC);
        this.io.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("scannerOpen_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("io:");
      if (this.io == null) {
        sb.append("null");
      } else {
        sb.append(this.io);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class scannerOpenWithStop_args implements TBase<scannerOpenWithStop_args, scannerOpenWithStop_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("scannerOpenWithStop_args");

    private static final TField TABLE_NAME_FIELD_DESC = new TField("tableName", TType.STRING, (short)1);
    private static final TField START_ROW_FIELD_DESC = new TField("startRow", TType.STRING, (short)2);
    private static final TField STOP_ROW_FIELD_DESC = new TField("stopRow", TType.STRING, (short)3);
    private static final TField COLUMNS_FIELD_DESC = new TField("columns", TType.LIST, (short)4);

    /**
     * name of table
     */
    public ByteBuffer tableName;
    /**
     * Starting row in table to scan.
     * Send "" (empty string) to start at the first row.
     */
    public ByteBuffer startRow;
    /**
     * row to stop scanning on. This row is *not* included in the
     * scanner's results
     */
    public ByteBuffer stopRow;
    /**
     * columns to scan. If column name is a column family, all
     * columns of the specified column family are returned. It's also possible
     * to pass a regex in the column qualifier.
     */
    public List<ByteBuffer> columns;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      /**
       * name of table
       */
      TABLE_NAME((short)1, "tableName"),
      /**
       * Starting row in table to scan.
       * Send "" (empty string) to start at the first row.
       */
      START_ROW((short)2, "startRow"),
      /**
       * row to stop scanning on. This row is *not* included in the
       * scanner's results
       */
      STOP_ROW((short)3, "stopRow"),
      /**
       * columns to scan. If column name is a column family, all
       * columns of the specified column family are returned. It's also possible
       * to pass a regex in the column qualifier.
       */
      COLUMNS((short)4, "columns");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // TABLE_NAME
            return TABLE_NAME;
          case 2: // START_ROW
            return START_ROW;
          case 3: // STOP_ROW
            return STOP_ROW;
          case 4: // COLUMNS
            return COLUMNS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.TABLE_NAME, new FieldMetaData("tableName", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Text")));
      tmpMap.put(_Fields.START_ROW, new FieldMetaData("startRow", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Text")));
      tmpMap.put(_Fields.STOP_ROW, new FieldMetaData("stopRow", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Text")));
      tmpMap.put(_Fields.COLUMNS, new FieldMetaData("columns", TFieldRequirementType.DEFAULT,
          new ListMetaData(TType.LIST,
              new FieldValueMetaData(TType.STRING              , "Text"))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(scannerOpenWithStop_args.class, metaDataMap);
    }

    public scannerOpenWithStop_args() {
    }

    public scannerOpenWithStop_args(
      ByteBuffer tableName,
      ByteBuffer startRow,
      ByteBuffer stopRow,
      List<ByteBuffer> columns)
    {
      this();
      this.tableName = tableName;
      this.startRow = startRow;
      this.stopRow = stopRow;
      this.columns = columns;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public scannerOpenWithStop_args(scannerOpenWithStop_args other) {
      if (other.isSetTableName()) {
        this.tableName = other.tableName;
      }
      if (other.isSetStartRow()) {
        this.startRow = other.startRow;
      }
      if (other.isSetStopRow()) {
        this.stopRow = other.stopRow;
      }
      if (other.isSetColumns()) {
        List<ByteBuffer> __this__columns = new ArrayList<ByteBuffer>();
        for (ByteBuffer other_element : other.columns) {
          __this__columns.add(other_element);
        }
        this.columns = __this__columns;
      }
    }

    public scannerOpenWithStop_args deepCopy() {
      return new scannerOpenWithStop_args(this);
    }

    @Override
    public void clear() {
      this.tableName = null;
      this.startRow = null;
      this.stopRow = null;
      this.columns = null;
    }

    /**
     * name of table
     */
    public byte[] getTableName() {
      setTableName(TBaseHelper.rightSize(tableName));
      return tableName.array();
    }

    public ByteBuffer BufferForTableName() {
      return tableName;
    }

    /**
     * name of table
     */
    public scannerOpenWithStop_args setTableName(byte[] tableName) {
      setTableName(ByteBuffer.wrap(tableName));
      return this;
    }

    public scannerOpenWithStop_args setTableName(ByteBuffer tableName) {
      this.tableName = tableName;
      return this;
    }

    public void unsetTableName() {
      this.tableName = null;
    }

    /** Returns true if field tableName is set (has been asigned a value) and false otherwise */
    public boolean isSetTableName() {
      return this.tableName != null;
    }

    public void setTableNameIsSet(boolean value) {
      if (!value) {
        this.tableName = null;
      }
    }

    /**
     * Starting row in table to scan.
     * Send "" (empty string) to start at the first row.
     */
    public byte[] getStartRow() {
      setStartRow(TBaseHelper.rightSize(startRow));
      return startRow.array();
    }

    public ByteBuffer BufferForStartRow() {
      return startRow;
    }

    /**
     * Starting row in table to scan.
     * Send "" (empty string) to start at the first row.
     */
    public scannerOpenWithStop_args setStartRow(byte[] startRow) {
      setStartRow(ByteBuffer.wrap(startRow));
      return this;
    }

    public scannerOpenWithStop_args setStartRow(ByteBuffer startRow) {
      this.startRow = startRow;
      return this;
    }

    public void unsetStartRow() {
      this.startRow = null;
    }

    /** Returns true if field startRow is set (has been asigned a value) and false otherwise */
    public boolean isSetStartRow() {
      return this.startRow != null;
    }

    public void setStartRowIsSet(boolean value) {
      if (!value) {
        this.startRow = null;
      }
    }

    /**
     * row to stop scanning on. This row is *not* included in the
     * scanner's results
     */
    public byte[] getStopRow() {
      setStopRow(TBaseHelper.rightSize(stopRow));
      return stopRow.array();
    }

    public ByteBuffer BufferForStopRow() {
      return stopRow;
    }

    /**
     * row to stop scanning on. This row is *not* included in the
     * scanner's results
     */
    public scannerOpenWithStop_args setStopRow(byte[] stopRow) {
      setStopRow(ByteBuffer.wrap(stopRow));
      return this;
    }

    public scannerOpenWithStop_args setStopRow(ByteBuffer stopRow) {
      this.stopRow = stopRow;
      return this;
    }

    public void unsetStopRow() {
      this.stopRow = null;
    }

    /** Returns true if field stopRow is set (has been asigned a value) and false otherwise */
    public boolean isSetStopRow() {
      return this.stopRow != null;
    }

    public void setStopRowIsSet(boolean value) {
      if (!value) {
        this.stopRow = null;
      }
    }

    public int getColumnsSize() {
      return (this.columns == null) ? 0 : this.columns.size();
    }

    public java.util.Iterator<ByteBuffer> getColumnsIterator() {
      return (this.columns == null) ? null : this.columns.iterator();
    }

    public void addToColumns(ByteBuffer elem) {
      if (this.columns == null) {
        this.columns = new ArrayList<ByteBuffer>();
      }
      this.columns.add(elem);
    }

    /**
     * columns to scan. If column name is a column family, all
     * columns of the specified column family are returned. It's also possible
     * to pass a regex in the column qualifier.
     */
    public List<ByteBuffer> getColumns() {
      return this.columns;
    }

    /**
     * columns to scan. If column name is a column family, all
     * columns of the specified column family are returned. It's also possible
     * to pass a regex in the column qualifier.
     */
    public scannerOpenWithStop_args setColumns(List<ByteBuffer> columns) {
      this.columns = columns;
      return this;
    }

    public void unsetColumns() {
      this.columns = null;
    }

    /** Returns true if field columns is set (has been asigned a value) and false otherwise */
    public boolean isSetColumns() {
      return this.columns != null;
    }

    public void setColumnsIsSet(boolean value) {
      if (!value) {
        this.columns = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TABLE_NAME:
        if (value == null) {
          unsetTableName();
        } else {
          setTableName((ByteBuffer)value);
        }
        break;

      case START_ROW:
        if (value == null) {
          unsetStartRow();
        } else {
          setStartRow((ByteBuffer)value);
        }
        break;

      case STOP_ROW:
        if (value == null) {
          unsetStopRow();
        } else {
          setStopRow((ByteBuffer)value);
        }
        break;

      case COLUMNS:
        if (value == null) {
          unsetColumns();
        } else {
          setColumns((List<ByteBuffer>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return getTableName();

      case START_ROW:
        return getStartRow();

      case STOP_ROW:
        return getStopRow();

      case COLUMNS:
        return getColumns();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case TABLE_NAME:
        return isSetTableName();
      case START_ROW:
        return isSetStartRow();
      case STOP_ROW:
        return isSetStopRow();
      case COLUMNS:
        return isSetColumns();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof scannerOpenWithStop_args)
        return this.equals((scannerOpenWithStop_args)that);
      return false;
    }

    public boolean equals(scannerOpenWithStop_args that) {
      if (that == null)
        return false;

      boolean this_present_tableName = true && this.isSetTableName();
      boolean that_present_tableName = true && that.isSetTableName();
      if (this_present_tableName || that_present_tableName) {
        if (!(this_present_tableName && that_present_tableName))
          return false;
        if (!this.tableName.equals(that.tableName))
          return false;
      }

      boolean this_present_startRow = true && this.isSetStartRow();
      boolean that_present_startRow = true && that.isSetStartRow();
      if (this_present_startRow || that_present_startRow) {
        if (!(this_present_startRow && that_present_startRow))
          return false;
        if (!this.startRow.equals(that.startRow))
          return false;
      }

      boolean this_present_stopRow = true && this.isSetStopRow();
      boolean that_present_stopRow = true && that.isSetStopRow();
      if (this_present_stopRow || that_present_stopRow) {
        if (!(this_present_stopRow && that_present_stopRow))
          return false;
        if (!this.stopRow.equals(that.stopRow))
          return false;
      }

      boolean this_present_columns = true && this.isSetColumns();
      boolean that_present_columns = true && that.isSetColumns();
      if (this_present_columns || that_present_columns) {
        if (!(this_present_columns && that_present_columns))
          return false;
        if (!this.columns.equals(that.columns))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(scannerOpenWithStop_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      scannerOpenWithStop_args typedOther = (scannerOpenWithStop_args)other;

      lastComparison = Boolean.valueOf(isSetTableName()).compareTo(typedOther.isSetTableName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTableName()) {
        lastComparison = TBaseHelper.compareTo(this.tableName, typedOther.tableName);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetStartRow()).compareTo(typedOther.isSetStartRow());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetStartRow()) {
        lastComparison = TBaseHelper.compareTo(this.startRow, typedOther.startRow);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetStopRow()).compareTo(typedOther.isSetStopRow());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetStopRow()) {
        lastComparison = TBaseHelper.compareTo(this.stopRow, typedOther.stopRow);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetColumns()).compareTo(typedOther.isSetColumns());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetColumns()) {
        lastComparison = TBaseHelper.compareTo(this.columns, typedOther.columns);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 1: // TABLE_NAME
            if (field.type == TType.STRING) {
              this.tableName = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // START_ROW
            if (field.type == TType.STRING) {
              this.startRow = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // STOP_ROW
            if (field.type == TType.STRING) {
              this.stopRow = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 4: // COLUMNS
            if (field.type == TType.LIST) {
              {
                TList _list122 = iprot.readListBegin();
                this.columns = new ArrayList<ByteBuffer>(_list122.size);
                for (int _i123 = 0; _i123 < _list122.size; ++_i123)
                {
                  ByteBuffer _elem124;
                  _elem124 = iprot.readBinary();
                  this.columns.add(_elem124);
                }
                iprot.readListEnd();
              }
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tableName != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeBinary(this.tableName);
        oprot.writeFieldEnd();
      }
      if (this.startRow != null) {
        oprot.writeFieldBegin(START_ROW_FIELD_DESC);
        oprot.writeBinary(this.startRow);
        oprot.writeFieldEnd();
      }
      if (this.stopRow != null) {
        oprot.writeFieldBegin(STOP_ROW_FIELD_DESC);
        oprot.writeBinary(this.stopRow);
        oprot.writeFieldEnd();
      }
      if (this.columns != null) {
        oprot.writeFieldBegin(COLUMNS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.columns.size()));
          for (ByteBuffer _iter125 : this.columns)
          {
            oprot.writeBinary(_iter125);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("scannerOpenWithStop_args(");
      boolean first = true;

      sb.append("tableName:");
      if (this.tableName == null) {
        sb.append("null");
      } else {
        sb.append(this.tableName);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("startRow:");
      if (this.startRow == null) {
        sb.append("null");
      } else {
        sb.append(this.startRow);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("stopRow:");
      if (this.stopRow == null) {
        sb.append("null");
      } else {
        sb.append(this.stopRow);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("columns:");
      if (this.columns == null) {
        sb.append("null");
      } else {
        sb.append(this.columns);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class scannerOpenWithStop_result implements TBase<scannerOpenWithStop_result, scannerOpenWithStop_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("scannerOpenWithStop_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.I32, (short)0);
    private static final TField IO_FIELD_DESC = new TField("io", TType.STRUCT, (short)1);

    public int success;
    public IOError io;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      IO((short)1, "io");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // IO
            return IO;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.I32          , "ScannerID")));
      tmpMap.put(_Fields.IO, new FieldMetaData("io", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(scannerOpenWithStop_result.class, metaDataMap);
    }

    public scannerOpenWithStop_result() {
    }

    public scannerOpenWithStop_result(
      int success,
      IOError io)
    {
      this();
      this.success = success;
      setSuccessIsSet(true);
      this.io = io;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public scannerOpenWithStop_result(scannerOpenWithStop_result other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.success = other.success;
      if (other.isSetIo()) {
        this.io = new IOError(other.io);
      }
    }

    public scannerOpenWithStop_result deepCopy() {
      return new scannerOpenWithStop_result(this);
    }

    @Override
    public void clear() {
      setSuccessIsSet(false);
      this.success = 0;
      this.io = null;
    }

    public int getSuccess() {
      return this.success;
    }

    public scannerOpenWithStop_result setSuccess(int success) {
      this.success = success;
      setSuccessIsSet(true);
      return this;
    }

    public void unsetSuccess() {
      __isset_bit_vector.clear(__SUCCESS_ISSET_ID);
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return __isset_bit_vector.get(__SUCCESS_ISSET_ID);
    }

    public void setSuccessIsSet(boolean value) {
      __isset_bit_vector.set(__SUCCESS_ISSET_ID, value);
    }

    public IOError getIo() {
      return this.io;
    }

    public scannerOpenWithStop_result setIo(IOError io) {
      this.io = io;
      return this;
    }

    public void unsetIo() {
      this.io = null;
    }

    /** Returns true if field io is set (has been asigned a value) and false otherwise */
    public boolean isSetIo() {
      return this.io != null;
    }

    public void setIoIsSet(boolean value) {
      if (!value) {
        this.io = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Integer)value);
        }
        break;

      case IO:
        if (value == null) {
          unsetIo();
        } else {
          setIo((IOError)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return new Integer(getSuccess());

      case IO:
        return getIo();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case IO:
        return isSetIo();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof scannerOpenWithStop_result)
        return this.equals((scannerOpenWithStop_result)that);
      return false;
    }

    public boolean equals(scannerOpenWithStop_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_io = true && this.isSetIo();
      boolean that_present_io = true && that.isSetIo();
      if (this_present_io || that_present_io) {
        if (!(this_present_io && that_present_io))
          return false;
        if (!this.io.equals(that.io))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(scannerOpenWithStop_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      scannerOpenWithStop_result typedOther = (scannerOpenWithStop_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetIo()).compareTo(typedOther.isSetIo());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetIo()) {
        lastComparison = TBaseHelper.compareTo(this.io, typedOther.io);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.I32) {
              this.success = iprot.readI32();
              setSuccessIsSet(true);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // IO
            if (field.type == TType.STRUCT) {
              this.io = new IOError();
              this.io.read(iprot);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeI32(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetIo()) {
        oprot.writeFieldBegin(IO_FIELD_DESC);
        this.io.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("scannerOpenWithStop_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("io:");
      if (this.io == null) {
        sb.append("null");
      } else {
        sb.append(this.io);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class scannerOpenWithPrefix_args implements TBase<scannerOpenWithPrefix_args, scannerOpenWithPrefix_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("scannerOpenWithPrefix_args");

    private static final TField TABLE_NAME_FIELD_DESC = new TField("tableName", TType.STRING, (short)1);
    private static final TField START_AND_PREFIX_FIELD_DESC = new TField("startAndPrefix", TType.STRING, (short)2);
    private static final TField COLUMNS_FIELD_DESC = new TField("columns", TType.LIST, (short)3);

    /**
     * name of table
     */
    public ByteBuffer tableName;
    /**
     * the prefix (and thus start row) of the keys you want
     */
    public ByteBuffer startAndPrefix;
    /**
     * the columns you want returned
     */
    public List<ByteBuffer> columns;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      /**
       * name of table
       */
      TABLE_NAME((short)1, "tableName"),
      /**
       * the prefix (and thus start row) of the keys you want
       */
      START_AND_PREFIX((short)2, "startAndPrefix"),
      /**
       * the columns you want returned
       */
      COLUMNS((short)3, "columns");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // TABLE_NAME
            return TABLE_NAME;
          case 2: // START_AND_PREFIX
            return START_AND_PREFIX;
          case 3: // COLUMNS
            return COLUMNS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.TABLE_NAME, new FieldMetaData("tableName", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Text")));
      tmpMap.put(_Fields.START_AND_PREFIX, new FieldMetaData("startAndPrefix", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Text")));
      tmpMap.put(_Fields.COLUMNS, new FieldMetaData("columns", TFieldRequirementType.DEFAULT,
          new ListMetaData(TType.LIST,
              new FieldValueMetaData(TType.STRING              , "Text"))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(scannerOpenWithPrefix_args.class, metaDataMap);
    }

    public scannerOpenWithPrefix_args() {
    }

    public scannerOpenWithPrefix_args(
      ByteBuffer tableName,
      ByteBuffer startAndPrefix,
      List<ByteBuffer> columns)
    {
      this();
      this.tableName = tableName;
      this.startAndPrefix = startAndPrefix;
      this.columns = columns;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public scannerOpenWithPrefix_args(scannerOpenWithPrefix_args other) {
      if (other.isSetTableName()) {
        this.tableName = other.tableName;
      }
      if (other.isSetStartAndPrefix()) {
        this.startAndPrefix = other.startAndPrefix;
      }
      if (other.isSetColumns()) {
        List<ByteBuffer> __this__columns = new ArrayList<ByteBuffer>();
        for (ByteBuffer other_element : other.columns) {
          __this__columns.add(other_element);
        }
        this.columns = __this__columns;
      }
    }

    public scannerOpenWithPrefix_args deepCopy() {
      return new scannerOpenWithPrefix_args(this);
    }

    @Override
    public void clear() {
      this.tableName = null;
      this.startAndPrefix = null;
      this.columns = null;
    }

    /**
     * name of table
     */
    public byte[] getTableName() {
      setTableName(TBaseHelper.rightSize(tableName));
      return tableName.array();
    }

    public ByteBuffer BufferForTableName() {
      return tableName;
    }

    /**
     * name of table
     */
    public scannerOpenWithPrefix_args setTableName(byte[] tableName) {
      setTableName(ByteBuffer.wrap(tableName));
      return this;
    }

    public scannerOpenWithPrefix_args setTableName(ByteBuffer tableName) {
      this.tableName = tableName;
      return this;
    }

    public void unsetTableName() {
      this.tableName = null;
    }

    /** Returns true if field tableName is set (has been asigned a value) and false otherwise */
    public boolean isSetTableName() {
      return this.tableName != null;
    }

    public void setTableNameIsSet(boolean value) {
      if (!value) {
        this.tableName = null;
      }
    }

    /**
     * the prefix (and thus start row) of the keys you want
     */
    public byte[] getStartAndPrefix() {
      setStartAndPrefix(TBaseHelper.rightSize(startAndPrefix));
      return startAndPrefix.array();
    }

    public ByteBuffer BufferForStartAndPrefix() {
      return startAndPrefix;
    }

    /**
     * the prefix (and thus start row) of the keys you want
     */
    public scannerOpenWithPrefix_args setStartAndPrefix(byte[] startAndPrefix) {
      setStartAndPrefix(ByteBuffer.wrap(startAndPrefix));
      return this;
    }

    public scannerOpenWithPrefix_args setStartAndPrefix(ByteBuffer startAndPrefix) {
      this.startAndPrefix = startAndPrefix;
      return this;
    }

    public void unsetStartAndPrefix() {
      this.startAndPrefix = null;
    }

    /** Returns true if field startAndPrefix is set (has been asigned a value) and false otherwise */
    public boolean isSetStartAndPrefix() {
      return this.startAndPrefix != null;
    }

    public void setStartAndPrefixIsSet(boolean value) {
      if (!value) {
        this.startAndPrefix = null;
      }
    }

    public int getColumnsSize() {
      return (this.columns == null) ? 0 : this.columns.size();
    }

    public java.util.Iterator<ByteBuffer> getColumnsIterator() {
      return (this.columns == null) ? null : this.columns.iterator();
    }

    public void addToColumns(ByteBuffer elem) {
      if (this.columns == null) {
        this.columns = new ArrayList<ByteBuffer>();
      }
      this.columns.add(elem);
    }

    /**
     * the columns you want returned
     */
    public List<ByteBuffer> getColumns() {
      return this.columns;
    }

    /**
     * the columns you want returned
     */
    public scannerOpenWithPrefix_args setColumns(List<ByteBuffer> columns) {
      this.columns = columns;
      return this;
    }

    public void unsetColumns() {
      this.columns = null;
    }

    /** Returns true if field columns is set (has been asigned a value) and false otherwise */
    public boolean isSetColumns() {
      return this.columns != null;
    }

    public void setColumnsIsSet(boolean value) {
      if (!value) {
        this.columns = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TABLE_NAME:
        if (value == null) {
          unsetTableName();
        } else {
          setTableName((ByteBuffer)value);
        }
        break;

      case START_AND_PREFIX:
        if (value == null) {
          unsetStartAndPrefix();
        } else {
          setStartAndPrefix((ByteBuffer)value);
        }
        break;

      case COLUMNS:
        if (value == null) {
          unsetColumns();
        } else {
          setColumns((List<ByteBuffer>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return getTableName();

      case START_AND_PREFIX:
        return getStartAndPrefix();

      case COLUMNS:
        return getColumns();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case TABLE_NAME:
        return isSetTableName();
      case START_AND_PREFIX:
        return isSetStartAndPrefix();
      case COLUMNS:
        return isSetColumns();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof scannerOpenWithPrefix_args)
        return this.equals((scannerOpenWithPrefix_args)that);
      return false;
    }

    public boolean equals(scannerOpenWithPrefix_args that) {
      if (that == null)
        return false;

      boolean this_present_tableName = true && this.isSetTableName();
      boolean that_present_tableName = true && that.isSetTableName();
      if (this_present_tableName || that_present_tableName) {
        if (!(this_present_tableName && that_present_tableName))
          return false;
        if (!this.tableName.equals(that.tableName))
          return false;
      }

      boolean this_present_startAndPrefix = true && this.isSetStartAndPrefix();
      boolean that_present_startAndPrefix = true && that.isSetStartAndPrefix();
      if (this_present_startAndPrefix || that_present_startAndPrefix) {
        if (!(this_present_startAndPrefix && that_present_startAndPrefix))
          return false;
        if (!this.startAndPrefix.equals(that.startAndPrefix))
          return false;
      }

      boolean this_present_columns = true && this.isSetColumns();
      boolean that_present_columns = true && that.isSetColumns();
      if (this_present_columns || that_present_columns) {
        if (!(this_present_columns && that_present_columns))
          return false;
        if (!this.columns.equals(that.columns))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(scannerOpenWithPrefix_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      scannerOpenWithPrefix_args typedOther = (scannerOpenWithPrefix_args)other;

      lastComparison = Boolean.valueOf(isSetTableName()).compareTo(typedOther.isSetTableName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTableName()) {
        lastComparison = TBaseHelper.compareTo(this.tableName, typedOther.tableName);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetStartAndPrefix()).compareTo(typedOther.isSetStartAndPrefix());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetStartAndPrefix()) {
        lastComparison = TBaseHelper.compareTo(this.startAndPrefix, typedOther.startAndPrefix);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetColumns()).compareTo(typedOther.isSetColumns());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetColumns()) {
        lastComparison = TBaseHelper.compareTo(this.columns, typedOther.columns);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 1: // TABLE_NAME
            if (field.type == TType.STRING) {
              this.tableName = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // START_AND_PREFIX
            if (field.type == TType.STRING) {
              this.startAndPrefix = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // COLUMNS
            if (field.type == TType.LIST) {
              {
                TList _list126 = iprot.readListBegin();
                this.columns = new ArrayList<ByteBuffer>(_list126.size);
                for (int _i127 = 0; _i127 < _list126.size; ++_i127)
                {
                  ByteBuffer _elem128;
                  _elem128 = iprot.readBinary();
                  this.columns.add(_elem128);
                }
                iprot.readListEnd();
              }
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tableName != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeBinary(this.tableName);
        oprot.writeFieldEnd();
      }
      if (this.startAndPrefix != null) {
        oprot.writeFieldBegin(START_AND_PREFIX_FIELD_DESC);
        oprot.writeBinary(this.startAndPrefix);
        oprot.writeFieldEnd();
      }
      if (this.columns != null) {
        oprot.writeFieldBegin(COLUMNS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.columns.size()));
          for (ByteBuffer _iter129 : this.columns)
          {
            oprot.writeBinary(_iter129);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("scannerOpenWithPrefix_args(");
      boolean first = true;

      sb.append("tableName:");
      if (this.tableName == null) {
        sb.append("null");
      } else {
        sb.append(this.tableName);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("startAndPrefix:");
      if (this.startAndPrefix == null) {
        sb.append("null");
      } else {
        sb.append(this.startAndPrefix);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("columns:");
      if (this.columns == null) {
        sb.append("null");
      } else {
        sb.append(this.columns);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class scannerOpenWithPrefix_result implements TBase<scannerOpenWithPrefix_result, scannerOpenWithPrefix_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("scannerOpenWithPrefix_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.I32, (short)0);
    private static final TField IO_FIELD_DESC = new TField("io", TType.STRUCT, (short)1);

    public int success;
    public IOError io;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      IO((short)1, "io");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // IO
            return IO;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.I32          , "ScannerID")));
      tmpMap.put(_Fields.IO, new FieldMetaData("io", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(scannerOpenWithPrefix_result.class, metaDataMap);
    }

    public scannerOpenWithPrefix_result() {
    }

    public scannerOpenWithPrefix_result(
      int success,
      IOError io)
    {
      this();
      this.success = success;
      setSuccessIsSet(true);
      this.io = io;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public scannerOpenWithPrefix_result(scannerOpenWithPrefix_result other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.success = other.success;
      if (other.isSetIo()) {
        this.io = new IOError(other.io);
      }
    }

    public scannerOpenWithPrefix_result deepCopy() {
      return new scannerOpenWithPrefix_result(this);
    }

    @Override
    public void clear() {
      setSuccessIsSet(false);
      this.success = 0;
      this.io = null;
    }

    public int getSuccess() {
      return this.success;
    }

    public scannerOpenWithPrefix_result setSuccess(int success) {
      this.success = success;
      setSuccessIsSet(true);
      return this;
    }

    public void unsetSuccess() {
      __isset_bit_vector.clear(__SUCCESS_ISSET_ID);
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return __isset_bit_vector.get(__SUCCESS_ISSET_ID);
    }

    public void setSuccessIsSet(boolean value) {
      __isset_bit_vector.set(__SUCCESS_ISSET_ID, value);
    }

    public IOError getIo() {
      return this.io;
    }

    public scannerOpenWithPrefix_result setIo(IOError io) {
      this.io = io;
      return this;
    }

    public void unsetIo() {
      this.io = null;
    }

    /** Returns true if field io is set (has been asigned a value) and false otherwise */
    public boolean isSetIo() {
      return this.io != null;
    }

    public void setIoIsSet(boolean value) {
      if (!value) {
        this.io = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Integer)value);
        }
        break;

      case IO:
        if (value == null) {
          unsetIo();
        } else {
          setIo((IOError)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return new Integer(getSuccess());

      case IO:
        return getIo();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case IO:
        return isSetIo();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof scannerOpenWithPrefix_result)
        return this.equals((scannerOpenWithPrefix_result)that);
      return false;
    }

    public boolean equals(scannerOpenWithPrefix_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_io = true && this.isSetIo();
      boolean that_present_io = true && that.isSetIo();
      if (this_present_io || that_present_io) {
        if (!(this_present_io && that_present_io))
          return false;
        if (!this.io.equals(that.io))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(scannerOpenWithPrefix_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      scannerOpenWithPrefix_result typedOther = (scannerOpenWithPrefix_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetIo()).compareTo(typedOther.isSetIo());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetIo()) {
        lastComparison = TBaseHelper.compareTo(this.io, typedOther.io);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.I32) {
              this.success = iprot.readI32();
              setSuccessIsSet(true);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // IO
            if (field.type == TType.STRUCT) {
              this.io = new IOError();
              this.io.read(iprot);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeI32(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetIo()) {
        oprot.writeFieldBegin(IO_FIELD_DESC);
        this.io.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("scannerOpenWithPrefix_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("io:");
      if (this.io == null) {
        sb.append("null");
      } else {
        sb.append(this.io);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class scannerOpenTs_args implements TBase<scannerOpenTs_args, scannerOpenTs_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("scannerOpenTs_args");

    private static final TField TABLE_NAME_FIELD_DESC = new TField("tableName", TType.STRING, (short)1);
    private static final TField START_ROW_FIELD_DESC = new TField("startRow", TType.STRING, (short)2);
    private static final TField COLUMNS_FIELD_DESC = new TField("columns", TType.LIST, (short)3);
    private static final TField TIMESTAMP_FIELD_DESC = new TField("timestamp", TType.I64, (short)4);

    /**
     * name of table
     */
    public ByteBuffer tableName;
    /**
     * Starting row in table to scan.
     * Send "" (empty string) to start at the first row.
     */
    public ByteBuffer startRow;
    /**
     * columns to scan. If column name is a column family, all
     * columns of the specified column family are returned. It's also possible
     * to pass a regex in the column qualifier.
     */
    public List<ByteBuffer> columns;
    /**
     * timestamp
     */
    public long timestamp;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      /**
       * name of table
       */
      TABLE_NAME((short)1, "tableName"),
      /**
       * Starting row in table to scan.
       * Send "" (empty string) to start at the first row.
       */
      START_ROW((short)2, "startRow"),
      /**
       * columns to scan. If column name is a column family, all
       * columns of the specified column family are returned. It's also possible
       * to pass a regex in the column qualifier.
       */
      COLUMNS((short)3, "columns"),
      /**
       * timestamp
       */
      TIMESTAMP((short)4, "timestamp");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // TABLE_NAME
            return TABLE_NAME;
          case 2: // START_ROW
            return START_ROW;
          case 3: // COLUMNS
            return COLUMNS;
          case 4: // TIMESTAMP
            return TIMESTAMP;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __TIMESTAMP_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.TABLE_NAME, new FieldMetaData("tableName", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Text")));
      tmpMap.put(_Fields.START_ROW, new FieldMetaData("startRow", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Text")));
      tmpMap.put(_Fields.COLUMNS, new FieldMetaData("columns", TFieldRequirementType.DEFAULT,
          new ListMetaData(TType.LIST,
              new FieldValueMetaData(TType.STRING              , "Text"))));
      tmpMap.put(_Fields.TIMESTAMP, new FieldMetaData("timestamp", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.I64)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(scannerOpenTs_args.class, metaDataMap);
    }

    public scannerOpenTs_args() {
    }

    public scannerOpenTs_args(
      ByteBuffer tableName,
      ByteBuffer startRow,
      List<ByteBuffer> columns,
      long timestamp)
    {
      this();
      this.tableName = tableName;
      this.startRow = startRow;
      this.columns = columns;
      this.timestamp = timestamp;
      setTimestampIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public scannerOpenTs_args(scannerOpenTs_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      if (other.isSetTableName()) {
        this.tableName = other.tableName;
      }
      if (other.isSetStartRow()) {
        this.startRow = other.startRow;
      }
      if (other.isSetColumns()) {
        List<ByteBuffer> __this__columns = new ArrayList<ByteBuffer>();
        for (ByteBuffer other_element : other.columns) {
          __this__columns.add(other_element);
        }
        this.columns = __this__columns;
      }
      this.timestamp = other.timestamp;
    }

    public scannerOpenTs_args deepCopy() {
      return new scannerOpenTs_args(this);
    }

    @Override
    public void clear() {
      this.tableName = null;
      this.startRow = null;
      this.columns = null;
      setTimestampIsSet(false);
      this.timestamp = 0;
    }

    /**
     * name of table
     */
    public byte[] getTableName() {
      setTableName(TBaseHelper.rightSize(tableName));
      return tableName.array();
    }

    public ByteBuffer BufferForTableName() {
      return tableName;
    }

    /**
     * name of table
     */
    public scannerOpenTs_args setTableName(byte[] tableName) {
      setTableName(ByteBuffer.wrap(tableName));
      return this;
    }

    public scannerOpenTs_args setTableName(ByteBuffer tableName) {
      this.tableName = tableName;
      return this;
    }

    public void unsetTableName() {
      this.tableName = null;
    }

    /** Returns true if field tableName is set (has been asigned a value) and false otherwise */
    public boolean isSetTableName() {
      return this.tableName != null;
    }

    public void setTableNameIsSet(boolean value) {
      if (!value) {
        this.tableName = null;
      }
    }

    /**
     * Starting row in table to scan.
     * Send "" (empty string) to start at the first row.
     */
    public byte[] getStartRow() {
      setStartRow(TBaseHelper.rightSize(startRow));
      return startRow.array();
    }

    public ByteBuffer BufferForStartRow() {
      return startRow;
    }

    /**
     * Starting row in table to scan.
     * Send "" (empty string) to start at the first row.
     */
    public scannerOpenTs_args setStartRow(byte[] startRow) {
      setStartRow(ByteBuffer.wrap(startRow));
      return this;
    }

    public scannerOpenTs_args setStartRow(ByteBuffer startRow) {
      this.startRow = startRow;
      return this;
    }

    public void unsetStartRow() {
      this.startRow = null;
    }

    /** Returns true if field startRow is set (has been asigned a value) and false otherwise */
    public boolean isSetStartRow() {
      return this.startRow != null;
    }

    public void setStartRowIsSet(boolean value) {
      if (!value) {
        this.startRow = null;
      }
    }

    public int getColumnsSize() {
      return (this.columns == null) ? 0 : this.columns.size();
    }

    public java.util.Iterator<ByteBuffer> getColumnsIterator() {
      return (this.columns == null) ? null : this.columns.iterator();
    }

    public void addToColumns(ByteBuffer elem) {
      if (this.columns == null) {
        this.columns = new ArrayList<ByteBuffer>();
      }
      this.columns.add(elem);
    }

    /**
     * columns to scan. If column name is a column family, all
     * columns of the specified column family are returned. It's also possible
     * to pass a regex in the column qualifier.
     */
    public List<ByteBuffer> getColumns() {
      return this.columns;
    }

    /**
     * columns to scan. If column name is a column family, all
     * columns of the specified column family are returned. It's also possible
     * to pass a regex in the column qualifier.
     */
    public scannerOpenTs_args setColumns(List<ByteBuffer> columns) {
      this.columns = columns;
      return this;
    }

    public void unsetColumns() {
      this.columns = null;
    }

    /** Returns true if field columns is set (has been asigned a value) and false otherwise */
    public boolean isSetColumns() {
      return this.columns != null;
    }

    public void setColumnsIsSet(boolean value) {
      if (!value) {
        this.columns = null;
      }
    }

    /**
     * timestamp
     */
    public long getTimestamp() {
      return this.timestamp;
    }

    /**
     * timestamp
     */
    public scannerOpenTs_args setTimestamp(long timestamp) {
      this.timestamp = timestamp;
      setTimestampIsSet(true);
      return this;
    }

    public void unsetTimestamp() {
      __isset_bit_vector.clear(__TIMESTAMP_ISSET_ID);
    }

    /** Returns true if field timestamp is set (has been asigned a value) and false otherwise */
    public boolean isSetTimestamp() {
      return __isset_bit_vector.get(__TIMESTAMP_ISSET_ID);
    }

    public void setTimestampIsSet(boolean value) {
      __isset_bit_vector.set(__TIMESTAMP_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TABLE_NAME:
        if (value == null) {
          unsetTableName();
        } else {
          setTableName((ByteBuffer)value);
        }
        break;

      case START_ROW:
        if (value == null) {
          unsetStartRow();
        } else {
          setStartRow((ByteBuffer)value);
        }
        break;

      case COLUMNS:
        if (value == null) {
          unsetColumns();
        } else {
          setColumns((List<ByteBuffer>)value);
        }
        break;

      case TIMESTAMP:
        if (value == null) {
          unsetTimestamp();
        } else {
          setTimestamp((Long)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return getTableName();

      case START_ROW:
        return getStartRow();

      case COLUMNS:
        return getColumns();

      case TIMESTAMP:
        return new Long(getTimestamp());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case TABLE_NAME:
        return isSetTableName();
      case START_ROW:
        return isSetStartRow();
      case COLUMNS:
        return isSetColumns();
      case TIMESTAMP:
        return isSetTimestamp();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof scannerOpenTs_args)
        return this.equals((scannerOpenTs_args)that);
      return false;
    }

    public boolean equals(scannerOpenTs_args that) {
      if (that == null)
        return false;

      boolean this_present_tableName = true && this.isSetTableName();
      boolean that_present_tableName = true && that.isSetTableName();
      if (this_present_tableName || that_present_tableName) {
        if (!(this_present_tableName && that_present_tableName))
          return false;
        if (!this.tableName.equals(that.tableName))
          return false;
      }

      boolean this_present_startRow = true && this.isSetStartRow();
      boolean that_present_startRow = true && that.isSetStartRow();
      if (this_present_startRow || that_present_startRow) {
        if (!(this_present_startRow && that_present_startRow))
          return false;
        if (!this.startRow.equals(that.startRow))
          return false;
      }

      boolean this_present_columns = true && this.isSetColumns();
      boolean that_present_columns = true && that.isSetColumns();
      if (this_present_columns || that_present_columns) {
        if (!(this_present_columns && that_present_columns))
          return false;
        if (!this.columns.equals(that.columns))
          return false;
      }

      boolean this_present_timestamp = true;
      boolean that_present_timestamp = true;
      if (this_present_timestamp || that_present_timestamp) {
        if (!(this_present_timestamp && that_present_timestamp))
          return false;
        if (this.timestamp != that.timestamp)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(scannerOpenTs_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      scannerOpenTs_args typedOther = (scannerOpenTs_args)other;

      lastComparison = Boolean.valueOf(isSetTableName()).compareTo(typedOther.isSetTableName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTableName()) {
        lastComparison = TBaseHelper.compareTo(this.tableName, typedOther.tableName);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetStartRow()).compareTo(typedOther.isSetStartRow());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetStartRow()) {
        lastComparison = TBaseHelper.compareTo(this.startRow, typedOther.startRow);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetColumns()).compareTo(typedOther.isSetColumns());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetColumns()) {
        lastComparison = TBaseHelper.compareTo(this.columns, typedOther.columns);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetTimestamp()).compareTo(typedOther.isSetTimestamp());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTimestamp()) {
        lastComparison = TBaseHelper.compareTo(this.timestamp, typedOther.timestamp);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 1: // TABLE_NAME
            if (field.type == TType.STRING) {
              this.tableName = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // START_ROW
            if (field.type == TType.STRING) {
              this.startRow = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // COLUMNS
            if (field.type == TType.LIST) {
              {
                TList _list130 = iprot.readListBegin();
                this.columns = new ArrayList<ByteBuffer>(_list130.size);
                for (int _i131 = 0; _i131 < _list130.size; ++_i131)
                {
                  ByteBuffer _elem132;
                  _elem132 = iprot.readBinary();
                  this.columns.add(_elem132);
                }
                iprot.readListEnd();
              }
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 4: // TIMESTAMP
            if (field.type == TType.I64) {
              this.timestamp = iprot.readI64();
              setTimestampIsSet(true);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tableName != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeBinary(this.tableName);
        oprot.writeFieldEnd();
      }
      if (this.startRow != null) {
        oprot.writeFieldBegin(START_ROW_FIELD_DESC);
        oprot.writeBinary(this.startRow);
        oprot.writeFieldEnd();
      }
      if (this.columns != null) {
        oprot.writeFieldBegin(COLUMNS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.columns.size()));
          for (ByteBuffer _iter133 : this.columns)
          {
            oprot.writeBinary(_iter133);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(TIMESTAMP_FIELD_DESC);
      oprot.writeI64(this.timestamp);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("scannerOpenTs_args(");
      boolean first = true;

      sb.append("tableName:");
      if (this.tableName == null) {
        sb.append("null");
      } else {
        sb.append(this.tableName);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("startRow:");
      if (this.startRow == null) {
        sb.append("null");
      } else {
        sb.append(this.startRow);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("columns:");
      if (this.columns == null) {
        sb.append("null");
      } else {
        sb.append(this.columns);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("timestamp:");
      sb.append(this.timestamp);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class scannerOpenTs_result implements TBase<scannerOpenTs_result, scannerOpenTs_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("scannerOpenTs_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.I32, (short)0);
    private static final TField IO_FIELD_DESC = new TField("io", TType.STRUCT, (short)1);

    public int success;
    public IOError io;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      IO((short)1, "io");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // IO
            return IO;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.I32          , "ScannerID")));
      tmpMap.put(_Fields.IO, new FieldMetaData("io", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(scannerOpenTs_result.class, metaDataMap);
    }

    public scannerOpenTs_result() {
    }

    public scannerOpenTs_result(
      int success,
      IOError io)
    {
      this();
      this.success = success;
      setSuccessIsSet(true);
      this.io = io;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public scannerOpenTs_result(scannerOpenTs_result other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.success = other.success;
      if (other.isSetIo()) {
        this.io = new IOError(other.io);
      }
    }

    public scannerOpenTs_result deepCopy() {
      return new scannerOpenTs_result(this);
    }

    @Override
    public void clear() {
      setSuccessIsSet(false);
      this.success = 0;
      this.io = null;
    }

    public int getSuccess() {
      return this.success;
    }

    public scannerOpenTs_result setSuccess(int success) {
      this.success = success;
      setSuccessIsSet(true);
      return this;
    }

    public void unsetSuccess() {
      __isset_bit_vector.clear(__SUCCESS_ISSET_ID);
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return __isset_bit_vector.get(__SUCCESS_ISSET_ID);
    }

    public void setSuccessIsSet(boolean value) {
      __isset_bit_vector.set(__SUCCESS_ISSET_ID, value);
    }

    public IOError getIo() {
      return this.io;
    }

    public scannerOpenTs_result setIo(IOError io) {
      this.io = io;
      return this;
    }

    public void unsetIo() {
      this.io = null;
    }

    /** Returns true if field io is set (has been asigned a value) and false otherwise */
    public boolean isSetIo() {
      return this.io != null;
    }

    public void setIoIsSet(boolean value) {
      if (!value) {
        this.io = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Integer)value);
        }
        break;

      case IO:
        if (value == null) {
          unsetIo();
        } else {
          setIo((IOError)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return new Integer(getSuccess());

      case IO:
        return getIo();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case IO:
        return isSetIo();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof scannerOpenTs_result)
        return this.equals((scannerOpenTs_result)that);
      return false;
    }

    public boolean equals(scannerOpenTs_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_io = true && this.isSetIo();
      boolean that_present_io = true && that.isSetIo();
      if (this_present_io || that_present_io) {
        if (!(this_present_io && that_present_io))
          return false;
        if (!this.io.equals(that.io))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(scannerOpenTs_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      scannerOpenTs_result typedOther = (scannerOpenTs_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetIo()).compareTo(typedOther.isSetIo());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetIo()) {
        lastComparison = TBaseHelper.compareTo(this.io, typedOther.io);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.I32) {
              this.success = iprot.readI32();
              setSuccessIsSet(true);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // IO
            if (field.type == TType.STRUCT) {
              this.io = new IOError();
              this.io.read(iprot);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeI32(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetIo()) {
        oprot.writeFieldBegin(IO_FIELD_DESC);
        this.io.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("scannerOpenTs_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("io:");
      if (this.io == null) {
        sb.append("null");
      } else {
        sb.append(this.io);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class scannerOpenWithStopTs_args implements TBase<scannerOpenWithStopTs_args, scannerOpenWithStopTs_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("scannerOpenWithStopTs_args");

    private static final TField TABLE_NAME_FIELD_DESC = new TField("tableName", TType.STRING, (short)1);
    private static final TField START_ROW_FIELD_DESC = new TField("startRow", TType.STRING, (short)2);
    private static final TField STOP_ROW_FIELD_DESC = new TField("stopRow", TType.STRING, (short)3);
    private static final TField COLUMNS_FIELD_DESC = new TField("columns", TType.LIST, (short)4);
    private static final TField TIMESTAMP_FIELD_DESC = new TField("timestamp", TType.I64, (short)5);

    /**
     * name of table
     */
    public ByteBuffer tableName;
    /**
     * Starting row in table to scan.
     * Send "" (empty string) to start at the first row.
     */
    public ByteBuffer startRow;
    /**
     * row to stop scanning on. This row is *not* included in the
     * scanner's results
     */
    public ByteBuffer stopRow;
    /**
     * columns to scan. If column name is a column family, all
     * columns of the specified column family are returned. It's also possible
     * to pass a regex in the column qualifier.
     */
    public List<ByteBuffer> columns;
    /**
     * timestamp
     */
    public long timestamp;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      /**
       * name of table
       */
      TABLE_NAME((short)1, "tableName"),
      /**
       * Starting row in table to scan.
       * Send "" (empty string) to start at the first row.
       */
      START_ROW((short)2, "startRow"),
      /**
       * row to stop scanning on. This row is *not* included in the
       * scanner's results
       */
      STOP_ROW((short)3, "stopRow"),
      /**
       * columns to scan. If column name is a column family, all
       * columns of the specified column family are returned. It's also possible
       * to pass a regex in the column qualifier.
       */
      COLUMNS((short)4, "columns"),
      /**
       * timestamp
       */
      TIMESTAMP((short)5, "timestamp");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // TABLE_NAME
            return TABLE_NAME;
          case 2: // START_ROW
            return START_ROW;
          case 3: // STOP_ROW
            return STOP_ROW;
          case 4: // COLUMNS
            return COLUMNS;
          case 5: // TIMESTAMP
            return TIMESTAMP;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __TIMESTAMP_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.TABLE_NAME, new FieldMetaData("tableName", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Text")));
      tmpMap.put(_Fields.START_ROW, new FieldMetaData("startRow", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Text")));
      tmpMap.put(_Fields.STOP_ROW, new FieldMetaData("stopRow", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Text")));
      tmpMap.put(_Fields.COLUMNS, new FieldMetaData("columns", TFieldRequirementType.DEFAULT,
          new ListMetaData(TType.LIST,
              new FieldValueMetaData(TType.STRING              , "Text"))));
      tmpMap.put(_Fields.TIMESTAMP, new FieldMetaData("timestamp", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.I64)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(scannerOpenWithStopTs_args.class, metaDataMap);
    }

    public scannerOpenWithStopTs_args() {
    }

    public scannerOpenWithStopTs_args(
      ByteBuffer tableName,
      ByteBuffer startRow,
      ByteBuffer stopRow,
      List<ByteBuffer> columns,
      long timestamp)
    {
      this();
      this.tableName = tableName;
      this.startRow = startRow;
      this.stopRow = stopRow;
      this.columns = columns;
      this.timestamp = timestamp;
      setTimestampIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public scannerOpenWithStopTs_args(scannerOpenWithStopTs_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      if (other.isSetTableName()) {
        this.tableName = other.tableName;
      }
      if (other.isSetStartRow()) {
        this.startRow = other.startRow;
      }
      if (other.isSetStopRow()) {
        this.stopRow = other.stopRow;
      }
      if (other.isSetColumns()) {
        List<ByteBuffer> __this__columns = new ArrayList<ByteBuffer>();
        for (ByteBuffer other_element : other.columns) {
          __this__columns.add(other_element);
        }
        this.columns = __this__columns;
      }
      this.timestamp = other.timestamp;
    }

    public scannerOpenWithStopTs_args deepCopy() {
      return new scannerOpenWithStopTs_args(this);
    }

    @Override
    public void clear() {
      this.tableName = null;
      this.startRow = null;
      this.stopRow = null;
      this.columns = null;
      setTimestampIsSet(false);
      this.timestamp = 0;
    }

    /**
     * name of table
     */
    public byte[] getTableName() {
      setTableName(TBaseHelper.rightSize(tableName));
      return tableName.array();
    }

    public ByteBuffer BufferForTableName() {
      return tableName;
    }

    /**
     * name of table
     */
    public scannerOpenWithStopTs_args setTableName(byte[] tableName) {
      setTableName(ByteBuffer.wrap(tableName));
      return this;
    }

    public scannerOpenWithStopTs_args setTableName(ByteBuffer tableName) {
      this.tableName = tableName;
      return this;
    }

    public void unsetTableName() {
      this.tableName = null;
    }

    /** Returns true if field tableName is set (has been asigned a value) and false otherwise */
    public boolean isSetTableName() {
      return this.tableName != null;
    }

    public void setTableNameIsSet(boolean value) {
      if (!value) {
        this.tableName = null;
      }
    }

    /**
     * Starting row in table to scan.
     * Send "" (empty string) to start at the first row.
     */
    public byte[] getStartRow() {
      setStartRow(TBaseHelper.rightSize(startRow));
      return startRow.array();
    }

    public ByteBuffer BufferForStartRow() {
      return startRow;
    }

    /**
     * Starting row in table to scan.
     * Send "" (empty string) to start at the first row.
     */
    public scannerOpenWithStopTs_args setStartRow(byte[] startRow) {
      setStartRow(ByteBuffer.wrap(startRow));
      return this;
    }

    public scannerOpenWithStopTs_args setStartRow(ByteBuffer startRow) {
      this.startRow = startRow;
      return this;
    }

    public void unsetStartRow() {
      this.startRow = null;
    }

    /** Returns true if field startRow is set (has been asigned a value) and false otherwise */
    public boolean isSetStartRow() {
      return this.startRow != null;
    }

    public void setStartRowIsSet(boolean value) {
      if (!value) {
        this.startRow = null;
      }
    }

    /**
     * row to stop scanning on. This row is *not* included in the
     * scanner's results
     */
    public byte[] getStopRow() {
      setStopRow(TBaseHelper.rightSize(stopRow));
      return stopRow.array();
    }

    public ByteBuffer BufferForStopRow() {
      return stopRow;
    }

    /**
     * row to stop scanning on. This row is *not* included in the
     * scanner's results
     */
    public scannerOpenWithStopTs_args setStopRow(byte[] stopRow) {
      setStopRow(ByteBuffer.wrap(stopRow));
      return this;
    }

    public scannerOpenWithStopTs_args setStopRow(ByteBuffer stopRow) {
      this.stopRow = stopRow;
      return this;
    }

    public void unsetStopRow() {
      this.stopRow = null;
    }

    /** Returns true if field stopRow is set (has been asigned a value) and false otherwise */
    public boolean isSetStopRow() {
      return this.stopRow != null;
    }

    public void setStopRowIsSet(boolean value) {
      if (!value) {
        this.stopRow = null;
      }
    }

    public int getColumnsSize() {
      return (this.columns == null) ? 0 : this.columns.size();
    }

    public java.util.Iterator<ByteBuffer> getColumnsIterator() {
      return (this.columns == null) ? null : this.columns.iterator();
    }

    public void addToColumns(ByteBuffer elem) {
      if (this.columns == null) {
        this.columns = new ArrayList<ByteBuffer>();
      }
      this.columns.add(elem);
    }

    /**
     * columns to scan. If column name is a column family, all
     * columns of the specified column family are returned. It's also possible
     * to pass a regex in the column qualifier.
     */
    public List<ByteBuffer> getColumns() {
      return this.columns;
    }

    /**
     * columns to scan. If column name is a column family, all
     * columns of the specified column family are returned. It's also possible
     * to pass a regex in the column qualifier.
     */
    public scannerOpenWithStopTs_args setColumns(List<ByteBuffer> columns) {
      this.columns = columns;
      return this;
    }

    public void unsetColumns() {
      this.columns = null;
    }

    /** Returns true if field columns is set (has been asigned a value) and false otherwise */
    public boolean isSetColumns() {
      return this.columns != null;
    }

    public void setColumnsIsSet(boolean value) {
      if (!value) {
        this.columns = null;
      }
    }

    /**
     * timestamp
     */
    public long getTimestamp() {
      return this.timestamp;
    }

    /**
     * timestamp
     */
    public scannerOpenWithStopTs_args setTimestamp(long timestamp) {
      this.timestamp = timestamp;
      setTimestampIsSet(true);
      return this;
    }

    public void unsetTimestamp() {
      __isset_bit_vector.clear(__TIMESTAMP_ISSET_ID);
    }

    /** Returns true if field timestamp is set (has been asigned a value) and false otherwise */
    public boolean isSetTimestamp() {
      return __isset_bit_vector.get(__TIMESTAMP_ISSET_ID);
    }

    public void setTimestampIsSet(boolean value) {
      __isset_bit_vector.set(__TIMESTAMP_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TABLE_NAME:
        if (value == null) {
          unsetTableName();
        } else {
          setTableName((ByteBuffer)value);
        }
        break;

      case START_ROW:
        if (value == null) {
          unsetStartRow();
        } else {
          setStartRow((ByteBuffer)value);
        }
        break;

      case STOP_ROW:
        if (value == null) {
          unsetStopRow();
        } else {
          setStopRow((ByteBuffer)value);
        }
        break;

      case COLUMNS:
        if (value == null) {
          unsetColumns();
        } else {
          setColumns((List<ByteBuffer>)value);
        }
        break;

      case TIMESTAMP:
        if (value == null) {
          unsetTimestamp();
        } else {
          setTimestamp((Long)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return getTableName();

      case START_ROW:
        return getStartRow();

      case STOP_ROW:
        return getStopRow();

      case COLUMNS:
        return getColumns();

      case TIMESTAMP:
        return new Long(getTimestamp());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case TABLE_NAME:
        return isSetTableName();
      case START_ROW:
        return isSetStartRow();
      case STOP_ROW:
        return isSetStopRow();
      case COLUMNS:
        return isSetColumns();
      case TIMESTAMP:
        return isSetTimestamp();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof scannerOpenWithStopTs_args)
        return this.equals((scannerOpenWithStopTs_args)that);
      return false;
    }

    public boolean equals(scannerOpenWithStopTs_args that) {
      if (that == null)
        return false;

      boolean this_present_tableName = true && this.isSetTableName();
      boolean that_present_tableName = true && that.isSetTableName();
      if (this_present_tableName || that_present_tableName) {
        if (!(this_present_tableName && that_present_tableName))
          return false;
        if (!this.tableName.equals(that.tableName))
          return false;
      }

      boolean this_present_startRow = true && this.isSetStartRow();
      boolean that_present_startRow = true && that.isSetStartRow();
      if (this_present_startRow || that_present_startRow) {
        if (!(this_present_startRow && that_present_startRow))
          return false;
        if (!this.startRow.equals(that.startRow))
          return false;
      }

      boolean this_present_stopRow = true && this.isSetStopRow();
      boolean that_present_stopRow = true && that.isSetStopRow();
      if (this_present_stopRow || that_present_stopRow) {
        if (!(this_present_stopRow && that_present_stopRow))
          return false;
        if (!this.stopRow.equals(that.stopRow))
          return false;
      }

      boolean this_present_columns = true && this.isSetColumns();
      boolean that_present_columns = true && that.isSetColumns();
      if (this_present_columns || that_present_columns) {
        if (!(this_present_columns && that_present_columns))
          return false;
        if (!this.columns.equals(that.columns))
          return false;
      }

      boolean this_present_timestamp = true;
      boolean that_present_timestamp = true;
      if (this_present_timestamp || that_present_timestamp) {
        if (!(this_present_timestamp && that_present_timestamp))
          return false;
        if (this.timestamp != that.timestamp)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(scannerOpenWithStopTs_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      scannerOpenWithStopTs_args typedOther = (scannerOpenWithStopTs_args)other;

      lastComparison = Boolean.valueOf(isSetTableName()).compareTo(typedOther.isSetTableName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTableName()) {
        lastComparison = TBaseHelper.compareTo(this.tableName, typedOther.tableName);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetStartRow()).compareTo(typedOther.isSetStartRow());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetStartRow()) {
        lastComparison = TBaseHelper.compareTo(this.startRow, typedOther.startRow);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetStopRow()).compareTo(typedOther.isSetStopRow());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetStopRow()) {
        lastComparison = TBaseHelper.compareTo(this.stopRow, typedOther.stopRow);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetColumns()).compareTo(typedOther.isSetColumns());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetColumns()) {
        lastComparison = TBaseHelper.compareTo(this.columns, typedOther.columns);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetTimestamp()).compareTo(typedOther.isSetTimestamp());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTimestamp()) {
        lastComparison = TBaseHelper.compareTo(this.timestamp, typedOther.timestamp);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 1: // TABLE_NAME
            if (field.type == TType.STRING) {
              this.tableName = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // START_ROW
            if (field.type == TType.STRING) {
              this.startRow = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // STOP_ROW
            if (field.type == TType.STRING) {
              this.stopRow = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 4: // COLUMNS
            if (field.type == TType.LIST) {
              {
                TList _list134 = iprot.readListBegin();
                this.columns = new ArrayList<ByteBuffer>(_list134.size);
                for (int _i135 = 0; _i135 < _list134.size; ++_i135)
                {
                  ByteBuffer _elem136;
                  _elem136 = iprot.readBinary();
                  this.columns.add(_elem136);
                }
                iprot.readListEnd();
              }
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 5: // TIMESTAMP
            if (field.type == TType.I64) {
              this.timestamp = iprot.readI64();
              setTimestampIsSet(true);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tableName != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeBinary(this.tableName);
        oprot.writeFieldEnd();
      }
      if (this.startRow != null) {
        oprot.writeFieldBegin(START_ROW_FIELD_DESC);
        oprot.writeBinary(this.startRow);
        oprot.writeFieldEnd();
      }
      if (this.stopRow != null) {
        oprot.writeFieldBegin(STOP_ROW_FIELD_DESC);
        oprot.writeBinary(this.stopRow);
        oprot.writeFieldEnd();
      }
      if (this.columns != null) {
        oprot.writeFieldBegin(COLUMNS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.columns.size()));
          for (ByteBuffer _iter137 : this.columns)
          {
            oprot.writeBinary(_iter137);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(TIMESTAMP_FIELD_DESC);
      oprot.writeI64(this.timestamp);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("scannerOpenWithStopTs_args(");
      boolean first = true;

      sb.append("tableName:");
      if (this.tableName == null) {
        sb.append("null");
      } else {
        sb.append(this.tableName);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("startRow:");
      if (this.startRow == null) {
        sb.append("null");
      } else {
        sb.append(this.startRow);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("stopRow:");
      if (this.stopRow == null) {
        sb.append("null");
      } else {
        sb.append(this.stopRow);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("columns:");
      if (this.columns == null) {
        sb.append("null");
      } else {
        sb.append(this.columns);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("timestamp:");
      sb.append(this.timestamp);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class scannerOpenWithStopTs_result implements TBase<scannerOpenWithStopTs_result, scannerOpenWithStopTs_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("scannerOpenWithStopTs_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.I32, (short)0);
    private static final TField IO_FIELD_DESC = new TField("io", TType.STRUCT, (short)1);

    public int success;
    public IOError io;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      IO((short)1, "io");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // IO
            return IO;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.I32          , "ScannerID")));
      tmpMap.put(_Fields.IO, new FieldMetaData("io", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(scannerOpenWithStopTs_result.class, metaDataMap);
    }

    public scannerOpenWithStopTs_result() {
    }

    public scannerOpenWithStopTs_result(
      int success,
      IOError io)
    {
      this();
      this.success = success;
      setSuccessIsSet(true);
      this.io = io;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public scannerOpenWithStopTs_result(scannerOpenWithStopTs_result other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.success = other.success;
      if (other.isSetIo()) {
        this.io = new IOError(other.io);
      }
    }

    public scannerOpenWithStopTs_result deepCopy() {
      return new scannerOpenWithStopTs_result(this);
    }

    @Override
    public void clear() {
      setSuccessIsSet(false);
      this.success = 0;
      this.io = null;
    }

    public int getSuccess() {
      return this.success;
    }

    public scannerOpenWithStopTs_result setSuccess(int success) {
      this.success = success;
      setSuccessIsSet(true);
      return this;
    }

    public void unsetSuccess() {
      __isset_bit_vector.clear(__SUCCESS_ISSET_ID);
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return __isset_bit_vector.get(__SUCCESS_ISSET_ID);
    }

    public void setSuccessIsSet(boolean value) {
      __isset_bit_vector.set(__SUCCESS_ISSET_ID, value);
    }

    public IOError getIo() {
      return this.io;
    }

    public scannerOpenWithStopTs_result setIo(IOError io) {
      this.io = io;
      return this;
    }

    public void unsetIo() {
      this.io = null;
    }

    /** Returns true if field io is set (has been asigned a value) and false otherwise */
    public boolean isSetIo() {
      return this.io != null;
    }

    public void setIoIsSet(boolean value) {
      if (!value) {
        this.io = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Integer)value);
        }
        break;

      case IO:
        if (value == null) {
          unsetIo();
        } else {
          setIo((IOError)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return new Integer(getSuccess());

      case IO:
        return getIo();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case IO:
        return isSetIo();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof scannerOpenWithStopTs_result)
        return this.equals((scannerOpenWithStopTs_result)that);
      return false;
    }

    public boolean equals(scannerOpenWithStopTs_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_io = true && this.isSetIo();
      boolean that_present_io = true && that.isSetIo();
      if (this_present_io || that_present_io) {
        if (!(this_present_io && that_present_io))
          return false;
        if (!this.io.equals(that.io))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(scannerOpenWithStopTs_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      scannerOpenWithStopTs_result typedOther = (scannerOpenWithStopTs_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetIo()).compareTo(typedOther.isSetIo());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetIo()) {
        lastComparison = TBaseHelper.compareTo(this.io, typedOther.io);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.I32) {
              this.success = iprot.readI32();
              setSuccessIsSet(true);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // IO
            if (field.type == TType.STRUCT) {
              this.io = new IOError();
              this.io.read(iprot);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeI32(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetIo()) {
        oprot.writeFieldBegin(IO_FIELD_DESC);
        this.io.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("scannerOpenWithStopTs_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("io:");
      if (this.io == null) {
        sb.append("null");
      } else {
        sb.append(this.io);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class scannerGet_args implements TBase<scannerGet_args, scannerGet_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("scannerGet_args");

    private static final TField ID_FIELD_DESC = new TField("id", TType.I32, (short)1);

    /**
     * id of a scanner returned by scannerOpen
     */
    public int id;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      /**
       * id of a scanner returned by scannerOpen
       */
      ID((short)1, "id");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // ID
            return ID;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __ID_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.ID, new FieldMetaData("id", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.I32          , "ScannerID")));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(scannerGet_args.class, metaDataMap);
    }

    public scannerGet_args() {
    }

    public scannerGet_args(
      int id)
    {
      this();
      this.id = id;
      setIdIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public scannerGet_args(scannerGet_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.id = other.id;
    }

    public scannerGet_args deepCopy() {
      return new scannerGet_args(this);
    }

    @Override
    public void clear() {
      setIdIsSet(false);
      this.id = 0;
    }

    /**
     * id of a scanner returned by scannerOpen
     */
    public int getId() {
      return this.id;
    }

    /**
     * id of a scanner returned by scannerOpen
     */
    public scannerGet_args setId(int id) {
      this.id = id;
      setIdIsSet(true);
      return this;
    }

    public void unsetId() {
      __isset_bit_vector.clear(__ID_ISSET_ID);
    }

    /** Returns true if field id is set (has been asigned a value) and false otherwise */
    public boolean isSetId() {
      return __isset_bit_vector.get(__ID_ISSET_ID);
    }

    public void setIdIsSet(boolean value) {
      __isset_bit_vector.set(__ID_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case ID:
        if (value == null) {
          unsetId();
        } else {
          setId((Integer)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case ID:
        return new Integer(getId());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case ID:
        return isSetId();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof scannerGet_args)
        return this.equals((scannerGet_args)that);
      return false;
    }

    public boolean equals(scannerGet_args that) {
      if (that == null)
        return false;

      boolean this_present_id = true;
      boolean that_present_id = true;
      if (this_present_id || that_present_id) {
        if (!(this_present_id && that_present_id))
          return false;
        if (this.id != that.id)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(scannerGet_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      scannerGet_args typedOther = (scannerGet_args)other;

      lastComparison = Boolean.valueOf(isSetId()).compareTo(typedOther.isSetId());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetId()) {
        lastComparison = TBaseHelper.compareTo(this.id, typedOther.id);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 1: // ID
            if (field.type == TType.I32) {
              this.id = iprot.readI32();
              setIdIsSet(true);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(ID_FIELD_DESC);
      oprot.writeI32(this.id);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("scannerGet_args(");
      boolean first = true;

      sb.append("id:");
      sb.append(this.id);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class scannerGet_result implements TBase<scannerGet_result, scannerGet_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("scannerGet_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField IO_FIELD_DESC = new TField("io", TType.STRUCT, (short)1);
    private static final TField IA_FIELD_DESC = new TField("ia", TType.STRUCT, (short)2);

    public List<TRowResult> success;
    public IOError io;
    public IllegalArgument ia;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      IO((short)1, "io"),
      IA((short)2, "ia");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // IO
            return IO;
          case 2: // IA
            return IA;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT,
          new ListMetaData(TType.LIST,
              new StructMetaData(TType.STRUCT, TRowResult.class))));
      tmpMap.put(_Fields.IO, new FieldMetaData("io", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRUCT)));
      tmpMap.put(_Fields.IA, new FieldMetaData("ia", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(scannerGet_result.class, metaDataMap);
    }

    public scannerGet_result() {
    }

    public scannerGet_result(
      List<TRowResult> success,
      IOError io,
      IllegalArgument ia)
    {
      this();
      this.success = success;
      this.io = io;
      this.ia = ia;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public scannerGet_result(scannerGet_result other) {
      if (other.isSetSuccess()) {
        List<TRowResult> __this__success = new ArrayList<TRowResult>();
        for (TRowResult other_element : other.success) {
          __this__success.add(new TRowResult(other_element));
        }
        this.success = __this__success;
      }
      if (other.isSetIo()) {
        this.io = new IOError(other.io);
      }
      if (other.isSetIa()) {
        this.ia = new IllegalArgument(other.ia);
      }
    }

    public scannerGet_result deepCopy() {
      return new scannerGet_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.io = null;
      this.ia = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<TRowResult> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(TRowResult elem) {
      if (this.success == null) {
        this.success = new ArrayList<TRowResult>();
      }
      this.success.add(elem);
    }

    public List<TRowResult> getSuccess() {
      return this.success;
    }

    public scannerGet_result setSuccess(List<TRowResult> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public IOError getIo() {
      return this.io;
    }

    public scannerGet_result setIo(IOError io) {
      this.io = io;
      return this;
    }

    public void unsetIo() {
      this.io = null;
    }

    /** Returns true if field io is set (has been asigned a value) and false otherwise */
    public boolean isSetIo() {
      return this.io != null;
    }

    public void setIoIsSet(boolean value) {
      if (!value) {
        this.io = null;
      }
    }

    public IllegalArgument getIa() {
      return this.ia;
    }

    public scannerGet_result setIa(IllegalArgument ia) {
      this.ia = ia;
      return this;
    }

    public void unsetIa() {
      this.ia = null;
    }

    /** Returns true if field ia is set (has been asigned a value) and false otherwise */
    public boolean isSetIa() {
      return this.ia != null;
    }

    public void setIaIsSet(boolean value) {
      if (!value) {
        this.ia = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<TRowResult>)value);
        }
        break;

      case IO:
        if (value == null) {
          unsetIo();
        } else {
          setIo((IOError)value);
        }
        break;

      case IA:
        if (value == null) {
          unsetIa();
        } else {
          setIa((IllegalArgument)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case IO:
        return getIo();

      case IA:
        return getIa();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case IO:
        return isSetIo();
      case IA:
        return isSetIa();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof scannerGet_result)
        return this.equals((scannerGet_result)that);
      return false;
    }

    public boolean equals(scannerGet_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_io = true && this.isSetIo();
      boolean that_present_io = true && that.isSetIo();
      if (this_present_io || that_present_io) {
        if (!(this_present_io && that_present_io))
          return false;
        if (!this.io.equals(that.io))
          return false;
      }

      boolean this_present_ia = true && this.isSetIa();
      boolean that_present_ia = true && that.isSetIa();
      if (this_present_ia || that_present_ia) {
        if (!(this_present_ia && that_present_ia))
          return false;
        if (!this.ia.equals(that.ia))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(scannerGet_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      scannerGet_result typedOther = (scannerGet_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetIo()).compareTo(typedOther.isSetIo());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetIo()) {
        lastComparison = TBaseHelper.compareTo(this.io, typedOther.io);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetIa()).compareTo(typedOther.isSetIa());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetIa()) {
        lastComparison = TBaseHelper.compareTo(this.ia, typedOther.ia);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list138 = iprot.readListBegin();
                this.success = new ArrayList<TRowResult>(_list138.size);
                for (int _i139 = 0; _i139 < _list138.size; ++_i139)
                {
                  TRowResult _elem140;
                  _elem140 = new TRowResult();
                  _elem140.read(iprot);
                  this.success.add(_elem140);
                }
                iprot.readListEnd();
              }
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // IO
            if (field.type == TType.STRUCT) {
              this.io = new IOError();
              this.io.read(iprot);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // IA
            if (field.type == TType.STRUCT) {
              this.ia = new IllegalArgument();
              this.ia.read(iprot);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (TRowResult _iter141 : this.success)
          {
            _iter141.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetIo()) {
        oprot.writeFieldBegin(IO_FIELD_DESC);
        this.io.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetIa()) {
        oprot.writeFieldBegin(IA_FIELD_DESC);
        this.ia.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("scannerGet_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("io:");
      if (this.io == null) {
        sb.append("null");
      } else {
        sb.append(this.io);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ia:");
      if (this.ia == null) {
        sb.append("null");
      } else {
        sb.append(this.ia);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class scannerGetList_args implements TBase<scannerGetList_args, scannerGetList_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("scannerGetList_args");

    private static final TField ID_FIELD_DESC = new TField("id", TType.I32, (short)1);
    private static final TField NB_ROWS_FIELD_DESC = new TField("nbRows", TType.I32, (short)2);

    /**
     * id of a scanner returned by scannerOpen
     */
    public int id;
    /**
     * number of results to return
     */
    public int nbRows;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      /**
       * id of a scanner returned by scannerOpen
       */
      ID((short)1, "id"),
      /**
       * number of results to return
       */
      NB_ROWS((short)2, "nbRows");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // ID
            return ID;
          case 2: // NB_ROWS
            return NB_ROWS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __ID_ISSET_ID = 0;
    private static final int __NBROWS_ISSET_ID = 1;
    private BitSet __isset_bit_vector = new BitSet(2);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.ID, new FieldMetaData("id", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.I32          , "ScannerID")));
      tmpMap.put(_Fields.NB_ROWS, new FieldMetaData("nbRows", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.I32)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(scannerGetList_args.class, metaDataMap);
    }

    public scannerGetList_args() {
    }

    public scannerGetList_args(
      int id,
      int nbRows)
    {
      this();
      this.id = id;
      setIdIsSet(true);
      this.nbRows = nbRows;
      setNbRowsIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public scannerGetList_args(scannerGetList_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.id = other.id;
      this.nbRows = other.nbRows;
    }

    public scannerGetList_args deepCopy() {
      return new scannerGetList_args(this);
    }

    @Override
    public void clear() {
      setIdIsSet(false);
      this.id = 0;
      setNbRowsIsSet(false);
      this.nbRows = 0;
    }

    /**
     * id of a scanner returned by scannerOpen
     */
    public int getId() {
      return this.id;
    }

    /**
     * id of a scanner returned by scannerOpen
     */
    public scannerGetList_args setId(int id) {
      this.id = id;
      setIdIsSet(true);
      return this;
    }

    public void unsetId() {
      __isset_bit_vector.clear(__ID_ISSET_ID);
    }

    /** Returns true if field id is set (has been asigned a value) and false otherwise */
    public boolean isSetId() {
      return __isset_bit_vector.get(__ID_ISSET_ID);
    }

    public void setIdIsSet(boolean value) {
      __isset_bit_vector.set(__ID_ISSET_ID, value);
    }

    /**
     * number of results to return
     */
    public int getNbRows() {
      return this.nbRows;
    }

    /**
     * number of results to return
     */
    public scannerGetList_args setNbRows(int nbRows) {
      this.nbRows = nbRows;
      setNbRowsIsSet(true);
      return this;
    }

    public void unsetNbRows() {
      __isset_bit_vector.clear(__NBROWS_ISSET_ID);
    }

    /** Returns true if field nbRows is set (has been asigned a value) and false otherwise */
    public boolean isSetNbRows() {
      return __isset_bit_vector.get(__NBROWS_ISSET_ID);
    }

    public void setNbRowsIsSet(boolean value) {
      __isset_bit_vector.set(__NBROWS_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case ID:
        if (value == null) {
          unsetId();
        } else {
          setId((Integer)value);
        }
        break;

      case NB_ROWS:
        if (value == null) {
          unsetNbRows();
        } else {
          setNbRows((Integer)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case ID:
        return new Integer(getId());

      case NB_ROWS:
        return new Integer(getNbRows());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case ID:
        return isSetId();
      case NB_ROWS:
        return isSetNbRows();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof scannerGetList_args)
        return this.equals((scannerGetList_args)that);
      return false;
    }

    public boolean equals(scannerGetList_args that) {
      if (that == null)
        return false;

      boolean this_present_id = true;
      boolean that_present_id = true;
      if (this_present_id || that_present_id) {
        if (!(this_present_id && that_present_id))
          return false;
        if (this.id != that.id)
          return false;
      }

      boolean this_present_nbRows = true;
      boolean that_present_nbRows = true;
      if (this_present_nbRows || that_present_nbRows) {
        if (!(this_present_nbRows && that_present_nbRows))
          return false;
        if (this.nbRows != that.nbRows)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(scannerGetList_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      scannerGetList_args typedOther = (scannerGetList_args)other;

      lastComparison = Boolean.valueOf(isSetId()).compareTo(typedOther.isSetId());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetId()) {
        lastComparison = TBaseHelper.compareTo(this.id, typedOther.id);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetNbRows()).compareTo(typedOther.isSetNbRows());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetNbRows()) {
        lastComparison = TBaseHelper.compareTo(this.nbRows, typedOther.nbRows);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 1: // ID
            if (field.type == TType.I32) {
              this.id = iprot.readI32();
              setIdIsSet(true);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // NB_ROWS
            if (field.type == TType.I32) {
              this.nbRows = iprot.readI32();
              setNbRowsIsSet(true);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(ID_FIELD_DESC);
      oprot.writeI32(this.id);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(NB_ROWS_FIELD_DESC);
      oprot.writeI32(this.nbRows);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("scannerGetList_args(");
      boolean first = true;

      sb.append("id:");
      sb.append(this.id);
      first = false;
      if (!first) sb.append(", ");
      sb.append("nbRows:");
      sb.append(this.nbRows);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class scannerGetList_result implements TBase<scannerGetList_result, scannerGetList_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("scannerGetList_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField IO_FIELD_DESC = new TField("io", TType.STRUCT, (short)1);
    private static final TField IA_FIELD_DESC = new TField("ia", TType.STRUCT, (short)2);

    public List<TRowResult> success;
    public IOError io;
    public IllegalArgument ia;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      IO((short)1, "io"),
      IA((short)2, "ia");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // IO
            return IO;
          case 2: // IA
            return IA;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT,
          new ListMetaData(TType.LIST,
              new StructMetaData(TType.STRUCT, TRowResult.class))));
      tmpMap.put(_Fields.IO, new FieldMetaData("io", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRUCT)));
      tmpMap.put(_Fields.IA, new FieldMetaData("ia", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(scannerGetList_result.class, metaDataMap);
    }

    public scannerGetList_result() {
    }

    public scannerGetList_result(
      List<TRowResult> success,
      IOError io,
      IllegalArgument ia)
    {
      this();
      this.success = success;
      this.io = io;
      this.ia = ia;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public scannerGetList_result(scannerGetList_result other) {
      if (other.isSetSuccess()) {
        List<TRowResult> __this__success = new ArrayList<TRowResult>();
        for (TRowResult other_element : other.success) {
          __this__success.add(new TRowResult(other_element));
        }
        this.success = __this__success;
      }
      if (other.isSetIo()) {
        this.io = new IOError(other.io);
      }
      if (other.isSetIa()) {
        this.ia = new IllegalArgument(other.ia);
      }
    }

    public scannerGetList_result deepCopy() {
      return new scannerGetList_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.io = null;
      this.ia = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<TRowResult> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(TRowResult elem) {
      if (this.success == null) {
        this.success = new ArrayList<TRowResult>();
      }
      this.success.add(elem);
    }

    public List<TRowResult> getSuccess() {
      return this.success;
    }

    public scannerGetList_result setSuccess(List<TRowResult> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public IOError getIo() {
      return this.io;
    }

    public scannerGetList_result setIo(IOError io) {
      this.io = io;
      return this;
    }

    public void unsetIo() {
      this.io = null;
    }

    /** Returns true if field io is set (has been asigned a value) and false otherwise */
    public boolean isSetIo() {
      return this.io != null;
    }

    public void setIoIsSet(boolean value) {
      if (!value) {
        this.io = null;
      }
    }

    public IllegalArgument getIa() {
      return this.ia;
    }

    public scannerGetList_result setIa(IllegalArgument ia) {
      this.ia = ia;
      return this;
    }

    public void unsetIa() {
      this.ia = null;
    }

    /** Returns true if field ia is set (has been asigned a value) and false otherwise */
    public boolean isSetIa() {
      return this.ia != null;
    }

    public void setIaIsSet(boolean value) {
      if (!value) {
        this.ia = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<TRowResult>)value);
        }
        break;

      case IO:
        if (value == null) {
          unsetIo();
        } else {
          setIo((IOError)value);
        }
        break;

      case IA:
        if (value == null) {
          unsetIa();
        } else {
          setIa((IllegalArgument)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case IO:
        return getIo();

      case IA:
        return getIa();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case IO:
        return isSetIo();
      case IA:
        return isSetIa();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof scannerGetList_result)
        return this.equals((scannerGetList_result)that);
      return false;
    }

    public boolean equals(scannerGetList_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_io = true && this.isSetIo();
      boolean that_present_io = true && that.isSetIo();
      if (this_present_io || that_present_io) {
        if (!(this_present_io && that_present_io))
          return false;
        if (!this.io.equals(that.io))
          return false;
      }

      boolean this_present_ia = true && this.isSetIa();
      boolean that_present_ia = true && that.isSetIa();
      if (this_present_ia || that_present_ia) {
        if (!(this_present_ia && that_present_ia))
          return false;
        if (!this.ia.equals(that.ia))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(scannerGetList_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      scannerGetList_result typedOther = (scannerGetList_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetIo()).compareTo(typedOther.isSetIo());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetIo()) {
        lastComparison = TBaseHelper.compareTo(this.io, typedOther.io);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetIa()).compareTo(typedOther.isSetIa());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetIa()) {
        lastComparison = TBaseHelper.compareTo(this.ia, typedOther.ia);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list142 = iprot.readListBegin();
                this.success = new ArrayList<TRowResult>(_list142.size);
                for (int _i143 = 0; _i143 < _list142.size; ++_i143)
                {
                  TRowResult _elem144;
                  _elem144 = new TRowResult();
                  _elem144.read(iprot);
                  this.success.add(_elem144);
                }
                iprot.readListEnd();
              }
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // IO
            if (field.type == TType.STRUCT) {
              this.io = new IOError();
              this.io.read(iprot);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // IA
            if (field.type == TType.STRUCT) {
              this.ia = new IllegalArgument();
              this.ia.read(iprot);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (TRowResult _iter145 : this.success)
          {
            _iter145.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetIo()) {
        oprot.writeFieldBegin(IO_FIELD_DESC);
        this.io.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetIa()) {
        oprot.writeFieldBegin(IA_FIELD_DESC);
        this.ia.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("scannerGetList_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("io:");
      if (this.io == null) {
        sb.append("null");
      } else {
        sb.append(this.io);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ia:");
      if (this.ia == null) {
        sb.append("null");
      } else {
        sb.append(this.ia);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class scannerClose_args implements TBase<scannerClose_args, scannerClose_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("scannerClose_args");

    private static final TField ID_FIELD_DESC = new TField("id", TType.I32, (short)1);

    /**
     * id of a scanner returned by scannerOpen
     */
    public int id;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      /**
       * id of a scanner returned by scannerOpen
       */
      ID((short)1, "id");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // ID
            return ID;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __ID_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.ID, new FieldMetaData("id", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.I32          , "ScannerID")));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(scannerClose_args.class, metaDataMap);
    }

    public scannerClose_args() {
    }

    public scannerClose_args(
      int id)
    {
      this();
      this.id = id;
      setIdIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public scannerClose_args(scannerClose_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.id = other.id;
    }

    public scannerClose_args deepCopy() {
      return new scannerClose_args(this);
    }

    @Override
    public void clear() {
      setIdIsSet(false);
      this.id = 0;
    }

    /**
     * id of a scanner returned by scannerOpen
     */
    public int getId() {
      return this.id;
    }

    /**
     * id of a scanner returned by scannerOpen
     */
    public scannerClose_args setId(int id) {
      this.id = id;
      setIdIsSet(true);
      return this;
    }

    public void unsetId() {
      __isset_bit_vector.clear(__ID_ISSET_ID);
    }

    /** Returns true if field id is set (has been asigned a value) and false otherwise */
    public boolean isSetId() {
      return __isset_bit_vector.get(__ID_ISSET_ID);
    }

    public void setIdIsSet(boolean value) {
      __isset_bit_vector.set(__ID_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case ID:
        if (value == null) {
          unsetId();
        } else {
          setId((Integer)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case ID:
        return new Integer(getId());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case ID:
        return isSetId();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof scannerClose_args)
        return this.equals((scannerClose_args)that);
      return false;
    }

    public boolean equals(scannerClose_args that) {
      if (that == null)
        return false;

      boolean this_present_id = true;
      boolean that_present_id = true;
      if (this_present_id || that_present_id) {
        if (!(this_present_id && that_present_id))
          return false;
        if (this.id != that.id)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(scannerClose_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      scannerClose_args typedOther = (scannerClose_args)other;

      lastComparison = Boolean.valueOf(isSetId()).compareTo(typedOther.isSetId());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetId()) {
        lastComparison = TBaseHelper.compareTo(this.id, typedOther.id);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 1: // ID
            if (field.type == TType.I32) {
              this.id = iprot.readI32();
              setIdIsSet(true);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(ID_FIELD_DESC);
      oprot.writeI32(this.id);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("scannerClose_args(");
      boolean first = true;

      sb.append("id:");
      sb.append(this.id);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class scannerClose_result implements TBase<scannerClose_result, scannerClose_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("scannerClose_result");

    private static final TField IO_FIELD_DESC = new TField("io", TType.STRUCT, (short)1);
    private static final TField IA_FIELD_DESC = new TField("ia", TType.STRUCT, (short)2);

    public IOError io;
    public IllegalArgument ia;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      IO((short)1, "io"),
      IA((short)2, "ia");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // IO
            return IO;
          case 2: // IA
            return IA;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.IO, new FieldMetaData("io", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRUCT)));
      tmpMap.put(_Fields.IA, new FieldMetaData("ia", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(scannerClose_result.class, metaDataMap);
    }

    public scannerClose_result() {
    }

    public scannerClose_result(
      IOError io,
      IllegalArgument ia)
    {
      this();
      this.io = io;
      this.ia = ia;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public scannerClose_result(scannerClose_result other) {
      if (other.isSetIo()) {
        this.io = new IOError(other.io);
      }
      if (other.isSetIa()) {
        this.ia = new IllegalArgument(other.ia);
      }
    }

    public scannerClose_result deepCopy() {
      return new scannerClose_result(this);
    }

    @Override
    public void clear() {
      this.io = null;
      this.ia = null;
    }

    public IOError getIo() {
      return this.io;
    }

    public scannerClose_result setIo(IOError io) {
      this.io = io;
      return this;
    }

    public void unsetIo() {
      this.io = null;
    }

    /** Returns true if field io is set (has been asigned a value) and false otherwise */
    public boolean isSetIo() {
      return this.io != null;
    }

    public void setIoIsSet(boolean value) {
      if (!value) {
        this.io = null;
      }
    }

    public IllegalArgument getIa() {
      return this.ia;
    }

    public scannerClose_result setIa(IllegalArgument ia) {
      this.ia = ia;
      return this;
    }

    public void unsetIa() {
      this.ia = null;
    }

    /** Returns true if field ia is set (has been asigned a value) and false otherwise */
    public boolean isSetIa() {
      return this.ia != null;
    }

    public void setIaIsSet(boolean value) {
      if (!value) {
        this.ia = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case IO:
        if (value == null) {
          unsetIo();
        } else {
          setIo((IOError)value);
        }
        break;

      case IA:
        if (value == null) {
          unsetIa();
        } else {
          setIa((IllegalArgument)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case IO:
        return getIo();

      case IA:
        return getIa();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case IO:
        return isSetIo();
      case IA:
        return isSetIa();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof scannerClose_result)
        return this.equals((scannerClose_result)that);
      return false;
    }

    public boolean equals(scannerClose_result that) {
      if (that == null)
        return false;

      boolean this_present_io = true && this.isSetIo();
      boolean that_present_io = true && that.isSetIo();
      if (this_present_io || that_present_io) {
        if (!(this_present_io && that_present_io))
          return false;
        if (!this.io.equals(that.io))
          return false;
      }

      boolean this_present_ia = true && this.isSetIa();
      boolean that_present_ia = true && that.isSetIa();
      if (this_present_ia || that_present_ia) {
        if (!(this_present_ia && that_present_ia))
          return false;
        if (!this.ia.equals(that.ia))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(scannerClose_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      scannerClose_result typedOther = (scannerClose_result)other;

      lastComparison = Boolean.valueOf(isSetIo()).compareTo(typedOther.isSetIo());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetIo()) {
        lastComparison = TBaseHelper.compareTo(this.io, typedOther.io);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetIa()).compareTo(typedOther.isSetIa());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetIa()) {
        lastComparison = TBaseHelper.compareTo(this.ia, typedOther.ia);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 1: // IO
            if (field.type == TType.STRUCT) {
              this.io = new IOError();
              this.io.read(iprot);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // IA
            if (field.type == TType.STRUCT) {
              this.ia = new IllegalArgument();
              this.ia.read(iprot);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetIo()) {
        oprot.writeFieldBegin(IO_FIELD_DESC);
        this.io.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetIa()) {
        oprot.writeFieldBegin(IA_FIELD_DESC);
        this.ia.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("scannerClose_result(");
      boolean first = true;

      sb.append("io:");
      if (this.io == null) {
        sb.append("null");
      } else {
        sb.append(this.io);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ia:");
      if (this.ia == null) {
        sb.append("null");
      } else {
        sb.append(this.ia);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class parallelGet_args implements TBase<parallelGet_args, parallelGet_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("parallelGet_args");

    private static final TField TABLE_NAME_FIELD_DESC = new TField("tableName", TType.STRING, (short)1);
    private static final TField COLUMN_FIELD_DESC = new TField("column", TType.STRING, (short)2);
    private static final TField ROWS_FIELD_DESC = new TField("rows", TType.LIST, (short)3);

    public ByteBuffer tableName;
    public ByteBuffer column;
    public List<ByteBuffer> rows;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      TABLE_NAME((short)1, "tableName"),
      COLUMN((short)2, "column"),
      ROWS((short)3, "rows");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // TABLE_NAME
            return TABLE_NAME;
          case 2: // COLUMN
            return COLUMN;
          case 3: // ROWS
            return ROWS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.TABLE_NAME, new FieldMetaData("tableName", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Text")));
      tmpMap.put(_Fields.COLUMN, new FieldMetaData("column", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRING          , "Text")));
      tmpMap.put(_Fields.ROWS, new FieldMetaData("rows", TFieldRequirementType.DEFAULT,
          new ListMetaData(TType.LIST,
              new FieldValueMetaData(TType.STRING              , "Text"))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(parallelGet_args.class, metaDataMap);
    }

    public parallelGet_args() {
    }

    public parallelGet_args(
      ByteBuffer tableName,
      ByteBuffer column,
      List<ByteBuffer> rows)
    {
      this();
      this.tableName = tableName;
      this.column = column;
      this.rows = rows;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public parallelGet_args(parallelGet_args other) {
      if (other.isSetTableName()) {
        this.tableName = other.tableName;
      }
      if (other.isSetColumn()) {
        this.column = other.column;
      }
      if (other.isSetRows()) {
        List<ByteBuffer> __this__rows = new ArrayList<ByteBuffer>();
        for (ByteBuffer other_element : other.rows) {
          __this__rows.add(other_element);
        }
        this.rows = __this__rows;
      }
    }

    public parallelGet_args deepCopy() {
      return new parallelGet_args(this);
    }

    @Override
    public void clear() {
      this.tableName = null;
      this.column = null;
      this.rows = null;
    }

    public byte[] getTableName() {
      setTableName(TBaseHelper.rightSize(tableName));
      return tableName.array();
    }

    public ByteBuffer BufferForTableName() {
      return tableName;
    }

    public parallelGet_args setTableName(byte[] tableName) {
      setTableName(ByteBuffer.wrap(tableName));
      return this;
    }

    public parallelGet_args setTableName(ByteBuffer tableName) {
      this.tableName = tableName;
      return this;
    }

    public void unsetTableName() {
      this.tableName = null;
    }

    /** Returns true if field tableName is set (has been asigned a value) and false otherwise */
    public boolean isSetTableName() {
      return this.tableName != null;
    }

    public void setTableNameIsSet(boolean value) {
      if (!value) {
        this.tableName = null;
      }
    }

    public byte[] getColumn() {
      setColumn(TBaseHelper.rightSize(column));
      return column.array();
    }

    public ByteBuffer BufferForColumn() {
      return column;
    }

    public parallelGet_args setColumn(byte[] column) {
      setColumn(ByteBuffer.wrap(column));
      return this;
    }

    public parallelGet_args setColumn(ByteBuffer column) {
      this.column = column;
      return this;
    }

    public void unsetColumn() {
      this.column = null;
    }

    /** Returns true if field column is set (has been asigned a value) and false otherwise */
    public boolean isSetColumn() {
      return this.column != null;
    }

    public void setColumnIsSet(boolean value) {
      if (!value) {
        this.column = null;
      }
    }

    public int getRowsSize() {
      return (this.rows == null) ? 0 : this.rows.size();
    }

    public java.util.Iterator<ByteBuffer> getRowsIterator() {
      return (this.rows == null) ? null : this.rows.iterator();
    }

    public void addToRows(ByteBuffer elem) {
      if (this.rows == null) {
        this.rows = new ArrayList<ByteBuffer>();
      }
      this.rows.add(elem);
    }

    public List<ByteBuffer> getRows() {
      return this.rows;
    }

    public parallelGet_args setRows(List<ByteBuffer> rows) {
      this.rows = rows;
      return this;
    }

    public void unsetRows() {
      this.rows = null;
    }

    /** Returns true if field rows is set (has been asigned a value) and false otherwise */
    public boolean isSetRows() {
      return this.rows != null;
    }

    public void setRowsIsSet(boolean value) {
      if (!value) {
        this.rows = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TABLE_NAME:
        if (value == null) {
          unsetTableName();
        } else {
          setTableName((ByteBuffer)value);
        }
        break;

      case COLUMN:
        if (value == null) {
          unsetColumn();
        } else {
          setColumn((ByteBuffer)value);
        }
        break;

      case ROWS:
        if (value == null) {
          unsetRows();
        } else {
          setRows((List<ByteBuffer>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return getTableName();

      case COLUMN:
        return getColumn();

      case ROWS:
        return getRows();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case TABLE_NAME:
        return isSetTableName();
      case COLUMN:
        return isSetColumn();
      case ROWS:
        return isSetRows();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof parallelGet_args)
        return this.equals((parallelGet_args)that);
      return false;
    }

    public boolean equals(parallelGet_args that) {
      if (that == null)
        return false;

      boolean this_present_tableName = true && this.isSetTableName();
      boolean that_present_tableName = true && that.isSetTableName();
      if (this_present_tableName || that_present_tableName) {
        if (!(this_present_tableName && that_present_tableName))
          return false;
        if (!this.tableName.equals(that.tableName))
          return false;
      }

      boolean this_present_column = true && this.isSetColumn();
      boolean that_present_column = true && that.isSetColumn();
      if (this_present_column || that_present_column) {
        if (!(this_present_column && that_present_column))
          return false;
        if (!this.column.equals(that.column))
          return false;
      }

      boolean this_present_rows = true && this.isSetRows();
      boolean that_present_rows = true && that.isSetRows();
      if (this_present_rows || that_present_rows) {
        if (!(this_present_rows && that_present_rows))
          return false;
        if (!this.rows.equals(that.rows))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(parallelGet_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      parallelGet_args typedOther = (parallelGet_args)other;

      lastComparison = Boolean.valueOf(isSetTableName()).compareTo(typedOther.isSetTableName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTableName()) {
        lastComparison = TBaseHelper.compareTo(this.tableName, typedOther.tableName);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetColumn()).compareTo(typedOther.isSetColumn());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetColumn()) {
        lastComparison = TBaseHelper.compareTo(this.column, typedOther.column);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetRows()).compareTo(typedOther.isSetRows());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetRows()) {
        lastComparison = TBaseHelper.compareTo(this.rows, typedOther.rows);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 1: // TABLE_NAME
            if (field.type == TType.STRING) {
              this.tableName = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // COLUMN
            if (field.type == TType.STRING) {
              this.column = iprot.readBinary();
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // ROWS
            if (field.type == TType.LIST) {
              {
                TList _list146 = iprot.readListBegin();
                this.rows = new ArrayList<ByteBuffer>(_list146.size);
                for (int _i147 = 0; _i147 < _list146.size; ++_i147)
                {
                  ByteBuffer _elem148;
                  _elem148 = iprot.readBinary();
                  this.rows.add(_elem148);
                }
                iprot.readListEnd();
              }
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tableName != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeBinary(this.tableName);
        oprot.writeFieldEnd();
      }
      if (this.column != null) {
        oprot.writeFieldBegin(COLUMN_FIELD_DESC);
        oprot.writeBinary(this.column);
        oprot.writeFieldEnd();
      }
      if (this.rows != null) {
        oprot.writeFieldBegin(ROWS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.rows.size()));
          for (ByteBuffer _iter149 : this.rows)
          {
            oprot.writeBinary(_iter149);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("parallelGet_args(");
      boolean first = true;

      sb.append("tableName:");
      if (this.tableName == null) {
        sb.append("null");
      } else {
        sb.append(this.tableName);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("column:");
      if (this.column == null) {
        sb.append("null");
      } else {
        sb.append(this.column);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("rows:");
      if (this.rows == null) {
        sb.append("null");
      } else {
        sb.append(this.rows);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class parallelGet_result implements TBase<parallelGet_result, parallelGet_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("parallelGet_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField IO_FIELD_DESC = new TField("io", TType.STRUCT, (short)1);

    public List<TRowResult> success;
    public IOError io;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      IO((short)1, "io");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // IO
            return IO;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT,
          new ListMetaData(TType.LIST,
              new StructMetaData(TType.STRUCT, TRowResult.class))));
      tmpMap.put(_Fields.IO, new FieldMetaData("io", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(parallelGet_result.class, metaDataMap);
    }

    public parallelGet_result() {
    }

    public parallelGet_result(
      List<TRowResult> success,
      IOError io)
    {
      this();
      this.success = success;
      this.io = io;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public parallelGet_result(parallelGet_result other) {
      if (other.isSetSuccess()) {
        List<TRowResult> __this__success = new ArrayList<TRowResult>();
        for (TRowResult other_element : other.success) {
          __this__success.add(new TRowResult(other_element));
        }
        this.success = __this__success;
      }
      if (other.isSetIo()) {
        this.io = new IOError(other.io);
      }
    }

    public parallelGet_result deepCopy() {
      return new parallelGet_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.io = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<TRowResult> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(TRowResult elem) {
      if (this.success == null) {
        this.success = new ArrayList<TRowResult>();
      }
      this.success.add(elem);
    }

    public List<TRowResult> getSuccess() {
      return this.success;
    }

    public parallelGet_result setSuccess(List<TRowResult> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public IOError getIo() {
      return this.io;
    }

    public parallelGet_result setIo(IOError io) {
      this.io = io;
      return this;
    }

    public void unsetIo() {
      this.io = null;
    }

    /** Returns true if field io is set (has been asigned a value) and false otherwise */
    public boolean isSetIo() {
      return this.io != null;
    }

    public void setIoIsSet(boolean value) {
      if (!value) {
        this.io = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<TRowResult>)value);
        }
        break;

      case IO:
        if (value == null) {
          unsetIo();
        } else {
          setIo((IOError)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case IO:
        return getIo();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case IO:
        return isSetIo();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof parallelGet_result)
        return this.equals((parallelGet_result)that);
      return false;
    }

    public boolean equals(parallelGet_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_io = true && this.isSetIo();
      boolean that_present_io = true && that.isSetIo();
      if (this_present_io || that_present_io) {
        if (!(this_present_io && that_present_io))
          return false;
        if (!this.io.equals(that.io))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(parallelGet_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      parallelGet_result typedOther = (parallelGet_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetIo()).compareTo(typedOther.isSetIo());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetIo()) {
        lastComparison = TBaseHelper.compareTo(this.io, typedOther.io);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list150 = iprot.readListBegin();
                this.success = new ArrayList<TRowResult>(_list150.size);
                for (int _i151 = 0; _i151 < _list150.size; ++_i151)
                {
                  TRowResult _elem152;
                  _elem152 = new TRowResult();
                  _elem152.read(iprot);
                  this.success.add(_elem152);
                }
                iprot.readListEnd();
              }
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // IO
            if (field.type == TType.STRUCT) {
              this.io = new IOError();
              this.io.read(iprot);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (TRowResult _iter153 : this.success)
          {
            _iter153.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetIo()) {
        oprot.writeFieldBegin(IO_FIELD_DESC);
        this.io.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("parallelGet_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("io:");
      if (this.io == null) {
        sb.append("null");
      } else {
        sb.append(this.io);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class asyncAtomicIncrements_args implements TBase<asyncAtomicIncrements_args, asyncAtomicIncrements_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("asyncAtomicIncrements_args");

    private static final TField INCREMENTS_FIELD_DESC = new TField("increments", TType.LIST, (short)1);

    public List<Increment> increments;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      INCREMENTS((short)1, "increments");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // INCREMENTS
            return INCREMENTS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.INCREMENTS, new FieldMetaData("increments", TFieldRequirementType.DEFAULT,
          new ListMetaData(TType.LIST,
              new StructMetaData(TType.STRUCT, Increment.class))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(asyncAtomicIncrements_args.class, metaDataMap);
    }

    public asyncAtomicIncrements_args() {
    }

    public asyncAtomicIncrements_args(
      List<Increment> increments)
    {
      this();
      this.increments = increments;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public asyncAtomicIncrements_args(asyncAtomicIncrements_args other) {
      if (other.isSetIncrements()) {
        List<Increment> __this__increments = new ArrayList<Increment>();
        for (Increment other_element : other.increments) {
          __this__increments.add(new Increment(other_element));
        }
        this.increments = __this__increments;
      }
    }

    public asyncAtomicIncrements_args deepCopy() {
      return new asyncAtomicIncrements_args(this);
    }

    @Override
    public void clear() {
      this.increments = null;
    }

    public int getIncrementsSize() {
      return (this.increments == null) ? 0 : this.increments.size();
    }

    public java.util.Iterator<Increment> getIncrementsIterator() {
      return (this.increments == null) ? null : this.increments.iterator();
    }

    public void addToIncrements(Increment elem) {
      if (this.increments == null) {
        this.increments = new ArrayList<Increment>();
      }
      this.increments.add(elem);
    }

    public List<Increment> getIncrements() {
      return this.increments;
    }

    public asyncAtomicIncrements_args setIncrements(List<Increment> increments) {
      this.increments = increments;
      return this;
    }

    public void unsetIncrements() {
      this.increments = null;
    }

    /** Returns true if field increments is set (has been asigned a value) and false otherwise */
    public boolean isSetIncrements() {
      return this.increments != null;
    }

    public void setIncrementsIsSet(boolean value) {
      if (!value) {
        this.increments = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case INCREMENTS:
        if (value == null) {
          unsetIncrements();
        } else {
          setIncrements((List<Increment>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case INCREMENTS:
        return getIncrements();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case INCREMENTS:
        return isSetIncrements();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof asyncAtomicIncrements_args)
        return this.equals((asyncAtomicIncrements_args)that);
      return false;
    }

    public boolean equals(asyncAtomicIncrements_args that) {
      if (that == null)
        return false;

      boolean this_present_increments = true && this.isSetIncrements();
      boolean that_present_increments = true && that.isSetIncrements();
      if (this_present_increments || that_present_increments) {
        if (!(this_present_increments && that_present_increments))
          return false;
        if (!this.increments.equals(that.increments))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(asyncAtomicIncrements_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      asyncAtomicIncrements_args typedOther = (asyncAtomicIncrements_args)other;

      lastComparison = Boolean.valueOf(isSetIncrements()).compareTo(typedOther.isSetIncrements());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetIncrements()) {
        lastComparison = TBaseHelper.compareTo(this.increments, typedOther.increments);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 1: // INCREMENTS
            if (field.type == TType.LIST) {
              {
                TList _list154 = iprot.readListBegin();
                this.increments = new ArrayList<Increment>(_list154.size);
                for (int _i155 = 0; _i155 < _list154.size; ++_i155)
                {
                  Increment _elem156;
                  _elem156 = new Increment();
                  _elem156.read(iprot);
                  this.increments.add(_elem156);
                }
                iprot.readListEnd();
              }
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.increments != null) {
        oprot.writeFieldBegin(INCREMENTS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.increments.size()));
          for (Increment _iter157 : this.increments)
          {
            _iter157.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("asyncAtomicIncrements_args(");
      boolean first = true;

      sb.append("increments:");
      if (this.increments == null) {
        sb.append("null");
      } else {
        sb.append(this.increments);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class queueIncrementColumnValues_args implements TBase<queueIncrementColumnValues_args, queueIncrementColumnValues_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("queueIncrementColumnValues_args");

    private static final TField INCREMENTS_FIELD_DESC = new TField("increments", TType.LIST, (short)1);

    public List<Increment> increments;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      INCREMENTS((short)1, "increments");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // INCREMENTS
            return INCREMENTS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.INCREMENTS, new FieldMetaData("increments", TFieldRequirementType.DEFAULT,
          new ListMetaData(TType.LIST,
              new StructMetaData(TType.STRUCT, Increment.class))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(queueIncrementColumnValues_args.class, metaDataMap);
    }

    public queueIncrementColumnValues_args() {
    }

    public queueIncrementColumnValues_args(
      List<Increment> increments)
    {
      this();
      this.increments = increments;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public queueIncrementColumnValues_args(queueIncrementColumnValues_args other) {
      if (other.isSetIncrements()) {
        List<Increment> __this__increments = new ArrayList<Increment>();
        for (Increment other_element : other.increments) {
          __this__increments.add(new Increment(other_element));
        }
        this.increments = __this__increments;
      }
    }

    public queueIncrementColumnValues_args deepCopy() {
      return new queueIncrementColumnValues_args(this);
    }

    @Override
    public void clear() {
      this.increments = null;
    }

    public int getIncrementsSize() {
      return (this.increments == null) ? 0 : this.increments.size();
    }

    public java.util.Iterator<Increment> getIncrementsIterator() {
      return (this.increments == null) ? null : this.increments.iterator();
    }

    public void addToIncrements(Increment elem) {
      if (this.increments == null) {
        this.increments = new ArrayList<Increment>();
      }
      this.increments.add(elem);
    }

    public List<Increment> getIncrements() {
      return this.increments;
    }

    public queueIncrementColumnValues_args setIncrements(List<Increment> increments) {
      this.increments = increments;
      return this;
    }

    public void unsetIncrements() {
      this.increments = null;
    }

    /** Returns true if field increments is set (has been asigned a value) and false otherwise */
    public boolean isSetIncrements() {
      return this.increments != null;
    }

    public void setIncrementsIsSet(boolean value) {
      if (!value) {
        this.increments = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case INCREMENTS:
        if (value == null) {
          unsetIncrements();
        } else {
          setIncrements((List<Increment>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case INCREMENTS:
        return getIncrements();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case INCREMENTS:
        return isSetIncrements();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof queueIncrementColumnValues_args)
        return this.equals((queueIncrementColumnValues_args)that);
      return false;
    }

    public boolean equals(queueIncrementColumnValues_args that) {
      if (that == null)
        return false;

      boolean this_present_increments = true && this.isSetIncrements();
      boolean that_present_increments = true && that.isSetIncrements();
      if (this_present_increments || that_present_increments) {
        if (!(this_present_increments && that_present_increments))
          return false;
        if (!this.increments.equals(that.increments))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(queueIncrementColumnValues_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      queueIncrementColumnValues_args typedOther = (queueIncrementColumnValues_args)other;

      lastComparison = Boolean.valueOf(isSetIncrements()).compareTo(typedOther.isSetIncrements());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetIncrements()) {
        lastComparison = TBaseHelper.compareTo(this.increments, typedOther.increments);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 1: // INCREMENTS
            if (field.type == TType.LIST) {
              {
                TList _list158 = iprot.readListBegin();
                this.increments = new ArrayList<Increment>(_list158.size);
                for (int _i159 = 0; _i159 < _list158.size; ++_i159)
                {
                  Increment _elem160;
                  _elem160 = new Increment();
                  _elem160.read(iprot);
                  this.increments.add(_elem160);
                }
                iprot.readListEnd();
              }
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.increments != null) {
        oprot.writeFieldBegin(INCREMENTS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.increments.size()));
          for (Increment _iter161 : this.increments)
          {
            _iter161.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("queueIncrementColumnValues_args(");
      boolean first = true;

      sb.append("increments:");
      if (this.increments == null) {
        sb.append("null");
      } else {
        sb.append(this.increments);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class queueIncrementColumnValues_result implements TBase<queueIncrementColumnValues_result, queueIncrementColumnValues_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("queueIncrementColumnValues_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.BOOL, (short)0);

    public boolean success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT,
          new FieldValueMetaData(TType.BOOL)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(queueIncrementColumnValues_result.class, metaDataMap);
    }

    public queueIncrementColumnValues_result() {
    }

    public queueIncrementColumnValues_result(
      boolean success)
    {
      this();
      this.success = success;
      setSuccessIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public queueIncrementColumnValues_result(queueIncrementColumnValues_result other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.success = other.success;
    }

    public queueIncrementColumnValues_result deepCopy() {
      return new queueIncrementColumnValues_result(this);
    }

    @Override
    public void clear() {
      setSuccessIsSet(false);
      this.success = false;
    }

    public boolean isSuccess() {
      return this.success;
    }

    public queueIncrementColumnValues_result setSuccess(boolean success) {
      this.success = success;
      setSuccessIsSet(true);
      return this;
    }

    public void unsetSuccess() {
      __isset_bit_vector.clear(__SUCCESS_ISSET_ID);
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return __isset_bit_vector.get(__SUCCESS_ISSET_ID);
    }

    public void setSuccessIsSet(boolean value) {
      __isset_bit_vector.set(__SUCCESS_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Boolean)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return new Boolean(isSuccess());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof queueIncrementColumnValues_result)
        return this.equals((queueIncrementColumnValues_result)that);
      return false;
    }

    public boolean equals(queueIncrementColumnValues_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(queueIncrementColumnValues_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      queueIncrementColumnValues_result typedOther = (queueIncrementColumnValues_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) {
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.BOOL) {
              this.success = iprot.readBool();
              setSuccessIsSet(true);
            } else {
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeBool(this.success);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("queueIncrementColumnValues_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

}
